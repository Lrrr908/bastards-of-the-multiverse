<!DOCTYPE html>
<!--
===============================================================================
                    COLOR MANAGEMENT SYSTEM - HARD RULES
===============================================================================

All color libraries are based on real, physical materials scanned with a
spectrophotometer. Those scans describe how a color looks in real life under
standard lighting (D50), not how it looks on a phone or monitor.

CANONICAL FORMAT: ICC PCS Lab (D50)
───────────────────────────────────
Lab(D50) in this system represents ICC Profile Connection Space (PCS) Lab,
not generic Lab. This is the industry standard used by:
  • ICC color profiles (v2 and v4)
  • Spectrophotometer manufacturers (X-Rite, Datacolor, etc.)
  • Print industry workflows (GRACoL, SWOP, Fogra)
  • Adobe applications (Photoshop, Illustrator)

Every color in the system must ultimately live in Lab(D50) / ICC PCS Lab.

HARD RULES (NEVER VIOLATE):
───────────────────────────
❌ NEVER compare Lab(D65) to Lab(D50) - illuminants must match for valid ΔE
❌ NEVER store RGB or HEX as truth - these are display approximations only  
❌ NEVER do ΔE calculations outside Lab(D50) - results will be wrong
✔  ALWAYS convert to Lab(D50) before any matching, ranking, averaging, or ΔE

PIPELINE:
─────────
• Spectro scans      → Already Lab(D50), store directly
• User HEX/RGB input → sRGB(D65) → XYZ(D65) → CAT16 → XYZ(D50) → Lab(D50)
• Screen display     → Lab(D50) → XYZ(D50) → CAT16 → XYZ(D65) → sRGB (preview only)
• CMYK input/output  → LittleCMS + GRACoL2013.icc (ICC PCS Lab as connection space)
• All matching logic → Happens in Lab(D50)

CHROMATIC ADAPTATION:
─────────────────────
• RGB ↔ Lab: CAT16 (CIE 2016) - better for blues and extreme saturations
• CMYK ↔ Lab: LittleCMS with ICC profile internal adaptation (preserves PCS)

RENDERING INTENTS:
──────────────────
This system supports ICC rendering intents for Lab → CMYK conversions:
  • 0 = Perceptual      - Compresses gamut, preserves relationships (photos)
  • 1 = Relative        - Maps white point, clips out-of-gamut (default, logos)
  • 2 = Saturation      - Maximizes saturation (business graphics)
  • 3 = Absolute        - No white point mapping (proofing)

⚠️  ΔE values WILL CHANGE across rendering intents - this is expected behavior.
    Different intents map out-of-gamut colors differently, resulting in
    different Lab values after the Lab → CMYK → Lab roundtrip.

WHAT WE ARE NOT DOING:
──────────────────────
• We are NOT trying to make the screen match perfectly
• We are NOT trusting RGB as a measurement  
• We are NOT skipping white-point adaptation
• We are NOT mixing Lab(D65) and Lab(D50) in ΔE math

FUTURE CONSIDERATIONS (Optional):
─────────────────────────────────
• CAM02-UCS or CAM16-UCS could be explored for UI ranking experiments
  (perceptual uniformity improvements over CIEDE2000)
• These would be OPTIONAL and should NEVER replace Lab(D50) as storage
• Lab(D50) / ICC PCS Lab remains the canonical storage format

Think of it like this:
  Lab(D50) = real-world color truth (ICC PCS)
  RGB/HEX  = display approximation (best-effort preview only)
  CMYK     = device-dependent output (requires ICC profile)

===============================================================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Match Widget</title>
    <script src="plotly-2.35.2.min.js"></script>
    <style>
        .cmw-wrap {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 600px;
            margin: 30px auto;
            padding: 0 20px;
            background: #ffffff;
        }

        .cmw-wrap h5 {
            font-size: 2.2rem;
            margin: 0 0 32px;
            font-weight: 800;
            color: #0065a3;
            text-align: center;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0, 101, 163, 0.1);
        }

        .cmw-section {
            margin-bottom: 24px;
            padding: 24px;
            border: 2px solid #e2e8f0;
            border-radius: 16px;
            background: #ffffff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .cmw-section:hover {
            border-color: #cbd5e1;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .cmw-section h6 {
            font-size: 1.1rem;
            margin: 0 0 20px;
            font-weight: 600;
            color: #374151;
            text-align: center;
        }

        /* New Search Form Layout */
        .cmw-search-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
        }

        .cmw-search-swatches {
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: flex-start;
        }

        .cmw-search-swatch-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .cmw-search-intent-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #e2e8f0;
            background: #f0f0f0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-search-intent-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-search-color-info {
            text-align: center;
            padding: 12px 16px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            min-width: 200px;
        }

        .cmw-search-info-title {
            font-size: 12px;
            color: #6b7280;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .cmw-search-info-value {
            font-size: 14px;
            color: #374151;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .cmw-search-name-input {
            width: 100%;
            max-width: 400px;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
        }

        .cmw-search-name-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        /* Legacy styles for compatibility */
        .cmw-input-group {
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
        }

        .cmw-values-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .cmw-value-type-selector {
            display: flex;
            justify-content: center;
            margin-bottom: 16px;
        }

        .cmw-value-type-select {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            color: #374151;
            cursor: pointer;
            min-width: 180px;
            text-align: center;
        }

        .cmw-value-type-select:focus {
            outline: none;
            border-color: #0065a3;
            box-shadow: 0 0 0 3px rgba(0, 101, 163, 0.1);
        }

        .cmw-color-preview-container {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            margin: 16px auto;
            flex-wrap: wrap;
            min-height: 80px;
            position: relative;
        }

        .cmw-color-preview {
            width: 80px;
            height: 80px;
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            background: #f8fafc;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
            position: relative;
            display: block;
            flex-shrink: 0;
            cursor: pointer;
        }

        .cmw-color-preview:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-color-preview::after {
            display: none;
        }

        .cmw-color-preview.valid::after {
            display: none;
        }

        .cmw-color-preview.selected {
            /* No blue border for main swatch */
            box-shadow: none;
        }

        .cmw-selected-color-info {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            min-width: 180px;
            max-width: 250px;
            flex-shrink: 0;
            position: relative;
        }

        .cmw-selected-color-info.show {
            display: flex;
        }

        .cmw-selected-color-library {
            font-size: 15px;
            color: #374151;
            text-align: center;
            font-weight: 600;
        }

        .cmw-selected-color-lab {
            font-size: 13px;
            color: #4b5563;
            text-align: center;
            font-family: 'Courier New', monospace;
            background: #ffffff;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }

        .cmw-converted-cmyk {
            font-size: 12px;
            color: #6b7280;
            text-align: center;
            font-family: 'Courier New', monospace;
            background: #f8fafc;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
            margin-top: 8px;
        }

        .cmw-value-inputs {
            display: none;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .cmw-value-inputs.active {
            display: flex;
        }

        .cmw-wrap input {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            transition: all 0.2s;
            background: #ffffff;
            width: 100%;
            max-width: 350px;
        }

        .cmw-wrap input:focus {
            outline: none;
            border-color: #0065a3;
            box-shadow: 0 0 0 3px rgba(0, 101, 163, 0.1);
        }

        .cmw-wrap input[readonly] {
            background: #f8fafc;
            color: #6b7280;
            cursor: default;
        }

        /* Legacy styles removed - now using .cmw-sample-input-group and .cmw-sample-input-field */

        .cmw-wrap button {
            padding: 12px 32px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border: 2px solid #0065a3;
            background: #0065a3;
            color: white;
            border-radius: 8px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .cmw-wrap button:hover {
            background: #004d7a;
            border-color: #004d7a;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 101, 163, 0.3);
        }

        .cmw-wrap button:active {
            transform: translateY(0);
        }

        .cmw-wrap button:disabled {
            background: #9ca3af;
            border-color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .cmw-library-toggles {
            margin-bottom: 24px;
            padding: 20px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .cmw-library-toggles h6 {
            font-size: 1.1rem;
            margin: 0 0 16px;
            font-weight: 600;
            color: #374151;
            text-align: center;
        }

        .cmw-toggle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .cmw-toggle-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #f8fafc;
            border-radius: 8px;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .cmw-toggle-item:hover {
            background: #f1f5f9;
            border-color: #e2e8f0;
        }

        .cmw-toggle-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #0065a3;
        }

        .cmw-toggle-item label {
            cursor: pointer;
            font-size: 15px;
            color: #374151;
            user-select: none;
            font-weight: 500;
        }

        .cmw-library-count {
            font-size: 0.9em;
            color: #6b7280;
            margin-left: 4px;
        }

        .cmw-profile-selector {
            margin-top: 16px;
            text-align: center;
        }

        .cmw-profile-select {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            color: #374151;
            cursor: pointer;
            margin-left: 8px;
        }

        .cmw-loading {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 20px 0;
            color: #6b7280;
        }

        .cmw-loading.show {
            display: flex;
        }

        .cmw-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f4f6;
            border-top: 2px solid #0065a3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .cmw-status {
            margin: 16px 0;
            padding: 12px;
            border-radius: 8px;
            display: none;
            text-align: center;
            font-weight: 500;
        }

        .cmw-status.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .cmw-status.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }

        .cmw-status.warning {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fde68a;
        }

        .cmw-status.show {
            display: block;
        }

        .cmw-wrap table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 24px;
            background: #ffffff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .cmw-wrap th,
        .cmw-wrap td {
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            text-align: left;
        }

        .cmw-wrap th {
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
        }

        .cmw-wrap td {
            color: #1f2937;
        }

        .cmw-swatch {
            width: 60px;
            height: 30px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* Color Info Modal */
        .cmw-color-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .cmw-color-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .cmw-color-modal {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 380px;
            width: 90%;
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.2s ease;
        }

        .cmw-color-modal-overlay.show .cmw-color-modal {
            transform: scale(1);
        }

        .cmw-color-modal-swatch {
            height: 120px;
            width: 100%;
            position: relative;
        }

        .cmw-color-modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }

        .cmw-color-modal-close:hover {
            background: #ffffff;
        }

        .cmw-color-modal-name {
            padding: 16px 20px 8px;
            font-size: 18px;
            font-weight: 700;
            color: #1f2937;
            text-align: center;
        }

        .cmw-color-modal-values {
            padding: 8px 20px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cmw-color-value-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: #f8fafc;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .cmw-color-value-row:hover {
            background: #e2e8f0;
        }

        .cmw-color-value-label {
            font-weight: 600;
            color: #6b7280;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .cmw-color-value-data {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 14px;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cmw-color-copy-icon {
            opacity: 0.4;
            font-size: 12px;
            transition: opacity 0.15s ease;
        }

        .cmw-color-value-row:hover .cmw-color-copy-icon {
            opacity: 1;
        }

        .cmw-color-copied {
            background: #dcfce7 !important;
        }

        /* Modal Add to Library Section */
        .cmw-modal-purchase-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 20px;
            border-top: 1px solid #e2e8f0;
            margin-top: 8px;
        }

        .cmw-modal-purchase-btn {
            display: inline-block;
            padding: 12px 16px;
            background: linear-gradient(135deg, #FF9900 0%, #FF7700 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .cmw-modal-purchase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            background: linear-gradient(135deg, #FFB84D 0%, #FF8833 100%);
        }

        .cmw-modal-manufacturer-btn {
            background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
        }

        .cmw-modal-manufacturer-btn:hover {
            background: linear-gradient(135deg, #0077c2 0%, #0065a3 100%);
        }

        .cmw-modal-add-library {
            border-top: 1px solid #e2e8f0;
            margin-top: 8px;
        }

        .cmw-modal-add-header {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            color: #0065a3;
            cursor: pointer;
            text-align: center;
            transition: background 0.15s ease;
        }

        .cmw-modal-add-header:hover {
            background: #f0f9ff;
        }

        .cmw-modal-add-content {
            padding: 0 20px 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cmw-modal-input {
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
        }

        .cmw-modal-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-modal-library-row {
            display: flex;
            gap: 8px;
        }

        .cmw-modal-select {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            background: #fff;
            cursor: pointer;
        }

        .cmw-modal-select:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-modal-new-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #0065a3;
            border-radius: 8px;
            background: #fff;
            color: #0065a3;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .cmw-modal-new-btn:hover {
            background: #0065a3;
            color: #fff;
        }

        .cmw-modal-new-lib-row {
            display: flex;
            gap: 8px;
        }

        .cmw-modal-new-lib-row .cmw-modal-input {
            flex: 1;
        }

        .cmw-modal-create-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            background: #10b981;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .cmw-modal-create-btn:hover {
            background: #059669;
        }

        .cmw-modal-add-btn {
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            background: #0065a3;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .cmw-modal-add-btn:hover {
            background: #004d7a;
        }

        .cmw-modal-add-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .cmw-modal-add-status {
            font-size: 13px;
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            display: none;
        }

        .cmw-modal-add-status.success {
            display: block;
            background: #dcfce7;
            color: #166534;
        }

        .cmw-modal-add-status.error {
            display: block;
            background: #fee2e2;
            color: #991b1b;
        }

        .cmw-suggestions {
            margin-top: 12px;
            padding: 0;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            display: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            max-width: 350px;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            position: relative;
            z-index: 100;
        }

        .cmw-suggestions.show {
            display: block;
        }

        .cmw-suggestions-header {
            position: sticky;
            top: 0;
            background: #f9fafb;
            padding: 12px;
            font-weight: 600;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            z-index: 10;
        }

        .cmw-suggestions-content {
            padding: 8px;
        }

        .cmw-suggestion {
            cursor: pointer;
            padding: 10px 12px;
            margin: 2px 0;
            border-radius: 6px;
            transition: background 0.1s ease;
            color: #374151;
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cmw-suggestion:hover {
            background: #0065a3;
            color: white;
            border-color: #0065a3;
        }

        .cmw-suggestion:active {
            background: #004d7a;
            transform: none;
        }

        .cmw-suggestion-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            flex-shrink: 0;
        }

        .cmw-suggestion-info {
            flex: 1;
            min-width: 0;
        }

        .cmw-suggestion-name {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cmw-suggestion-library {
            font-size: 11px;
            color: #9ca3af;
        }

        .cmw-suggestion:hover .cmw-suggestion-library {
            color: #e0e7ff;
        }

        @media (max-width: 768px) {
            .cmw-suggestion {
                padding: 12px 14px;
                min-height: 48px;
            }
            
            .cmw-suggestion-swatch {
                width: 32px;
                height: 32px;
            }
           
            .cmw-suggestion:hover {
                background: #f8fafc;
                color: #374151;
                border-color: #e5e7eb;
            }
            
            .cmw-suggestion:hover .cmw-suggestion-library {
                color: #9ca3af;
            }
           
            .cmw-suggestion:active,
            .cmw-suggestion:focus {
                background: #0065a3;
                color: white;
                border-color: #0065a3;
            }
            
            .cmw-suggestion:active .cmw-suggestion-library,
            .cmw-suggestion:focus .cmw-suggestion-library {
                color: #e0e7ff;
            }
        }

        .cmw-brand-hint {
            color: #6b7280;
            font-size: 0.9em;
        }
        
        .cmw-suggestion:hover .cmw-brand-hint {
            color: #e0e7ff;
        }

        .cmw-disabled-library {
            opacity: 0.6;
        }

        .cmw-loading-more {
            display: none;
            text-align: center;
            padding: 12px;
            color: #6b7280;
            font-style: italic;
            border-top: 1px solid #e5e7eb;
        }

        .cmw-loading-more.show {
            display: block;
        }

        .cmw-no-more-results {
            display: none;
            text-align: center;
            padding: 12px;
            color: #9ca3af;
            font-style: italic;
            font-size: 0.9em;
            border-top: 1px solid #e5e7eb;
        }

        .cmw-no-more-results.show {
            display: block;
        }

        .cmw-api-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-left: 8px;
            display: inline-block;
        }

        .cmw-api-status.enhanced {
            background: #d1fae5;
            color: #065f46;
        }

        .cmw-api-status.fallback {
            background: #fef3c7;
            color: #92400e;
        }

        /* Collapsible Settings Styles - Blue Arrow Style */
        .cmw-settings-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 8px 0;
            color: #0065a3;
            font-weight: 500;
        }

        .cmw-settings-toggle:hover {
            color: #004d7a;
        }

        .cmw-settings-caret {
            font-size: 12px;
            transition: transform 0.2s ease;
            display: inline-block;
        }

        .cmw-settings-toggle.collapsed .cmw-settings-caret {
            transform: rotate(0deg);
        }

        .cmw-settings-toggle:not(.collapsed) .cmw-settings-caret {
            transform: rotate(90deg);
        }

        .cmw-settings-label {
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
        }

        .cmw-settings-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(to right, #e2e8f0, #e2e8f0 80%, transparent);
            margin-left: 8px;
        }

        .cmw-settings-content {
            max-height: 3000px;
            overflow: visible;
            transition: max-height 0.3s ease-out;
            padding-bottom: 10px;
        }

        .cmw-settings-content.collapsed {
            max-height: 0;
            overflow: hidden;
            padding-bottom: 0;
        }

        /* Gamut Warning Styles */
        .cmw-gamut-warning {
            display: none;
            margin: 8px 0;
            padding: 8px 12px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
            border-radius: 6px;
            font-size: 12px;
            text-align: center;
            font-weight: 500;
        }

        .cmw-gamut-warning.show {
            display: block;
        }

        .cmw-gamut-warning.out-of-gamut {
            background: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
        }

        .cmw-gamut-icon {
            margin-right: 4px;
        }

        /* Color Harmonies Styles */
        .cmw-harmony-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
            margin-top: 16px;
        }

        .cmw-harmony-color {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            min-width: 160px;
            transition: all 0.2s;
        }

        .cmw-harmony-color:hover {
            border-color: #0065a3;
            box-shadow: 0 4px 8px rgba(0, 101, 163, 0.1);
        }

        .cmw-harmony-swatch {
            width: 60px;
            height: 60px;
            cursor: pointer;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 12px;
            position: relative;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-harmony-swatch::after {
            display: none;
        }

        .cmw-harmony-swatch.in-gamut::after {
            display: none;
        }

        .cmw-harmony-swatch:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-harmony-info {
            text-align: center;
            width: 100%;
        }

        .cmw-harmony-type {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .cmw-harmony-match {
            font-size: 13px;
            color: #374151;
            font-weight: 600;
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .cmw-harmony-brand {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 6px;
        }

        .cmw-harmony-delta {
            font-size: 11px;
            color: #4b5563;
            font-family: 'Courier New', monospace;
            background: #ffffff;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
        }

        .cmw-harmony-lab {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
            margin-top: 4px;
        }

        .cmw-harmony-cmyk {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
            margin-top: 4px;
        }

        .cmw-harmony-hex {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
            margin-top: 4px;
        }

        /* Rendering Intent Comparison Styles */
        .cmw-intents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .cmw-intent-card {
            display: flex;
            flex-direction: column;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            transition: all 0.2s;
        }

        .cmw-intent-card:hover {
            border-color: #0065a3;
            box-shadow: 0 4px 8px rgba(0, 101, 163, 0.1);
        }

        .cmw-intent-card.current {
            border-color: #0065a3;
            background: #f0f8ff;
        }

        .cmw-intent-swatch {
            width: 100%;
            height: 60px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 12px;
            background: #f8fafc;
            position: relative;
            transition: all 0.2s;
            cursor: pointer;
        }

        .cmw-intent-swatch:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .cmw-intent-swatch::after {
            content: '⚠';
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 14px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #92400e;
        }

        .cmw-intent-swatch.in-gamut::after {
            content: '✓';
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
        }

        .cmw-intent-swatch.no-gamut-indicator::after {
            display: none;
        }

        .cmw-intent-info {
            flex: 1;
        }

        .cmw-intent-name {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }

        .cmw-intent-delta {
            font-size: 12px;
            color: #4b5563;
            font-family: 'Courier New', monospace;
            margin-bottom: 6px;
        }

        .cmw-intent-desc {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .cmw-intent-lab {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .cmw-wrap {
                padding: 0 16px;
                max-width: 100%;
            }

            .cmw-wrap h5 {
                font-size: 1.5rem;
                margin-bottom: 24px;
            }

            .cmw-section {
                padding: 20px;
                margin-bottom: 20px;
            }

            .cmw-color-preview-container {
                flex-direction: column;
                gap: 16px;
            }

            .cmw-selected-color-info {
                min-width: auto;
                max-width: 100%;
            }

            .cmw-toggle-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .cmw-wrap table {
                font-size: 13px;
                overflow-x: auto;
                display: block;
            }

            .cmw-wrap table thead,
            .cmw-wrap table tbody {
                display: table;
                width: 100%;
                table-layout: fixed;
            }

            .cmw-wrap th,
            .cmw-wrap td {
                padding: 8px 6px;
            }

            .cmw-swatch {
                width: 40px;
                height: 24px;
            }

            .cmw-harmony-colors {
                flex-direction: column;
                gap: 12px;
            }

            .cmw-harmony-color {
                flex-direction: column;
                text-align: center;
            }

            .cmw-intents-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        @media (max-width: 480px) {
            .cmw-wrap {
                padding: 0 12px;
            }

            .cmw-section {
                padding: 16px;
            }

        }

        /* Color Consensus Styles */
        .cmw-consensus-section {
            margin-top: 24px;
        }

        .cmw-consensus-samples {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .cmw-sample-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            transition: all 0.2s;
        }

        .cmw-sample-row:hover {
            border-color: #cbd5e1;
        }

        .cmw-sample-row.excluded {
            opacity: 0.5;
            background: #fef2f2;
            border-color: #fecaca;
        }

        .cmw-sample-swatch {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            flex-shrink: 0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-sample-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .cmw-sample-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .cmw-sample-label {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .cmw-sample-values {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #6b7280;
        }

        .cmw-sample-delta {
            font-size: 12px;
            color: #0065a3;
            font-weight: 500;
        }

        .cmw-sample-remove {
            width: 28px;
            height: 28px;
            border: none;
            background: #fee2e2;
            color: #dc2626;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cmw-sample-remove:hover {
            background: #fecaca;
        }

        .cmw-add-sample-row {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            align-items: center;
        }

        .cmw-sample-label-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
            max-width: 300px;
        }

        .cmw-sample-label-section label {
            font-weight: 500;
            color: #374151;
            font-size: 13px;
            text-align: center;
        }

        .cmw-sample-label-section input {
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            color: #374151;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
        }

        .cmw-sample-label-section input:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-sample-preview-swatch-large {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #e2e8f0;
            background: #f0f0f0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-sample-preview-swatch-large:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-search-color-info-box {
            text-align: center;
            padding: 12px 20px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            min-width: 200px;
        }

        .cmw-sample-format-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .cmw-sample-format-select {
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            color: #374151;
            font-size: 14px;
            cursor: pointer;
            min-width: 100px;
        }

        .cmw-sample-format-select:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-sample-inputs-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            width: 100%;
        }

        .cmw-sample-value-inputs {
            display: none;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .cmw-sample-value-inputs.active {
            display: flex;
        }

        .cmw-sample-input-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .cmw-sample-input-label {
            font-weight: 600;
            color: #0065a3;
            font-size: 14px;
            min-width: 20px;
            text-align: right;
        }

        .cmw-sample-input-field {
            width: 70px;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .cmw-sample-input-field:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-sample-hex-input {
            width: 120px;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .cmw-sample-hex-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-add-sample-btn {
            padding: 12px 24px;
            background: #0065a3;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            align-self: center;
            flex-shrink: 0;
        }

        .cmw-add-sample-btn:hover {
            background: #004d7a;
        }


        .cmw-consensus-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .cmw-consensus-btn {
            padding: 12px 28px;
            background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 101, 163, 0.3);
        }

        .cmw-consensus-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.4);
        }

        .cmw-consensus-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .cmw-clear-btn {
            padding: 12px 28px;
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-clear-btn:hover {
            background: #e5e7eb;
        }

        .cmw-consensus-result {
            display: none;
            margin-top: 24px;
            margin-bottom: 16px;
            padding: 24px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0065a3;
            border-radius: 16px;
        }

        .cmw-consensus-result.show {
            display: block;
        }

        .cmw-consensus-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .cmw-consensus-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #0065a3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-consensus-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }

        .cmw-consensus-info {
            flex: 1;
        }

        .cmw-consensus-title {
            font-size: 18px;
            font-weight: 700;
            color: #0065a3;
            margin-bottom: 8px;
        }

        .cmw-consensus-lab {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #374151;
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            display: inline-block;
        }

        .cmw-consensus-hex {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #6b7280;
            margin-left: 12px;
        }

        .cmw-consensus-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .cmw-stat-card {
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            text-align: center;
        }

        .cmw-stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #0065a3;
        }

        .cmw-stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .cmw-consensus-warning {
            margin-top: 16px;
            padding: 12px 16px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            color: #92400e;
            font-size: 14px;
        }

        .cmw-pairwise-section {
            margin-top: 20px;
        }

        .cmw-pairwise-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 0;
            color: #0065a3;
            font-weight: 600;
            font-size: 14px;
        }

        .cmw-pairwise-toggle span:first-child {
            font-size: 12px;
            transition: transform 0.2s ease;
            display: inline-block;
        }

        .cmw-pairwise-toggle.expanded span:first-child {
            transform: rotate(90deg);
        }

        .cmw-pairwise-grid {
            display: none;
            margin-top: 12px;
            gap: 8px;
        }

        .cmw-pairwise-grid.show {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }

        .cmw-pairwise-item {
            background: white;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cmw-pairwise-pair {
            color: #374151;
        }

        .cmw-pairwise-delta {
            font-weight: 600;
            color: #0065a3;
            font-family: 'Courier New', monospace;
        }

        .cmw-threshold-setting {
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .cmw-threshold-input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .cmw-threshold-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        /* Custom Library Styles */
        .cmw-custom-library-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
            max-height: 300px;
            overflow-y: auto;
        }

        .cmw-custom-color-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .cmw-custom-color-item:hover {
            border-color: #cbd5e1;
        }

        .cmw-custom-color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 2px solid #e2e8f0;
            flex-shrink: 0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-custom-color-swatch:hover {
            transform: scale(1.15);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .cmw-custom-color-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .cmw-custom-color-name {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .cmw-custom-color-values {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #6b7280;
        }

        .cmw-custom-color-remove {
            width: 24px;
            height: 24px;
            border: none;
            background: #fee2e2;
            color: #dc2626;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cmw-custom-color-remove:hover {
            background: #fecaca;
        }

        .cmw-custom-add-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 16px;
            align-items: center;
        }

        .cmw-custom-library-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .cmw-custom-export-btn,
        .cmw-custom-import-btn {
            padding: 8px 16px;
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-custom-export-btn:hover,
        .cmw-custom-import-btn:hover {
            background: #e5e7eb;
        }

        .cmw-custom-clear-btn {
            padding: 8px 16px;
            background: #fee2e2;
            color: #dc2626;
            border: 2px solid #fecaca;
            border-radius: 8px;
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-custom-clear-btn:hover {
            background: #fecaca;
        }

        .cmw-custom-empty {
            text-align: center;
            color: #9ca3af;
            font-size: 14px;
            padding: 20px;
            font-style: italic;
        }

        #cmw-custom-import-file {
            display: none;
        }

        /* Color Compare Styles */
        .cmw-compare-container {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .cmw-compare-colors {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .cmw-compare-arrow-between {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #0065a3;
            font-weight: 700;
            padding: 0 8px;
            align-self: center;
            margin-top: 40px;
        }

        @media (max-width: 600px) {
            .cmw-compare-arrow-between {
                transform: rotate(90deg);
                margin: 8px 0;
            }
        }

        /* Responsive styles for Color Compare on small screens */
        @media (max-width: 480px) {
            .cmw-compare-colors {
                flex-direction: row !important;
                flex-wrap: nowrap !important;
                gap: 8px !important;
                justify-content: center;
            }

            .cmw-compare-color-box {
                width: calc(50% - 20px) !important;
                min-width: 0 !important;
                max-width: none !important;
                padding: 10px !important;
                gap: 8px !important;
                flex-shrink: 1 !important;
            }

            .cmw-compare-color-box h4 {
                font-size: 11px !important;
            }

            .cmw-compare-swatch {
                width: 50px !important;
                height: 50px !important;
                border-radius: 8px !important;
            }

            .cmw-compare-format-select {
                font-size: 11px !important;
                padding: 4px 6px !important;
            }

            .cmw-compare-inputs input {
                font-size: 11px !important;
                padding: 6px 8px !important;
            }

            .cmw-compare-color-values {
                font-size: 9px !important;
                padding: 4px !important;
            }

            .cmw-compare-arrow-between {
                font-size: 16px !important;
                margin: 0 4px !important;
                transform: none !important;
            }

            .cmw-compare-result {
                padding: 10px 16px !important;
            }

            .cmw-compare-delta-value {
                font-size: 22px !important;
            }

            .cmw-compare-delta-label {
                font-size: 11px !important;
            }

            .cmw-compare-delta-interpretation {
                font-size: 10px !important;
                padding: 3px 8px !important;
            }

            .cmw-compare-actions {
                flex-direction: column !important;
                gap: 8px !important;
            }

            .cmw-compare-btn,
            .cmw-compare-clear-btn {
                width: 100% !important;
                padding: 10px 16px !important;
                font-size: 13px !important;
            }
        }

        /* Even smaller screens */
        @media (max-width: 360px) {
            .cmw-compare-color-box {
                padding: 8px !important;
                gap: 6px !important;
            }

            .cmw-compare-swatch {
                width: 40px !important;
                height: 40px !important;
            }

            .cmw-compare-color-box h4 {
                font-size: 10px !important;
            }

            .cmw-compare-inputs input {
                font-size: 10px !important;
                padding: 5px 6px !important;
            }

            .cmw-compare-delta-value {
                font-size: 18px !important;
            }
        }

        .cmw-compare-color-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            width: 180px;
            max-width: 180px;
            flex-shrink: 0;
            transition: all 0.2s;
            box-sizing: border-box;
        }

        .cmw-compare-color-box:hover {
            border-color: #cbd5e1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .cmw-compare-color-box h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .cmw-compare-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #e2e8f0;
            background: #f0f0f0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-compare-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-compare-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .cmw-compare-format-row {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .cmw-compare-format-select {
            padding: 6px 10px;
            font-size: 13px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            color: #374151;
            cursor: pointer;
        }

        .cmw-compare-format-select:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-compare-value-inputs {
            display: none;
        }

        .cmw-compare-value-inputs.active {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .cmw-compare-input-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .cmw-compare-input-label {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            width: 24px;
            text-align: right;
        }

        .cmw-compare-input-field {
            flex: 1;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'SF Mono', Monaco, monospace;
            text-align: center;
        }

        .cmw-compare-input-field:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-compare-hex-input {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            text-align: center;
        }

        .cmw-compare-hex-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-compare-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .cmw-compare-suggestion-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .cmw-compare-suggestion-item:hover {
            background: #f0f9ff;
        }

        .cmw-compare-suggestion-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            flex-shrink: 0;
        }

        .cmw-compare-suggestion-info {
            flex: 1;
            min-width: 0;
        }

        .cmw-compare-suggestion-name {
            font-size: 13px;
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cmw-compare-suggestion-library {
            font-size: 11px;
            color: #9ca3af;
        }

        .cmw-compare-input-wrapper {
            position: relative;
            width: 100%;
            max-width: 100%;
        }

        .cmw-compare-color-box input,
        .cmw-compare-color-box select {
            max-width: 100% !important;
            box-sizing: border-box;
        }

        .cmw-compare-color-values {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            color: #6b7280;
            text-align: center;
            padding: 8px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            width: 100%;
        }

        /* Delta E Result */
        .cmw-compare-result {
            display: none;
            padding: 10px 16px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0065a3;
            border-radius: 10px;
            text-align: center;
            margin: 12px auto 0 auto;
            max-width: fit-content;
        }

        .cmw-compare-result.show {
            display: flex;
            justify-content: center;
        }

        .cmw-compare-delta-display {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .cmw-compare-delta-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .cmw-compare-delta-value {
            font-size: 28px;
            font-weight: 800;
            font-family: 'SF Mono', Monaco, monospace;
            transition: color 0.2s ease;
        }

        .cmw-compare-delta-value.good {
            color: #16a34a;
        }

        .cmw-compare-delta-value.moderate {
            color: #ca8a04;
        }

        .cmw-compare-delta-value.poor {
            color: #dc2626;
        }

        .cmw-compare-delta-interpretation {
            font-size: 12px;
            color: #6b7280;
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 6px;
        }

        .cmw-compare-btn {
            padding: 12px 32px;
            background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 101, 163, 0.3);
        }

        .cmw-compare-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.4);
        }

        .cmw-compare-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .cmw-compare-actions {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 16px;
        }

        .cmw-compare-clear-btn {
            padding: 12px 24px;
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-compare-clear-btn:hover {
            background: #e5e7eb;
        }

        /* Results Table Styles */
        #cmw-out {
            line-height: 25px;
            -webkit-font-smoothing: antialiased;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            border-collapse: collapse;
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            text-align: left;
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
            width: 100%;
            margin-top: 20px;
        }

        #cmw-out thead th {
            background: #f9fafb;
            color: #374151;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 1px solid #e5e7eb;
        }

        #cmw-out tbody tr {
            transition: background-color 0.2s, transform 0.1s;
        }

        #cmw-out tbody tr:hover {
            background-color: #f8fafc;
            transform: translateX(2px);
        }

        #cmw-out tbody td {
            padding: 10px 12px;
            border-bottom: 1px solid #e2e8f0;
        }
    </style>

           <!-- Section 2 HTML -->

</head>
<body>
    <!-- Color Info Modal -->
    <div id="cmw-color-modal-overlay" class="cmw-color-modal-overlay">
        <div class="cmw-color-modal">
            <div id="cmw-color-modal-swatch" class="cmw-color-modal-swatch">
                <button id="cmw-color-modal-close" class="cmw-color-modal-close">×</button>
            </div>
            <div id="cmw-color-modal-name" class="cmw-color-modal-name">Color Name</div>
            <div class="cmw-color-modal-values">
                <div class="cmw-color-value-row" data-type="lab">
                    <span class="cmw-color-value-label">Lab</span>
                    <span class="cmw-color-value-data"><span id="cmw-modal-lab">--</span><span class="cmw-color-copy-icon">📋</span></span>
                </div>
                <div class="cmw-color-value-row" data-type="hex">
                    <span class="cmw-color-value-label">Hex</span>
                    <span class="cmw-color-value-data"><span id="cmw-modal-hex">--</span><span class="cmw-color-copy-icon">📋</span></span>
                </div>
                <div class="cmw-color-value-row" data-type="rgb">
                    <span class="cmw-color-value-label">RGB</span>
                    <span class="cmw-color-value-data"><span id="cmw-modal-rgb">--</span><span class="cmw-color-copy-icon">📋</span></span>
                </div>
                <div class="cmw-color-value-row" data-type="cmyk">
                    <span class="cmw-color-value-label">CMYK</span>
                    <span class="cmw-color-value-data"><span id="cmw-modal-cmyk">--</span><span class="cmw-color-copy-icon">📋</span></span>
                </div>
            </div>
            
            <!-- Purchase Links Section -->
            <div id="cmw-modal-purchase-links" class="cmw-modal-purchase-links" style="display: none;">
                <a id="cmw-modal-amazon-link" href="#" target="_blank" rel="noopener noreferrer" class="cmw-modal-purchase-btn">
                    🛒 Buy on Amazon
                </a>
                <a id="cmw-modal-manufacturer-link" href="#" target="_blank" rel="noopener noreferrer" class="cmw-modal-purchase-btn cmw-modal-manufacturer-btn" style="display: none;">
                    🏭 Manufacturer Site
                </a>
            </div>
            
            <!-- Add to Library Section -->
            <div class="cmw-modal-add-library">
                <div class="cmw-modal-add-header" id="cmw-modal-add-toggle">
                    <span>+ Add to Library</span>
                </div>
                <div class="cmw-modal-add-content" id="cmw-modal-add-content" style="display: none;">
                    <input type="text" id="cmw-modal-color-name" class="cmw-modal-input" placeholder="Color name (optional)">
                    <div class="cmw-modal-library-row">
                        <select id="cmw-modal-library-select" class="cmw-modal-select">
                            <option value="">-- Select Library --</option>
                        </select>
                        <button id="cmw-modal-new-lib-btn" class="cmw-modal-new-btn" title="Create new library">+</button>
                    </div>
                    <div id="cmw-modal-new-lib-row" class="cmw-modal-new-lib-row" style="display: none;">
                        <input type="text" id="cmw-modal-new-lib-name" class="cmw-modal-input" placeholder="New library name">
                        <button id="cmw-modal-create-lib-btn" class="cmw-modal-create-btn">Create</button>
                    </div>
                    <button id="cmw-modal-add-btn" class="cmw-modal-add-btn">Add to Library</button>
                    <div id="cmw-modal-add-status" class="cmw-modal-add-status"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="cmw-wrap">
        <h5>+COLOR MATCH</h5>
       
        <!-- Change this to your actual API base URL -->
        <input type="hidden" id="cmw-api-url" value="https://botm-ucxq.onrender.com">
        <!-- ngrok tunnel allows mobile devices to access your localhost API -->
       
        <div class="cmw-library-toggles">
            <h6>Color Libraries</h6>
            <div class="cmw-toggle-grid" id="cmw-public-libraries-container">
                <!-- Public libraries loaded dynamically from libraries.json -->
            </div>
           
            <div style="height: 1px; background: linear-gradient(to right, transparent, #e2e8f0 20%, #e2e8f0 80%, transparent); margin: 20px 0;"></div>
           
            <div style="display: flex; justify-content: center; align-items: center; gap: 24px; margin-top: 16px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="cmw-results-count" style="font-weight: 600; color: #374151; white-space: nowrap;">Results per library:</label>
                    <select id="cmw-results-count" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                        <option value="1" selected>1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="5">5</option>
                        <option value="10">10</option>
                    </select>
                </div>
            </div>
           
            <!-- Custom Libraries Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-custom-library-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret">▶</span>
                    <span class="cmw-settings-label">Custom Libraries</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-custom-library-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Create custom color libraries. Libraries appear in the filter list above once they have colors.
                    </p>
                    
                    <!-- Library Selector -->
                    <div style="display: flex; align-items: center; gap: 12px; justify-content: center; margin-bottom: 16px; flex-wrap: wrap;">
                        <label style="font-weight: 600; color: #374151;">Library:</label>
                        <select id="cmw-custom-library-select" style="padding: 8px 14px; border: 2px solid #e2e8f0; border-radius: 8px; min-width: 150px; font-size: 14px;">
                            <option value="">-- Select or Create --</option>
                        </select>
                        <input type="text" id="cmw-new-library-name" class="cmw-custom-name-input" placeholder="New library name" style="width: 150px;">
                        <button id="cmw-create-library-btn" class="cmw-custom-add-btn" style="padding: 8px 16px;">+ Create</button>
                    </div>
                    
                    <!-- Current Library Info -->
                    <div id="cmw-current-library-info" style="display: none; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: #f0f9ff; border: 2px solid #0065a3; border-radius: 10px;">
                            <div>
                                <span style="font-weight: 600; color: #0065a3;" id="cmw-current-library-name">Library Name</span>
                                <span style="color: #6b7280; font-size: 13px; margin-left: 8px;" id="cmw-current-library-count">(0 colors)</span>
                            </div>
                            <button id="cmw-delete-library-btn" style="padding: 6px 12px; background: #fee2e2; color: #dc2626; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">Delete Library</button>
                        </div>
                    </div>
                    
                    <div id="cmw-custom-library-list" class="cmw-custom-library-list">
                        <div class="cmw-custom-empty">Select or create a library to add colors.</div>
                    </div>
                    
                    <div id="cmw-custom-add-form" class="cmw-custom-add-form" style="display: none;">
                        <!-- Swatch preview at top -->
                        <div id="cmw-custom-preview-swatch" class="cmw-sample-preview-swatch-large" title="Color preview"></div>
                        
                        <!-- Color name -->
                        <div class="cmw-sample-label-section">
                            <label>Color Name</label>
                            <input type="text" id="cmw-custom-color-name" placeholder="e.g., My Red, Brand Blue...">
                        </div>
                        
                        <!-- Format dropdown -->
                        <div class="cmw-sample-format-row">
                            <label style="font-weight: 500; color: #374151; font-size: 13px;">Format:</label>
                            <select id="cmw-custom-format" class="cmw-sample-format-select">
                                <option value="hex" selected>Hex</option>
                                <option value="lab">Lab</option>
                                <option value="rgb">RGB</option>
                                <option value="cmyk">CMYK</option>
                            </select>
                        </div>
                        
                        <!-- Color inputs -->
                        <div class="cmw-sample-inputs-container">
                            <!-- Hex Input -->
                            <div id="cmw-custom-hex-inputs" class="cmw-sample-value-inputs active">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">#</span>
                                    <input type="text" id="cmw-custom-hex" class="cmw-sample-hex-input" placeholder="FF5733" maxlength="6">
                                </div>
                            </div>
                            
                            <!-- Lab Inputs -->
                            <div id="cmw-custom-lab-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">L*</span>
                                    <input type="number" id="cmw-custom-lab-l" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">a*</span>
                                    <input type="number" id="cmw-custom-lab-a" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">b*</span>
                                    <input type="number" id="cmw-custom-lab-b" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                            </div>
                            
                            <!-- RGB Inputs -->
                            <div id="cmw-custom-rgb-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">R</span>
                                    <input type="number" id="cmw-custom-rgb-r" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">G</span>
                                    <input type="number" id="cmw-custom-rgb-g" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">B</span>
                                    <input type="number" id="cmw-custom-rgb-b" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                            </div>
                            
                            <!-- CMYK Inputs -->
                            <div id="cmw-custom-cmyk-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">C</span>
                                    <input type="number" id="cmw-custom-cmyk-c" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">M</span>
                                    <input type="number" id="cmw-custom-cmyk-m" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">Y</span>
                                    <input type="number" id="cmw-custom-cmyk-y" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">K</span>
                                    <input type="number" id="cmw-custom-cmyk-k" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Add button -->
                        <button id="cmw-custom-add-btn" class="cmw-add-sample-btn">+ Add Color</button>
                    </div>
                    
                    <div class="cmw-custom-library-actions" style="margin-top: 16px;">
                        <button id="cmw-custom-export-btn" class="cmw-custom-export-btn">Export Library</button>
                        <button id="cmw-custom-import-btn" class="cmw-custom-import-btn" title="Import from JSON, CXF, ASE, or CSV file">Import Library</button>
                        <input type="file" id="cmw-custom-import-file" accept=".json,.cxf,.csv,.ase">
                    </div>
                    
                    <div id="cmw-custom-status" class="cmw-status"></div>
                </div>
            </div>
            
            <!-- Color Consensus Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-consensus-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret">▶</span>
                    <span class="cmw-settings-label">Color Consensus</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-consensus-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Compare multiple color samples and find the perceptual average with outlier detection (ΔE2000)
                    </p>
                    
                    <div class="cmw-threshold-setting">
                        <label for="cmw-outlier-threshold" style="font-weight: 500; color: #374151;">Outlier Threshold (ΔE2000):</label>
                        <input type="number" id="cmw-outlier-threshold" class="cmw-threshold-input" value="3.0" min="0.5" max="10" step="0.5">
                    </div>
                    
                    <div id="cmw-consensus-samples" class="cmw-consensus-samples">
                        <!-- Sample rows will be added here dynamically -->
                    </div>
                    
                    <div class="cmw-add-sample-row">
                        <!-- Swatch preview at top -->
                        <div id="cmw-sample-preview-swatch" class="cmw-sample-preview-swatch-large" title="Color preview"></div>
                        
                        <!-- Label -->
                        <div class="cmw-sample-label-section">
                            <label>Label (optional)</label>
                            <input type="text" id="cmw-sample-label" placeholder="e.g., Sample A, Brand Color...">
                        </div>
                        
                        <!-- Format dropdown -->
                        <div class="cmw-sample-format-row">
                            <label style="font-weight: 500; color: #374151; font-size: 13px;">Format:</label>
                            <select id="cmw-sample-format" class="cmw-sample-format-select">
                                <option value="hex" selected>Hex</option>
                                <option value="lab">Lab</option>
                                <option value="rgb">RGB</option>
                                <option value="cmyk">CMYK</option>
                            </select>
                        </div>
                        
                        <!-- Color inputs -->
                        <div class="cmw-sample-inputs-container">
                            <!-- Hex Input -->
                            <div id="cmw-sample-hex-inputs" class="cmw-sample-value-inputs active">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">#</span>
                                    <input type="text" id="cmw-sample-hex" class="cmw-sample-hex-input" placeholder="FF5733" maxlength="6">
                                </div>
                            </div>
                            
                            <!-- Lab Inputs -->
                            <div id="cmw-sample-lab-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">L*</span>
                                    <input type="number" id="cmw-sample-lab-l" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">a*</span>
                                    <input type="number" id="cmw-sample-lab-a" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">b*</span>
                                    <input type="number" id="cmw-sample-lab-b" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                            </div>
                            
                            <!-- RGB Inputs -->
                            <div id="cmw-sample-rgb-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">R</span>
                                    <input type="number" id="cmw-sample-rgb-r" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">G</span>
                                    <input type="number" id="cmw-sample-rgb-g" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">B</span>
                                    <input type="number" id="cmw-sample-rgb-b" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                            </div>
                            
                            <!-- CMYK Inputs -->
                            <div id="cmw-sample-cmyk-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">C</span>
                                    <input type="number" id="cmw-sample-cmyk-c" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">M</span>
                                    <input type="number" id="cmw-sample-cmyk-m" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">Y</span>
                                    <input type="number" id="cmw-sample-cmyk-y" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">K</span>
                                    <input type="number" id="cmw-sample-cmyk-k" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Add button -->
                        <button id="cmw-add-sample-btn" class="cmw-add-sample-btn">+ Add Sample</button>
                    </div>
                
                    <div class="cmw-consensus-actions">
                        <button id="cmw-calculate-consensus-btn" class="cmw-consensus-btn" disabled>Calculate Consensus</button>
                        <button id="cmw-clear-samples-btn" class="cmw-clear-btn">Clear All</button>
                    </div>
                    
                    <div id="cmw-consensus-loading" class="cmw-loading" style="display: none;">
                        <div class="cmw-spinner"></div>
                        <span>Calculating color consensus...</span>
                    </div>
                    
                    <div id="cmw-consensus-result" class="cmw-consensus-result">
                        <div class="cmw-consensus-header">
                            <div id="cmw-consensus-swatch" class="cmw-consensus-swatch"></div>
                            <div class="cmw-consensus-info">
                                <div class="cmw-consensus-title">Consensus Color</div>
                                <div>
                                    <span id="cmw-consensus-lab" class="cmw-consensus-lab">Lab(50.00, 0.00, 0.00)</span>
                                    <span id="cmw-consensus-hex" class="cmw-consensus-hex">#808080</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="cmw-consensus-stats">
                            <div class="cmw-stat-card">
                                <div id="cmw-stat-included" class="cmw-stat-value">0</div>
                                <div class="cmw-stat-label">Samples Included</div>
                            </div>
                            <div class="cmw-stat-card">
                                <div id="cmw-stat-excluded" class="cmw-stat-value">0</div>
                                <div class="cmw-stat-label">Outliers Excluded</div>
                            </div>
                            <div class="cmw-stat-card">
                                <div id="cmw-stat-max-delta" class="cmw-stat-value">0.00</div>
                                <div class="cmw-stat-label">Max ΔE2000</div>
                            </div>
                        </div>
                        
                        <div id="cmw-consensus-warning" class="cmw-consensus-warning" style="display: none;"></div>
                        
                        <div class="cmw-pairwise-section">
                            <div id="cmw-pairwise-toggle" class="cmw-pairwise-toggle">
                                <span>▶</span>
                                <span>Show Pairwise Comparisons</span>
                            </div>
                            <div id="cmw-pairwise-grid" class="cmw-pairwise-grid"></div>
                        </div>
                    </div>
                    
                    <div id="cmw-consensus-status" class="cmw-status"></div>
                </div>
            </div>
            
            <!-- Color Compare Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-compare-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret">▶</span>
                    <span class="cmw-settings-label">Color Compare</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-compare-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Compare two colors and calculate their perceptual difference using ΔE2000
                    </p>
                    
                    <div class="cmw-compare-container">
                        <div class="cmw-compare-colors">
                            <!-- Color 1 -->
                            <div class="cmw-compare-color-box">
                                <h4>Color 1</h4>
                                <div id="cmw-compare-swatch-1" class="cmw-compare-swatch" title="Click for color info"></div>
                                
                                <div class="cmw-compare-inputs">
                                    <div class="cmw-compare-format-row">
                                        <label style="font-size: 12px; color: #6b7280;">Format:</label>
                                        <select id="cmw-compare-format-1" class="cmw-compare-format-select">
                                            <option value="hex" selected>Hex/Name</option>
                                            <option value="lab">Lab</option>
                                            <option value="rgb">RGB</option>
                                            <option value="cmyk">CMYK</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Hex/Name Input -->
                                    <div id="cmw-compare-hex-inputs-1" class="cmw-compare-value-inputs active">
                                        <div class="cmw-compare-input-wrapper">
                                            <input type="text" id="cmw-compare-hex-1" class="cmw-compare-hex-input" placeholder="Hex/Name">
                                            <div id="cmw-compare-suggestions-1" class="cmw-compare-suggestions" style="display: none;"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Lab Inputs -->
                                    <div id="cmw-compare-lab-inputs-1" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">L*</span>
                                            <input type="number" id="cmw-compare-lab-l-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">a*</span>
                                            <input type="number" id="cmw-compare-lab-a-1" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">b*</span>
                                            <input type="number" id="cmw-compare-lab-b-1" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                    </div>
                                    
                                    <!-- RGB Inputs -->
                                    <div id="cmw-compare-rgb-inputs-1" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">R</span>
                                            <input type="number" id="cmw-compare-rgb-r-1" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">G</span>
                                            <input type="number" id="cmw-compare-rgb-g-1" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">B</span>
                                            <input type="number" id="cmw-compare-rgb-b-1" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                    </div>
                                    
                                    <!-- CMYK Inputs -->
                                    <div id="cmw-compare-cmyk-inputs-1" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">C</span>
                                            <input type="number" id="cmw-compare-cmyk-c-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">M</span>
                                            <input type="number" id="cmw-compare-cmyk-m-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">Y</span>
                                            <input type="number" id="cmw-compare-cmyk-y-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">K</span>
                                            <input type="number" id="cmw-compare-cmyk-k-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <div id="cmw-compare-values-1" class="cmw-compare-color-values">
                                    Lab: — | Hex: —
                                </div>
                            </div>
                            
                            <!-- Arrow between colors -->
                            <div class="cmw-compare-arrow-between">↔</div>
                            
                            <!-- Color 2 -->
                            <div class="cmw-compare-color-box">
                                <h4>Color 2</h4>
                                <div id="cmw-compare-swatch-2" class="cmw-compare-swatch" title="Click for color info"></div>
                                
                                <div class="cmw-compare-inputs">
                                    <div class="cmw-compare-format-row">
                                        <label style="font-size: 12px; color: #6b7280;">Format:</label>
                                        <select id="cmw-compare-format-2" class="cmw-compare-format-select">
                                            <option value="hex" selected>Hex/Name</option>
                                            <option value="lab">Lab</option>
                                            <option value="rgb">RGB</option>
                                            <option value="cmyk">CMYK</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Hex/Name Input -->
                                    <div id="cmw-compare-hex-inputs-2" class="cmw-compare-value-inputs active">
                                        <div class="cmw-compare-input-wrapper">
                                            <input type="text" id="cmw-compare-hex-2" class="cmw-compare-hex-input" placeholder="Hex/Name">
                                            <div id="cmw-compare-suggestions-2" class="cmw-compare-suggestions" style="display: none;"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Lab Inputs -->
                                    <div id="cmw-compare-lab-inputs-2" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">L*</span>
                                            <input type="number" id="cmw-compare-lab-l-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">a*</span>
                                            <input type="number" id="cmw-compare-lab-a-2" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">b*</span>
                                            <input type="number" id="cmw-compare-lab-b-2" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                    </div>
                                    
                                    <!-- RGB Inputs -->
                                    <div id="cmw-compare-rgb-inputs-2" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">R</span>
                                            <input type="number" id="cmw-compare-rgb-r-2" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">G</span>
                                            <input type="number" id="cmw-compare-rgb-g-2" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">B</span>
                                            <input type="number" id="cmw-compare-rgb-b-2" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                    </div>
                                    
                                    <!-- CMYK Inputs -->
                                    <div id="cmw-compare-cmyk-inputs-2" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">C</span>
                                            <input type="number" id="cmw-compare-cmyk-c-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">M</span>
                                            <input type="number" id="cmw-compare-cmyk-m-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">Y</span>
                                            <input type="number" id="cmw-compare-cmyk-y-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">K</span>
                                            <input type="number" id="cmw-compare-cmyk-k-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <div id="cmw-compare-values-2" class="cmw-compare-color-values">
                                    Lab: — | Hex: —
                                </div>
                            </div>
                        </div>
                        
                        <!-- Delta E Result (displayed between color boxes and actions) -->
                        <div id="cmw-compare-result" class="cmw-compare-result">
                            <div class="cmw-compare-delta-display">
                                <span id="cmw-compare-delta-value" class="cmw-compare-delta-value">0.00</span>
                                <span class="cmw-compare-delta-label">ΔE</span>
                                <span id="cmw-compare-delta-interpretation" class="cmw-compare-delta-interpretation">Colors are identical</span>
                            </div>
                        </div>
                        
                        <div class="cmw-compare-actions">
                            <button id="cmw-compare-btn" class="cmw-compare-btn">Compare Colors</button>
                            <button id="cmw-compare-clear-btn" class="cmw-compare-clear-btn">Clear</button>
                        </div>
                    </div>
                    
                    <div id="cmw-compare-status" class="cmw-status"></div>
                </div>
            </div>
            
            <!-- Collapsible Settings Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-settings-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret">▶</span>
                    <span class="cmw-settings-label">Settings</span>
                    <div class="cmw-settings-line"></div>
                </div>
               
                <div id="cmw-settings-content" class="cmw-settings-content collapsed">
                    <div style="height: 1px; background: linear-gradient(to right, transparent, #e2e8f0 20%, #e2e8f0 80%, transparent); margin: 20px 0;"></div>
                   
                    <div style="display: flex; justify-content: center; align-items: center; gap: 24px; margin-top: 16px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="cmw-default-intent" style="font-weight: 600; color: #374151; white-space: nowrap;">Rendering Intent:</label>
                            <select id="cmw-default-intent" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                                <option value="none">None</option>
                                <option value="0">Perceptual</option>
                                <option value="1" selected>Relative Colorimetric</option>
                                <option value="2">Saturation</option>
                                <option value="3">Absolute Colorimetric</option>
                            </select>
                        </div>
                       
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px;">
                            <input type="checkbox" id="cmw-intents-toggle" style="width: 18px; height: 18px; cursor: pointer; accent-color: #0065a3;">
                            <label for="cmw-intents-toggle" style="cursor: pointer; font-size: 15px; color: #374151; font-weight: 500; user-select: none; white-space: nowrap;">Rendering Comparison</label>
                        </div>
                    </div>
                   
                    <div style="height: 1px; background: linear-gradient(to right, transparent, #e2e8f0 20%, #e2e8f0 80%, transparent); margin: 20px 0;"></div>
                   
                    <div style="display: flex; justify-content: center; align-items: center; gap: 24px; margin-top: 16px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px;">
                            <input type="checkbox" id="cmw-harmony-toggle" style="width: 18px; height: 18px; cursor: pointer; accent-color: #0065a3;">
                            <label for="cmw-harmony-toggle" style="cursor: pointer; font-size: 15px; color: #374151; font-weight: 500; user-select: none; white-space: nowrap;">Color Harmonies</label>
                        </div>
                       
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px;">
                            <input type="checkbox" id="cmw-gamut-toggle" style="width: 18px; height: 18px; cursor: pointer; accent-color: #0065a3;">
                            <label for="cmw-gamut-toggle" style="cursor: pointer; font-size: 15px; color: #374151; font-weight: 500; user-select: none; white-space: nowrap;">Gamut Indicator</label>
                        </div>
                    </div>
                   
                    <div id="cmw-profile-selector" class="cmw-profile-selector" style="display: none;">
                        <label for="cmw-profile-select" style="font-weight: 600; color: #374151; margin-right: 8px;">ICC Profile for CMYK:</label>
                        <select id="cmw-profile-select" class="cmw-profile-select">
                            <option value="GRACoL2013.icc" selected>GRACoL2013.icc</option>
                            <option value="SWOP2006_Coated3.icc">SWOP2006_Coated3.icc</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
       
        <div class="cmw-section">
            <h6>Color Search</h6>
            <div class="cmw-add-sample-row">
                <!-- Swatch preview at top -->
                <div id="cmw-color-preview" class="cmw-sample-preview-swatch-large"></div>
                
                <!-- Converted color info under swatch -->
                <div id="cmw-converted-color-info" class="cmw-search-color-info-box">
                    <div style="font-size: 12px; color: #6b7280; font-weight: 600;">Converted Lab Values</div>
                    <div id="cmw-converted-color-lab" style="font-size: 14px; color: #374151; font-family: 'SF Mono', Monaco, monospace;"></div>
                    <div id="cmw-converted-cmyk" style="font-size: 14px; color: #374151; font-family: 'SF Mono', Monaco, monospace;"></div>
                </div>
                
                <div id="cmw-selected-color-info" class="cmw-search-color-info-box" style="display: none;">
                    <div id="cmw-selected-color-library" style="font-size: 12px; color: #6b7280; font-weight: 600;"></div>
                    <div id="cmw-selected-color-lab" style="font-size: 14px; color: #374151; font-family: 'SF Mono', Monaco, monospace;"></div>
                </div>

                <!-- Gamut warning -->
                <div id="cmw-gamut-warning" class="cmw-gamut-warning" style="display: none;">
                    <span class="cmw-gamut-icon">⚠️</span>
                    <span id="cmw-gamut-message">Checking gamut...</span>
                </div>

                <!-- Format dropdown -->
                <div class="cmw-sample-format-row">
                    <label style="font-weight: 500; color: #374151; font-size: 13px;">Format:</label>
                    <select id="cmw-search-type-select" class="cmw-sample-format-select">
                        <option value="name" selected>Hex/Name</option>
                        <option value="lab">Lab Values</option>
                        <option value="cmyk">CMYK Values</option>
                        <option value="rgb">RGB Values</option>
                    </select>
                </div>

                <!-- Color inputs -->
                <div class="cmw-sample-inputs-container">
                    <!-- Hex/Name input -->
                    <div id="cmw-name-inputs" class="cmw-sample-value-inputs active">
                        <input id="cmw-name-input" style="width: 100%; max-width: 350px; padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; text-align: center;" placeholder="Hex/Name">
                    </div>
                    
                    <!-- Lab inputs -->
                    <div id="cmw-lab-inputs" class="cmw-sample-value-inputs">
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">L*</span>
                            <input id="cmw-lab-l" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">a*</span>
                            <input id="cmw-lab-a" class="cmw-sample-input-field" type="number" placeholder="-128" min="-128" max="127" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">b*</span>
                            <input id="cmw-lab-b" class="cmw-sample-input-field" type="number" placeholder="-128" min="-128" max="127" step="0.1">
                        </div>
                    </div>

                    <!-- CMYK inputs -->
                    <div id="cmw-cmyk-inputs" class="cmw-sample-value-inputs">
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">C</span>
                            <input id="cmw-cmyk-c" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">M</span>
                            <input id="cmw-cmyk-m" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">Y</span>
                            <input id="cmw-cmyk-y" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">K</span>
                            <input id="cmw-cmyk-k" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                    </div>

                    <!-- RGB inputs -->
                    <div id="cmw-rgb-inputs" class="cmw-sample-value-inputs">
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">R</span>
                            <input id="cmw-rgb-r" class="cmw-sample-input-field" type="number" placeholder="0-255" min="0" max="255">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">G</span>
                            <input id="cmw-rgb-g" class="cmw-sample-input-field" type="number" placeholder="0-255" min="0" max="255">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">B</span>
                            <input id="cmw-rgb-b" class="cmw-sample-input-field" type="number" placeholder="0-255" min="0" max="255">
                        </div>
                    </div>
                </div>
                
                <!-- Suggestions dropdown -->
                <div id="cmw-name-suggestions" class="cmw-suggestions">
                    <div class="cmw-suggestions-header">Suggestions:</div>
                    <div class="cmw-suggestions-content"></div>
                    <div id="cmw-loading-more" class="cmw-loading-more">Loading more results...</div>
                    <div id="cmw-no-more-results" class="cmw-no-more-results">No more results available</div>
                </div>

                <!-- Search button -->
                <button id="cmw-search-btn" class="cmw-add-sample-btn">Search</button>
            </div>
        </div>

        <div id="cmw-loading" class="cmw-loading">
            <div class="cmw-spinner"></div>
            <span>Loading color libraries...</span>
        </div>

        <div id="cmw-status" class="cmw-status"></div>

        <!-- Color Harmonies Section -->
        <div id="cmw-harmonies-section" class="cmw-section" style="display: none;">
            <h6>Color Harmonies</h6>
            <div style="display: flex; justify-content: center; margin-bottom: 20px;">
                <select id="cmw-harmony-type" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                    <option value="complementary" selected>Complementary</option>
                    <option value="triadic">Triadic</option>
                    <option value="tetradic">Tetradic</option>
                    <option value="analogous">Analogous</option>
                    <option value="splitComplementary">Split Complementary</option>
                    <option value="monochromatic">Monochromatic</option>
                </select>
            </div>
           
            <div id="cmw-harmony-loading" class="cmw-loading">
                <div class="cmw-spinner"></div>
                <span>Calculating color harmonies...</span>
            </div>
           
            <div id="cmw-harmony-colors" class="cmw-harmony-colors">
                <!-- Harmony colors will be populated here -->
            </div>
           
            <div id="cmw-harmony-status" class="cmw-status"></div>
        </div>

        <!-- Rendering Intent Comparison Section -->
        <div id="cmw-intents-section" class="cmw-section" style="display: none;">
            <h6>Rendering Comparison</h6>
            <div id="cmw-intents-loading" class="cmw-loading">
                <div class="cmw-spinner"></div>
                <span>Comparing rendering intents...</span>
            </div>
           
            <div id="cmw-intents-grid" class="cmw-intents-grid">
                <div class="cmw-intent-card" id="cmw-intent-perceptual">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Perceptual</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Smooth compression, good for photos</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
               
                <div class="cmw-intent-card" id="cmw-intent-relative">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Relative Colorimetric</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Exact colors where possible</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
               
                <div class="cmw-intent-card" id="cmw-intent-saturation">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Saturation</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Vivid colors for graphics</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
               
                <div class="cmw-intent-card" id="cmw-intent-absolute">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Absolute Colorimetric</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Exact simulation for proofing</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
            </div>
           
            <div id="cmw-intents-status" class="cmw-status"></div>
        </div>

        <!-- Filter Controls -->
        <div id="cmw-filter-controls" style="display: none; margin: 16px 0; padding: 12px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 8px; border: 1px solid #e2e8f0;">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 14px; font-weight: 500; color: #334155;">
                <input type="checkbox" id="cmw-filter-amazon" style="
                    width: 18px;
                    height: 18px;
                    cursor: pointer;
                    accent-color: #FF9900;
                ">
                <span>
                    <img src="https://www.amazon.com/favicon.ico" style="width: 18px; height: 18px; vertical-align: middle; margin-right: 4px;" title="Amazon">
                    Show only colors with Amazon links
                </span>
                <span id="cmw-filter-count" style="margin-left: auto; padding: 4px 10px; background: #FF9900; color: white; border-radius: 12px; font-size: 12px; font-weight: 600;"></span>
            </label>
        </div>

        <table id="cmw-out" hidden>
            <thead>
                <tr>
                    <th>Swatch</th>
                    <th>Name</th>
                    <th>Library</th>
                    <th>ΔE</th>
                    <th>Lab</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <script>
        /* ─────────────────────
           Section 3 Java Part 1
           ───────────────────── */

        /* 1. API Configuration - Update this to match your server */
        function getApiBaseUrl() {
            return document.getElementById('cmw-api-url').value || 'http://localhost:3000';
        }

        /* 2. Global variables */
        let currentAnalysisData = null;
        let currentHarmonyType = 'complementary';
        let libsLoaded = false;
        let currentSearchResults = []; // Store current search results for 3D visualization

        /* 3. Enhanced ΔE 2000 calculation (CIEDE2000)
         * ⚠️  HARD RULE: All Lab values MUST be in Lab(D50) illuminant!
         * ❌ NEVER pass Lab(D65) values here - results will be WRONG
         * ✔  All colors must be converted to Lab(D50) before calling this function
         */
        function dE(L1, a1, b1, L2, a2, b2) {
            const C1 = Math.hypot(a1, b1), C2 = Math.hypot(a2, b2), C̅ = (C1 + C2) / 2,
                G = .5 * (1 - Math.sqrt((C̅ ** 7) / ((C̅ ** 7) + (25 ** 7)))),
                a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.hypot(a1p, b1), C2p = Math.hypot(a2p, b2),
                h1p = Math.atan2(b1, a1p), h2p = Math.atan2(b2, a2p),
                ΔLp = L2 - L1, ΔCp = C2p - C1p;
            let Δhp = h2p - h1p; if (Δhp > Math.PI) Δhp -= 2 * Math.PI; if (Δhp < -Math.PI) Δhp += 2 * Math.PI;
            const ΔHp = 2 * Math.sqrt(C1p * C2p) * Math.sin(Δhp / 2),
                L̅ = (L1 + L2) / 2, C̅p = (C1p + C2p) / 2;
            let h̅p = (h1p + h2p) / 2; if (Math.abs(h1p - h2p) > Math.PI) h̅p += Math.PI;
            const T = 1 - .17 * Math.cos(h̅p - Math.PI / 6) + .24 * Math.cos(2 * h̅p) + .32 * Math.cos(3 * h̅p + Math.PI / 30) - .20 * Math.cos(4 * h̅p - 1.0996),
                ΔRo = .5236 * Math.exp(-(((h̅p * 57.2958 - 275) / 25) ** 2)),
                R_C = 2 * Math.sqrt((C̅p ** 7) / ((C̅p ** 7) + (25 ** 7))),
                S_L = 1 + .015 * ((L̅ - 50) ** 2) / Math.sqrt(20 + (L̅ - 50) ** 2),
                S_C = 1 + .045 * C̅p,
                S_H = 1 + .015 * C̅p * T,
                R_T = -Math.sin(2 * ΔRo) * R_C;
            return Math.sqrt((ΔLp / S_L) ** 2 + (ΔCp / S_C) ** 2 + (ΔHp / S_H) ** 2 + R_T * (ΔCp / S_C) * (ΔHp / S_H));
        }

        /* 4. Lab to RGB conversion - VISUAL PREVIEW ONLY
         * This function is used ONLY for immediate visual feedback in swatches.
         * All actual color data (Lab values, hex, RGB, CMYK) comes from LittleCMS API.
         * This is acceptable because:
         * - The Lab values are already accurate (from library or LittleCMS)
         * - This just provides a quick visual approximation for the swatch background
         * - The actual displayed values are always from LittleCMS
         * - Uses Lab(D50) → XYZ(D50) → CAT16 → XYZ(D65) → sRGB to match backend
         */
        function lab2rgb(L, a, b) {
            // Step 1: Lab(D50) → XYZ(D50)
            // D50 white point (spectrophotometer standard)
            const Xn = 0.96422, Yn = 1.00000, Zn = 0.82521;
            
            const fy = (L + 16) / 116;
            const fx = a / 500 + fy;
            const fz = fy - b / 200;
            
            const delta = 6 / 29;
            const f_inv = t => t > delta ? t ** 3 : 3 * delta * delta * (t - 4 / 29);
            
            const X_d50 = Xn * f_inv(fx);
            const Y_d50 = Yn * f_inv(fy);
            const Z_d50 = Zn * f_inv(fz);
            
            // Step 2: CAT16 chromatic adaptation D50 → D65 (CIE 2016)
            // ⚠️  GUARDRAIL - DO NOT MODIFY WITHOUT UNDERSTANDING:
            // CAT16 is used ONLY for display-referred RGB interpretation.
            // ICC profile transforms (LittleCMS API) must NEVER be overridden.
            // This is NOT a full CAM16 appearance model - just chromatic adaptation.
            // If CAM16-UCS is added later: derived, non-authoritative, UI-only.
            const M_CAT16 = [
                [ 0.401288,  0.650173, -0.051461],
                [-0.250268,  1.204414,  0.045854],
                [-0.002079,  0.048952,  0.953127]
            ];
            const M_CAT16_INV = [
                [ 1.8620678, -1.0112547,  0.1491868],
                [ 0.3875265,  0.6214474, -0.0089739],
                [-0.0158415, -0.0344317,  1.0502732]
            ];
            const D65_WHITE = [95.047, 100.0, 108.883];
            const D50_WHITE = [96.422, 100.0, 82.521];
            
            const matMul = (m, v) => [
                m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
                m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
                m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
            ];
            
            const xyz_d50_100 = [X_d50 * 100, Y_d50 * 100, Z_d50 * 100];
            const RGB_D65 = matMul(M_CAT16, D65_WHITE);
            const RGB_D50 = matMul(M_CAT16, D50_WHITE);
            const scale = [RGB_D65[0]/RGB_D50[0], RGB_D65[1]/RGB_D50[1], RGB_D65[2]/RGB_D50[2]];
            const rgb = matMul(M_CAT16, xyz_d50_100);
            const rgb_adapted = [rgb[0] * scale[0], rgb[1] * scale[1], rgb[2] * scale[2]];
            const xyz_d65_100 = matMul(M_CAT16_INV, rgb_adapted);
            
            const X_d65 = xyz_d65_100[0] / 100;
            const Y_d65 = xyz_d65_100[1] / 100;
            const Z_d65 = xyz_d65_100[2] / 100;
            
            // Step 3: XYZ(D65) → Linear RGB → sRGB
            let r_lin =  3.2404542 * X_d65 - 1.5371385 * Y_d65 - 0.4985314 * Z_d65;
            let g_lin = -0.9692660 * X_d65 + 1.8760108 * Y_d65 + 0.0415560 * Z_d65;
            let b_lin =  0.0556434 * X_d65 - 0.2040259 * Y_d65 + 1.0572252 * Z_d65;
            
            // Gamma correction
            const gamma = c => c <= 0.0031308 ? 12.92 * c : 1.055 * Math.pow(c, 1/2.4) - 0.055;
            
            const r = Math.max(0, Math.min(255, Math.round(gamma(r_lin) * 255)));
            const g = Math.max(0, Math.min(255, Math.round(gamma(g_lin) * 255)));
            const b_ = Math.max(0, Math.min(255, Math.round(gamma(b_lin) * 255)));
            
            return `rgb(${r},${g},${b_})`;
        }

        /* 5. Color conversion utilities */
        function hex2rgb(hex) {
            hex = hex.replace('#', '');
            if (hex.length !== 6) {
                throw new Error('Invalid hex color format');
            }
           
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
           
            return { r, g, b };
        }

        // DEPRECATED: DO NOT USE for Lab calculations - use convertColor() API instead
        // This function is kept only for reference but should never be called
        // All Lab conversions MUST go through LittleCMS API for accuracy
        function rgb2lab(r, g, b) {
            console.error('WARNING: rgb2lab() called - this should use LittleCMS API instead!');
            r /= 255;
            g /= 255;
            b /= 255;
           
            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
           
            let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
            let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
            let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
           
            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
           
            const L = (116 * y) - 16;
            const a = 500 * (x - y);
            const b_lab = 200 * (y - z);
           
            return { L, a, b: b_lab };
        }

        // DEPRECATED: DO NOT USE - use convertColor() API instead
        function hex2lab(hex) {
            console.error('WARNING: hex2lab() called - this should use LittleCMS API instead!');
            const rgb = hex2rgb(hex);
            return rgb2lab(rgb.r, rgb.g, rgb.b);
        }

        function isValidHex(hex) {
            const original = hex.trim();
           
            if (original.includes(' ')) {
                return false;
            }
           
            const cleanHex = original.replace('#', '');
           
            if (cleanHex.length === 6 && /^[0-9A-Fa-f]+$/.test(cleanHex)) {
                return true;
            }
           
            return false;
        }

        // DEPRECATED: DO NOT USE for Lab→Hex conversions - use convertColor() API instead
        // This function is kept only for reference but should never be called
        // All Lab→Hex conversions MUST go through LittleCMS API with sRGB.icc for accuracy
        function lab2hex(L, a, b) {
            console.error('WARNING: lab2hex() called - this should use LittleCMS API instead!');
            // Use existing lab2rgb function and extract RGB values
            const rgbString = lab2rgb(L, a, b);
            const rgbMatch = rgbString.match(/rgb\((\d+),(\d+),(\d+)\)/);
           
            if (rgbMatch) {
                const r = parseInt(rgbMatch[1]);
                const g = parseInt(rgbMatch[2]);
                const b_val = parseInt(rgbMatch[3]);
               
                // Convert to hex
                const toHex = (num) => {
                    const hex = num.toString(16).padStart(2, '0');
                    return hex.toUpperCase();
                };
               
                return `#${toHex(r)}${toHex(g)}${toHex(b_val)}`;
            }
           
            return '#000000'; // fallback
        }

        /* 6. API Integration Functions */
       
        // Universal color conversion using the new API with rendering intent
        // Rendering intent only applies to OUTPUT conversions (Lab → RGB/CMYK), not INPUT conversions (RGB/CMYK → Lab)
        async function convertColor(inputData) {
            const apiUrl = `${getApiBaseUrl()}/convert`;
           
            const enhancedInputData = { ...inputData };
           
            // Determine if this is an OUTPUT conversion (Lab → RGB/CMYK) where rendering intent applies
            // INPUT conversions (RGB/Hex/CMYK → Lab) should NOT have rendering intent applied
            const isOutputConversion = inputData.lab !== undefined;
            
            // Only add rendering intent for output conversions (Lab → device color space)
            if (isOutputConversion) {
                const currentIntent = document.getElementById('cmw-default-intent').value;
                if (currentIntent !== 'none') {
                    enhancedInputData.renderingIntent = parseInt(currentIntent);
                }
            }
           
            try {
                console.log('API call to:', apiUrl, isOutputConversion ? '(output conversion with intent)' : '(input conversion, no intent)');
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(enhancedInputData)
                });
               
                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    throw new Error(errorData?.error || `HTTP ${response.status}`);
                }
               
                const data = await response.json();
                console.log('API conversion response:', data);
                return data;
               
            } catch (error) {
                console.error('API conversion failed:', error);
                console.error('API URL attempted:', apiUrl);
                console.error('Check if API server is running and accessible from this device');
                throw error;
            }
        }

        // Color harmony calculation with fallback to local libraries
        async function calculateHarmonies(lab, harmonyType = 'complementary') {
            // First try API if available
            const apiUrl = `${getApiBaseUrl()}/harmony`;
            const activeLibs = getActiveLibraries();
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lab: [lab.L, lab.a, lab.b],
                        harmonyType: harmonyType,
                        libraries: activeLibs,
                        profile: 'GRACoL2013.icc'
                    })
                });
               
                if (response.ok) {
                    const data = await response.json();
                    return data;
                }
               
                throw new Error(`API returned ${response.status}`);
               
            } catch (error) {
                console.warn('API harmony calculation failed, using local fallback:', error);
               
                // Fallback to local harmony calculation with your libraries
                return calculateLocalHarmoniesWithLibraryMatching(lab, harmonyType);
            }
        }

        // Enhanced local harmony calculation with library matching
        function calculateLocalHarmoniesWithLibraryMatching(lab, harmonyType) {
            const harmonies = [];
            const usedColorNames = new Set(); // Track used color names to avoid duplicates
           
            // First, add the ORIGINAL color as the first harmony
            const originalMatches = findClosestInAllLibraries(lab, 1);
            if (originalMatches.length > 0) {
                usedColorNames.add(originalMatches[0].name.toLowerCase());
            }
            harmonies.push({
                lab: [lab.L, lab.a, lab.b],
                gamut: { inGamut: true },
                libraryMatches: groupMatchesByLibrary(originalMatches),
                isOriginal: true
            });
           
            // Then calculate harmony colors
            const baseHue = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
            const baseChroma = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
           
            let hueOffsets = [];
            switch (harmonyType) {
                case 'complementary':
                    hueOffsets = [180]; // Only complementary, original is already added
                    break;
                case 'triadic':
                    hueOffsets = [120, 240]; // Two additional colors
                    break;
                case 'tetradic':
                    hueOffsets = [90, 180, 270]; // Three additional colors
                    break;
                case 'analogous':
                    hueOffsets = [30, -30]; // Two additional colors
                    break;
                case 'splitComplementary':
                    hueOffsets = [150, 210]; // Two additional colors
                    break;
                case 'monochromatic':
                    hueOffsets = [0, 0, 0, 0]; // Four variations of the same hue
                    break;
                default:
                    hueOffsets = [180];
            }
           
            hueOffsets.forEach((offset, index) => {
                let newLab;
                if (harmonyType === 'monochromatic') {
                    // Create more dramatic lightness variations for monochromatic
                    const lightnessMods = [-35, -20, +20, +35];
                    const lightnessMod = lightnessMods[index] || 0;
                    newLab = {
                        L: Math.max(10, Math.min(90, lab.L + lightnessMod)),
                        a: lab.a * 0.8, // Slightly reduce saturation for variety
                        b: lab.b * 0.8
                    };
                } else {
                    const newHue = (baseHue + offset) * Math.PI / 180;
                    // Vary the chroma slightly to get more diverse matches
                    const chromaVariation = 0.8 + (index * 0.1); // 0.8, 0.9, 1.0, 1.1
                    const adjustedChroma = baseChroma * chromaVariation;
                    newLab = {
                        L: lab.L + (index % 2 === 0 ? -5 : 5), // Slight lightness variation
                        a: adjustedChroma * Math.cos(newHue),
                        b: adjustedChroma * Math.sin(newHue)
                    };
                }
               
                // Find matches but exclude already used colors
                const libraryMatches = findUniqueLibraryMatches(newLab, usedColorNames, 3);
               
                // Add the best match to used names
                if (libraryMatches.length > 0) {
                    usedColorNames.add(libraryMatches[0].name.toLowerCase());
                }
               
                harmonies.push({
                    lab: [newLab.L, newLab.a, newLab.b],
                    gamut: { inGamut: true },
                    libraryMatches: groupMatchesByLibrary(libraryMatches),
                    isOriginal: false
                });
            });
           
            return { colors: harmonies };
        }

        // Find library matches while excluding already used color names
        function findUniqueLibraryMatches(targetLab, usedNames, maxResults = 5) {
            const activeLibs = getActiveLibraries();
            const allMatches = [];
            const seenLabValues = new Set(); // Track Lab values to prevent duplicates
           
            for (const libId of activeLibs) {
                const lib = libs[libId];
                if (!lib || lib.length === 0) continue;
               
                for (const color of lib) {
                    // Skip if we've already used this color name
                    if (usedNames.has(color.name.toLowerCase())) {
                        continue;
                    }
                    
                    // Create a key from Lab values (rounded to 1 decimal for matching)
                    const labKey = `${color.L.toFixed(1)}_${color.a.toFixed(1)}_${color.b.toFixed(1)}`;
                    
                    // Skip if we've already seen this Lab value (same color in different library)
                    if (seenLabValues.has(labKey)) {
                        continue;
                    }
                    seenLabValues.add(labKey);
                   
                    const deltaE = dE(targetLab.L, targetLab.a, targetLab.b, color.L, color.a, color.b);
                    allMatches.push({
                        name: color.name,
                        library: color.libraryName || libNames[libId],
                        deltaE: deltaE,
                        lab: [color.L, color.a, color.b],
                        colorData: color
                    });
                }
            }
           
            // Sort by deltaE and return top matches
            allMatches.sort((a, b) => a.deltaE - b.deltaE);
            return allMatches.slice(0, maxResults);
        }

        // Find closest colors across all active libraries
        function findClosestInAllLibraries(targetLab, maxResults = 5) {
            const activeLibs = getActiveLibraries();
            const allMatches = [];
            const seenLabValues = new Set(); // Track Lab values to prevent duplicates
           
            for (const libId of activeLibs) {
                const lib = libs[libId];
                if (!lib || lib.length === 0) continue;
               
                for (const color of lib) {
                    // Create a key from Lab values (rounded to 1 decimal for matching)
                    const labKey = `${color.L.toFixed(1)}_${color.a.toFixed(1)}_${color.b.toFixed(1)}`;
                    
                    // Skip if we've already seen this Lab value (same color in different library)
                    if (seenLabValues.has(labKey)) {
                        continue;
                    }
                    seenLabValues.add(labKey);
                    
                    const deltaE = dE(targetLab.L, targetLab.a, targetLab.b, color.L, color.a, color.b);
                    allMatches.push({
                        name: color.name,
                        library: color.libraryName || libNames[libId],
                        deltaE: deltaE,
                        lab: [color.L, color.a, color.b],
                        colorData: color // Keep full color data
                    });
                }
            }
           
            // Sort by deltaE and return top matches
            allMatches.sort((a, b) => a.deltaE - b.deltaE);
            return allMatches.slice(0, maxResults);
        }

        // Group matches by library for display
        function groupMatchesByLibrary(matches) {
            const grouped = {};
           
            matches.forEach(match => {
                const libKey = match.library.toLowerCase().replace(/\s+/g, '');
                if (!grouped[libKey]) {
                    grouped[libKey] = [];
                }
                grouped[libKey].push(match);
            });
           
            return grouped;
        }

        // Rendering intent comparison - Lab-based approach for consistency, keeping originalData for context
        // For CMYK and Library colors: now uses Lab values instead of original CMYK for consistent behavior
        // For RGB, Hex, Lab: maintains existing working behavior
        async function compareRenderingIntents(lab, originalData = null) {
            const apiUrl = `${getApiBaseUrl()}/rendering-intents`;
           
            try {
                console.log('Making rendering intent API call to:', apiUrl);
               
                // Always use Lab values for the actual API call to ensure consistency
                // This makes CMYK and Library colors work the same as RGB/Hex/Lab
                const requestData = {
                    lab: [lab.L, lab.a, lab.b],
                    targetProfile: 'GRACoL2013.icc'
                };
                console.log('Lab rendering intent request:', requestData);
               
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
               
                if (!response.ok) {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    console.error('Rendering intent API error:', response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
               
                const data = await response.json();
                console.log('Rendering intent API response:', data);
                return data;
               
            } catch (error) {
                console.error('Rendering intent comparison failed:', error);
                console.error('API URL attempted:', apiUrl);
                console.error('Lab values sent:', lab);
                console.error('Original data sent:', originalData);
               
                // Try alternative API endpoint naming
                try {
                    console.log('Trying alternative API endpoint...');
                    const altApiUrl = `${getApiBaseUrl()}/compare-rendering-intents`;
                   
                    // Always use Lab values for alternative endpoint too
                    const altRequestData = {
                        lab: [lab.L, lab.a, lab.b],
                        profile: 'GRACoL2013.icc'
                    };
                   
                    const altResponse = await fetch(altApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(altRequestData)
                    });
                   
                    if (altResponse.ok) {
                        const altData = await altResponse.json();
                        console.log('Alternative API successful:', altData);
                        return altData;
                    }
                } catch (altError) {
                    console.warn('Alternative API also failed:', altError);
                }
               
                throw error;
            }
        }

        // Gamut checking
        async function checkGamut(lab, profile = 'GRACoL2013.icc') {
            const apiUrl = `${getApiBaseUrl()}/gamut-check`;
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lab: [lab.L, lab.a, lab.b],
                        profile: profile
                    })
                });
               
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const data = await response.json();
                return data.gamut;
               
            } catch (error) {
                console.error('Gamut check failed:', error);
                return null;
            }
        }

        // Combined analysis for efficiency
        async function analyzeColor(lab, options = {}) {
            const apiUrl = `${getApiBaseUrl()}/analyze-color`;
            const activeLibs = getActiveLibraries();
           
            const requestData = {
                lab: [lab.L, lab.a, lab.b],
                profile: 'GRACoL2013.icc',
                includeHarmony: options.includeHarmony || false,
                harmonyType: options.harmonyType || 'complementary',
                libraries: activeLibs,
                includeRenderingIntents: options.includeRenderingIntents || false,
                includeGamutBoundary: false  // We don't need 3D data for this UI
            };
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
               
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const data = await response.json();
                return data;
               
            } catch (error) {
                console.error('Color analysis failed:', error);
                throw error;
            }
        }

        /* 7. Dynamic Library Loading System */
        const BASE_URL = 'https://raw.githubusercontent.com/Lrrr908/bastards-of-the-multiverse/main/files/theme/';
        const libs = {};
        const libNames = {};
        let libraryManifest = [];

        // Default library configuration (fallback if manifest doesn't exist yet)
        const defaultLibraries = [
            { id: "pantone", name: "PMS", file: "pantone.json", enabled: true },
            { id: "behr", name: "Behr", file: "behr.json", enabled: true },
            { id: "sherwin", name: "Sherwin Williams", file: "sherwin.json", enabled: true },
            { id: "bm", name: "Benjamin Moore", file: "benjaminmoore.json", enabled: true }
        ];

        // Load the library manifest and initialize all libraries
        async function initializeLibraries() {
            try {
                const manifestUrl = BASE_URL + 'libraries.json';
                console.log('=== INITIALIZING LIBRARIES ===');
                console.log('Manifest URL:', manifestUrl);
                
                let manifestData;
                try {
                    const manifestRes = await fetch(manifestUrl);
                    console.log('Manifest fetch response:', manifestRes.status, manifestRes.statusText);
                    
                    if (manifestRes.ok) {
                        manifestData = await manifestRes.json();
                        console.log('✔ Manifest loaded from server');
                    } else {
                        throw new Error(`HTTP ${manifestRes.status}`);
                    }
                } catch (manifestError) {
                    console.warn('⚠ Manifest not found, using default libraries:', manifestError.message);
                    manifestData = { libraries: defaultLibraries };
                }
                
                console.log('Manifest data:', manifestData);
                
                if (!manifestData.libraries || !Array.isArray(manifestData.libraries)) {
                    throw new Error('Invalid manifest format: missing libraries array');
                }
                
                libraryManifest = manifestData.libraries.filter(lib => lib.enabled);
                
                console.log(`✔ ${libraryManifest.length} libraries enabled`);
                
                // Create checkboxes for each library
                const container = document.getElementById('cmw-public-libraries-container');
                if (!container) {
                    throw new Error('Library container not found in DOM');
                }
                
                libraryManifest.forEach(lib => {
                    libNames[lib.id] = lib.name;
                    
                    const toggleItem = document.createElement('div');
                    toggleItem.className = 'cmw-toggle-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `toggle-${lib.id}`;
                    checkbox.value = lib.id;
                    checkbox.checked = true;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `toggle-${lib.id}`;
                    
                    const labelText = document.createTextNode(lib.name + ' ');
                    const countSpan = document.createElement('span');
                    countSpan.className = 'cmw-library-count';
                    countSpan.id = `count-${lib.id}`;
                    countSpan.textContent = '(0)';
                    
                    label.appendChild(labelText);
                    label.appendChild(countSpan);
                    toggleItem.appendChild(checkbox);
                    toggleItem.appendChild(label);
                    container.appendChild(toggleItem);
                    
                    console.log(`Created checkbox for library: ${lib.name}`);
                });
                
                // Add custom libraries container inside the grid (uses display:contents to flow)
                const customContainer = document.createElement('div');
                customContainer.id = 'cmw-custom-libraries-container';
                customContainer.style.display = 'contents';
                container.appendChild(customContainer);
                
                console.log('Custom libraries container added to grid');
                
                // Load all library data files (use allSettled to continue even if some fail)
                const loadPromises = libraryManifest.map(lib => {
                    // Determine URL - use lib.url if specified, otherwise construct from BASE_URL + file
                    const url = lib.url || (lib.source === 'url' ? lib.url : BASE_URL + lib.file);
                    const format = lib.format || 'json';
                    return loadLibrary(lib.id, url, lib.name, format);
                });
                const results = await Promise.allSettled(loadPromises);
                
                const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
                console.log(`✔ Libraries initialized: ${successCount}/${libraryManifest.length} loaded successfully`);
            } catch (e) {
                console.error('✖ Failed to initialize libraries:', e);
                // Continue even if manifest fails - show empty state
            }
        }

        async function loadLibrary(id, url, name, format = 'json') {
            try {
                console.log(`Loading ${name} from ${url} (format: ${format})...`);
                const res = await fetch(url);
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }
                
                let colors;
                
                // Handle different formats
                if (format === 'filamentcolors') {
                    // Filament Colors format - may have RGB that needs conversion
                    const data = await res.json();
                    colors = await parseFilamentColorsData(data, name);
                } else if (format === 'cxf') {
                    // CXF format - needs API endpoint
                    const blob = await res.blob();
                    colors = await parseCxfData(blob, name);
                } else if (format === 'csv') {
                    // CSV format - needs API endpoint
                    const text = await res.text();
                    colors = await parseCsvData(text, name);
                } else {
                    // Default JSON format
                    colors = await res.json();
                }
                
                // Validate it's an array
                if (!Array.isArray(colors)) {
                    throw new Error('Library data must be an array');
                }
                
                // Map colors and ensure required fields exist
                libs[id] = colors.map((color, index) => {
                    // Validate required fields
                    if (typeof color.L !== 'number' || typeof color.a !== 'number' || typeof color.b !== 'number') {
                        console.warn(`${name}: Color at index ${index} missing Lab values, skipping`);
                        return null;
                    }
                    
                    return {
                        name: color.name || `Unnamed ${index + 1}`,
                        L: color.L,
                        a: color.a,
                        b: color.b,
                        hex: color.hex || '#808080',
                        library: id,
                        libraryName: name,
                        // Preserve ALL original fields from the color object
                        ...color,
                        // But ensure these core fields are correct
                        library: id,
                        libraryName: name
                    };
                }).filter(Boolean); // Remove any null entries
               
                const countEl = document.getElementById(`count-${id}`);
                if (countEl) {
                    countEl.textContent = `(${libs[id].length})`;
                }
               
                console.log(`✔ ${name} loaded successfully (${libs[id].length} colors)`);
                return true;
            } catch (e) {
                console.error(`✖ ${name} failed to load:`, e.message, `(${url})`);
                libs[id] = [];
                
                // Update count to show 0
                const countEl = document.getElementById(`count-${id}`);
                if (countEl) {
                    countEl.textContent = '(0)';
                }
                return false;
            }
        }
        
        // Parse Filament Colors format (handles RGB -> Lab conversion)
        async function parseFilamentColorsData(data, libraryName) {
            const API_URL = document.getElementById('cmw-api-url')?.value || 'http://127.0.0.1:8000';
            const colors = [];
            
            // Handle both array and nested format
            const colorArray = Array.isArray(data) ? data : (data.colors || []);
            
            for (const item of colorArray) {
                let color = { ...item };
                
                // If has Lab values, use them directly
                if (typeof color.L === 'number' && typeof color.a === 'number' && typeof color.b === 'number') {
                    colors.push(color);
                    continue;
                }
                
                // If has RGB but not Lab, convert via API
                if (color.rgb || (typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number')) {
                    try {
                        const rgb = color.rgb || { r: color.r, g: color.g, b: color.b };
                        const response = await fetch(`${API_URL}/rgb-to-lab`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ r: rgb.r, g: rgb.g, b: rgb.b })
                        });
                        
                        if (response.ok) {
                            const labData = await response.json();
                            color.L = labData.lab[0];
                            color.a = labData.lab[1];
                            color.b = labData.lab[2];
                            colors.push(color);
                        } else {
                            console.warn(`Failed to convert RGB for color: ${color.name}`);
                        }
                    } catch (e) {
                        console.warn(`RGB conversion failed for: ${color.name}`, e);
                    }
                } else if (color.hex) {
                    // If has hex but not Lab, convert via API
                    try {
                        const response = await fetch(`${API_URL}/hex-to-lab/${encodeURIComponent(color.hex)}`);
                        if (response.ok) {
                            const labData = await response.json();
                            color.L = labData.lab[0];
                            color.a = labData.lab[1];
                            color.b = labData.lab[2];
                            colors.push(color);
                        } else {
                            console.warn(`Failed to convert hex for color: ${color.name}`);
                        }
                    } catch (e) {
                        console.warn(`Hex conversion failed for: ${color.name}`, e);
                    }
                }
            }
            
            console.log(`Parsed ${colors.length} colors from ${libraryName}`);
            return colors;
        }
        
        // Parse CXF format via API
        async function parseCxfData(blob, libraryName) {
            const API_URL = document.getElementById('cmw-api-url')?.value || 'http://127.0.0.1:8000';
            
            const formData = new FormData();
            formData.append('file', blob, 'library.cxf');
            
            const response = await fetch(`${API_URL}/import-cxf`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error('CXF parsing failed');
            }
            
            const data = await response.json();
            return data.colors || [];
        }
        
        // Parse CSV format via API
        async function parseCsvData(text, libraryName) {
            const API_URL = document.getElementById('cmw-api-url')?.value || 'http://127.0.0.1:8000';
            
            const blob = new Blob([text], { type: 'text/csv' });
            const formData = new FormData();
            formData.append('file', blob, 'library.csv');
            
            const response = await fetch(`${API_URL}/import-csv`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error('CSV parsing failed');
            }
            
            const data = await response.json();
            return data.colors || [];
        }

        /* 8. Library management functions */
        function getActiveLibraries() {
            const activeLibs = [];
            // Check all public libraries
            document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]').forEach(checkbox => {
                if (checkbox.checked && checkbox.value) {
                    activeLibs.push(checkbox.value);
                }
            });
            // Check custom libraries
            document.querySelectorAll('#cmw-custom-libraries-container input[type="checkbox"]').forEach(checkbox => {
                if (checkbox.checked && checkbox.value) {
                    activeLibs.push(checkbox.value);
                }
            });
            return activeLibs;
        }

        function initializeLibraryCounts() {
            // Update counts for all libraries (both public and custom)
            Object.keys(libs).forEach(libId => {
                const countEl = document.getElementById(`count-${libId}`);
                if (countEl && libs[libId]) {
                    countEl.textContent = `(${libs[libId].length})`;
                }
            });
        }

        function nearest(L, a, b, maxPerLibrary = 1, excludeExactMatch = null) {
            const activeLibs = getActiveLibraries();
            console.log('=== Color Search nearest() ===');
            console.log('Input Lab:', `Lab(${L}, ${a}, ${b})`);
            console.log('Active libraries:', activeLibs);
            const allMatches = [];
           
            for (const libId of activeLibs) {
                const lib = libs[libId];
                if (!lib || lib.length === 0) continue;
               
                const libMatches = [];
                for (const c of lib) {
                    const deltaE = dE(L, a, b, c.L, c.a, c.b);
                    
                    // Log first few matches for debugging
                    if (libMatches.length < 3) {
                        console.log(`  ${c.name}: Lab(${c.L}, ${c.a}, ${c.b}) -> ΔE=${deltaE.toFixed(4)}`);
                    }
                   
                    // More robust exclusion logic
                    let shouldExclude = false;
                   
                    if (excludeExactMatch) {
                        // Exclude by name (case-insensitive)
                        if (c.name.toLowerCase() === excludeExactMatch.toLowerCase()) {
                            shouldExclude = true;
                            console.log('Excluding exact name match:', c.name);
                        }
                       
                        // Exclude if deltaE is very small (likely the same color)
                        if (deltaE < 1.0) {
                            shouldExclude = true;
                            console.log('Excluding small deltaE match:', c.name, 'deltaE:', deltaE);
                        }
                       
                        // Exclude if Lab values are very close
                        if (Math.abs(c.L - L) < 0.5 && Math.abs(c.a - a) < 0.5 && Math.abs(c.b - b) < 0.5) {
                            shouldExclude = true;
                            console.log('Excluding close Lab values match:', c.name);
                        }
                    }
                   
                    if (!shouldExclude) {
                        libMatches.push({ c, d: deltaE });
                    }
                }
               
                console.log(`Library ${libId}: ${libMatches.length} matches (before limiting to ${maxPerLibrary})`);
                libMatches.sort((x, y) => x.d - y.d);
               
                // If we have matches but need to skip duplicates, get more results
                if (excludeExactMatch && libMatches.length > 0) {
                    // Filter out any remaining duplicates by name and get extra results
                    const filteredMatches = [];
                    const usedNames = new Set();
                   
                    for (const match of libMatches) {
                        const normalizedName = match.c.name.toLowerCase().trim();
                        if (!usedNames.has(normalizedName)) {
                            usedNames.add(normalizedName);
                            filteredMatches.push(match);
                           
                            // Stop when we have enough unique results
                            if (filteredMatches.length >= maxPerLibrary) {
                                break;
                            }
                        }
                    }
                   
                    console.log(`Library ${libId}: ${filteredMatches.length} unique matches after filtering`);
                    allMatches.push(...filteredMatches);
                } else {
                    // No exclusion needed, just take the top results
                    console.log(`Library ${libId}: taking top ${maxPerLibrary} matches`);
                    allMatches.push(...libMatches.slice(0, maxPerLibrary));
                }
            }
           
            // Final deduplication across all libraries
            const finalMatches = [];
            const globalUsedNames = new Set();
            const globalUsedLabValues = new Set();
           
            const sortedMatches = allMatches.sort((x, y) => x.d - y.d);
            console.log('All matches before final deduplication:', sortedMatches.length);
           
            for (const match of sortedMatches) {
                const normalizedName = match.c.name.toLowerCase().trim();
                const labKey = `${match.c.L.toFixed(1)}_${match.c.a.toFixed(1)}_${match.c.b.toFixed(1)}`;
               
                // Check for duplicate names or very similar Lab values
                if (!globalUsedNames.has(normalizedName) && !globalUsedLabValues.has(labKey)) {
                    globalUsedNames.add(normalizedName);
                    globalUsedLabValues.add(labKey);
                    finalMatches.push(match);
                } else {
                    console.log('Global duplicate filtered:', match.c.name, 'deltaE:', match.d.toFixed(2));
                }
            }
           
            console.log('Final unique matches:', finalMatches.length);
            return finalMatches;
        }

        /* 9. UI Helper Functions */
       
        function showStatus(message, type = 'success', persistent = false) {
            const status = document.getElementById('cmw-status');
            status.textContent = message;
            status.className = `cmw-status ${type} show`;
           
            if (!persistent) {
                setTimeout(() => status.classList.remove('show'), 5000);
            }
        }

        function showLoading(show = true) {
            const loading = document.getElementById('cmw-loading');
            loading.classList.toggle('show', show);
        }

        function getResultsCount() {
            const resultsSelect = document.getElementById('cmw-results-count');
            return parseInt(resultsSelect ? resultsSelect.value : '1');
        }

        /* 10. Color Preview Functions */
       
        // Helper function - kept for compatibility but no longer shows separate swatch
        async function updateIntentSwatch(lab) {
            // Rendering intent is now applied directly through convertColor() API
            // No separate intent swatch needed
        }
       
        function updateColorPreview() {
            const preview = document.getElementById('cmw-color-preview');
            const selectedType = document.getElementById('cmw-search-type-select').value;
           
            if (preview.dataset.isHovering === 'true') {
                return;
            }
           
            if (preview.classList.contains('selected') && selectedType === 'name') {
                const nameInput = document.getElementById('cmw-name-input');
                const currentValue = nameInput.value.trim();
               
                if (currentValue && preview.dataset.selectedColor) {
                    preview.style.backgroundColor = preview.dataset.selectedColor;
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    preview.classList.add('valid', 'selected');
                   
                    if (preview.dataset.selectedName) {
                        updateSelectedColorInfo({
                            name: preview.dataset.selectedName,
                            libraryName: preview.dataset.selectedLibrary,
                            L: parseFloat(preview.dataset.selectedL),
                            a: parseFloat(preview.dataset.selectedA),
                            b: parseFloat(preview.dataset.selectedB)
                        });
                    }
                    return;
                }
               
                if (!currentValue || currentValue.length < 3) {
                    preview.classList.remove('selected');
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    delete preview.dataset.originalHexInput;
                    updateSelectedColorInfo(null);
                }
            }
           
            let color = null;
            let isValid = false;
           
            // Clear converted color info when switching to name mode or clearing inputs
            if (selectedType === 'name') {
                updateConvertedColorInfo(null);
                const query = document.getElementById('cmw-name-input').value.trim();
                if (isValidHex(query)) {
                    const normalizedHex = query.startsWith('#') ? query : '#' + query;
                    color = normalizedHex;
                    isValid = true;
                    
                    // Store the original hex input for the color modal
                    preview.dataset.originalHexInput = normalizedHex.toUpperCase();
                   
                    // Show converted Lab values for hex input
                    if (query.length >= 6) {
                        const rgb = hex2rgb(normalizedHex);
                        console.log(`[Color Search] Converting hex ${normalizedHex} -> RGB(${rgb.r}, ${rgb.g}, ${rgb.b})`);
                        convertColor({
                            rgb: [rgb.r, rgb.g, rgb.b],
                            profile: 'sRGB.icc'
                        }).then(data => {
                            console.log(`[Color Search] Hex ${normalizedHex} -> Lab(${data.lab[0]}, ${data.lab[1]}, ${data.lab[2]})`);
                            const gamutToggle = document.getElementById('cmw-gamut-toggle');
                            const showGamut = gamutToggle && gamutToggle.checked;
                           
                            const labValues = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                            currentColorData = labValues; // Set for intent updates
                           
                            // Clear original input data for hex input
                            currentOriginalInputData = null;
                           
                            if (showGamut && data.gamut) {
                                updateConvertedColorInfo(
                                    labValues,
                                    'api',
                                    'sRGB → GRACoL gamut',
                                    data.gamut.inGamut
                                );
                            } else {
                                updateConvertedColorInfo(
                                    labValues,
                                    'api',
                                    'sRGB.icc'
                                );
                            }
                           
                            // Update intent swatch for hex input
                            updateIntentSwatch(labValues);
                           
                            // Update rendering comparison if enabled
                            const intentsToggle = document.getElementById('cmw-intents-toggle');
                            if (intentsToggle && intentsToggle.checked) {
                                console.log('Updating rendering intents for hex input:', labValues);
                                updateRenderingIntents(labValues, null); // No original data for hex input
                            }
                        }).catch(error => {
                            console.error('LittleCMS API conversion failed:', error);
                            // Show error state - no fallback to local JS conversion
                            preview.style.backgroundColor = '#f0f0f0';
                            preview.classList.remove('valid');
                            currentColorData = null;
                            currentOriginalInputData = null;
                            updateConvertedColorInfo(null);
                            
                            // Show error message to user
                            const infoEl = document.getElementById('cmw-converted-color-info');
                            if (infoEl) {
                                infoEl.innerHTML = '<span style="color: #dc2626;">LittleCMS API unavailable</span>';
                            }
                        });
                    }
                } else {
                    // Clear for invalid hex or when clearing
                    currentColorData = null;
                }
            } else if (selectedType === 'lab') {
                const L = parseFloat(document.getElementById('cmw-lab-l').value);
                const a = parseFloat(document.getElementById('cmw-lab-a').value);
                const b = parseFloat(document.getElementById('cmw-lab-b').value);
               
                if (!isNaN(L) && !isNaN(a) && !isNaN(b) &&
                    L >= 0 && L <= 100 && a >= -128 && a <= 127 && b >= -128 && b <= 127) {
                    color = lab2rgb(L, a, b); // Quick preview with local conversion
                    isValid = true;
                    const labValues = { L: L, a: a, b: b };
                    currentColorData = labValues; // Set for intent updates
                   
                    // Clear original input data for Lab input
                    currentOriginalInputData = null;
                   
                    // Use LittleCMS for accurate preview color (Lab → RGB uses sRGB)
                    convertColor({
                        lab: [L, a, b],
                        profile: 'sRGB.icc'
                    }).then(data => {
                        if (data.hex) {
                            let hexColor = data.hex;
                            if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                            preview.style.backgroundColor = hexColor;
                        }
                    }).catch(() => {
                        // Keep local conversion on error
                    });
                   
                    const gamutToggle = document.getElementById('cmw-gamut-toggle');
                    const showGamutColors = gamutToggle && gamutToggle.checked;
                   
                    // Always update converted color info for Lab input
                    if (showGamutColors) {
                        checkGamut(labValues, 'GRACoL2013.icc')
                            .then(gamutData => {
                                updateConvertedColorInfo(
                                    labValues,
                                    'direct',
                                    'Lab → GRACoL2013.icc',
                                    gamutData ? gamutData.inGamut : null
                                );
                                updateGamutWarning(gamutData, 'GRACoL2013.icc');
                            })
                            .catch(() => {
                                updateConvertedColorInfo(labValues, 'direct', 'Lab values');
                            });
                    } else {
                        updateConvertedColorInfo(labValues, 'direct', 'Lab values');
                    }
                   
                    // Update intent swatch for Lab input
                    updateIntentSwatch(labValues);
                   
                    // Update rendering comparison if enabled
                    const intentsToggle = document.getElementById('cmw-intents-toggle');
                    if (intentsToggle && intentsToggle.checked) {
                        console.log('Updating rendering intents for Lab input:', labValues);
                        updateRenderingIntents(labValues, null); // No original data for Lab input
                    }
                } else {
                    currentColorData = null;
                    // Only clear if invalid values
                    updateConvertedColorInfo(null);
                }
            } else if (selectedType === 'cmyk') {
                const c = parseFloat(document.getElementById('cmw-cmyk-c').value);
                const m = parseFloat(document.getElementById('cmw-cmyk-m').value);
                const y = parseFloat(document.getElementById('cmw-cmyk-y').value);
                const k = parseFloat(document.getElementById('cmw-cmyk-k').value);
               
                if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k) &&
                    c >= 0 && c <= 100 && m >= 0 && m <= 100 && y >= 0 && y <= 100 && k >= 0 && k <= 100) {
                   
                    isValid = true;
                   
                    // Use API conversion for accurate preview
                    const profile = document.getElementById('cmw-profile-select').value;
                    convertColor({
                        cmyk: [c, m, y, k],
                        profile: profile
                    }).then(data => {
                        // Use LittleCMS hex for accurate color display - no fallback
                        if (!data.hex) {
                            throw new Error('LittleCMS did not return hex value');
                        }
                        let accurateColor = data.hex;
                        if (!accurateColor.startsWith('#')) {
                            accurateColor = '#' + accurateColor;
                        }
                        preview.style.backgroundColor = accurateColor;
                        preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                        preview.classList.add('valid');
                       
                        const labValues = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                        currentColorData = labValues; // Set for intent updates
                       
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        const showGamutColors = gamutToggle && gamutToggle.checked;
                        const currentIntent = document.getElementById('cmw-default-intent').value;
                       
                        // Update converted color info
                        if (showGamutColors) {
                            const gamutData = data.gamut || null;
                            updateConvertedColorInfo(
                                labValues,
                                'api',
                                profile,
                                gamutData ? gamutData.inGamut : null
                            );
                            updateGamutWarning(data.gamut, profile);
                           
                            // If rendering intent is "none" but we don't have gamut data, make explicit call
                            if (currentIntent === 'none' && !gamutData) {
                                checkGamut(labValues, profile)
                                    .then(explicitGamutData => {
                                        updateConvertedColorInfo(
                                            labValues,
                                            'api',
                                            profile,
                                            explicitGamutData ? explicitGamutData.inGamut : null
                                        );
                                        updateGamutWarning(explicitGamutData, profile);
                                    })
                                    .catch(() => {
                                        updateConvertedColorInfo(labValues, 'api', profile);
                                    });
                            }
                        } else {
                            updateConvertedColorInfo(labValues, 'api', profile);
                        }
                       
                        // Store original CMYK data for rendering intent comparison (Lab-based but with context)
                        currentOriginalInputData = {
                            type: 'cmyk',
                            values: [c, m, y, k],
                            profile: profile
                        };
                       
                        // Update intent swatch for CMYK input
                        updateIntentSwatch(labValues);
                       
                        // Update rendering comparison if enabled - ensure CMYK works like other input types
                        const intentsToggle = document.getElementById('cmw-intents-toggle');
                        if (intentsToggle && intentsToggle.checked) {
                            console.log('Updating rendering intents for CMYK input:', labValues);
                            // For CMYK, clear the original data to ensure consistent Lab-based processing
                            updateRenderingIntents(labValues, null);
                        }
                    }).catch(error => {
                        console.error('LittleCMS API CMYK conversion failed:', error);
                        // Show error state - no fallback to local JS conversion
                        preview.style.backgroundColor = '#f0f0f0';
                        preview.classList.remove('valid');
                        currentColorData = null;
                        currentOriginalInputData = null;
                        updateConvertedColorInfo(null);
                        
                        // Show error message to user
                        const infoEl = document.getElementById('cmw-converted-color-info');
                        if (infoEl) {
                            infoEl.innerHTML = '<span style="color: #dc2626;">LittleCMS API unavailable</span>';
                        }
                    });
                   
                    return; // Don't set color here since we're handling it asynchronously
                } else {
                    currentColorData = null;
                }
            } else if (selectedType === 'rgb') {
                const r = parseFloat(document.getElementById('cmw-rgb-r').value);
                const g = parseFloat(document.getElementById('cmw-rgb-g').value);
                const b = parseFloat(document.getElementById('cmw-rgb-b').value);
               
                if (!isNaN(r) && !isNaN(g) && !isNaN(b) &&
                    r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                    color = `rgb(${r}, ${g}, ${b})`; // Quick preview
                    isValid = true;
                   
                    // Show converted Lab values for RGB input
                    convertColor({
                        rgb: [r, g, b],
                        profile: 'sRGB.icc'
                    }).then(data => {
                        // Use LittleCMS hex for accurate preview color
                        if (data.hex) {
                            let hexColor = data.hex;
                            if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                            preview.style.backgroundColor = hexColor;
                        }
                        
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        const showGamut = gamutToggle && gamutToggle.checked;
                       
                        const labValues = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                        currentColorData = labValues; // Set for intent updates
                       
                        // Clear original input data for RGB input
                        currentOriginalInputData = null;
                       
                        if (showGamut && data.gamut) {
                            updateConvertedColorInfo(
                                labValues,
                                'api',
                                'sRGB → GRACoL gamut',
                                data.gamut.inGamut
                            );
                        } else {
                            updateConvertedColorInfo(
                                labValues,
                                'api',
                                'sRGB.icc'
                            );
                        }
                       
                        // Update intent swatch for RGB input
                        updateIntentSwatch(labValues);
                       
                        // Update rendering comparison if enabled
                        const intentsToggle = document.getElementById('cmw-intents-toggle');
                        if (intentsToggle && intentsToggle.checked) {
                            console.log('Updating rendering intents for RGB input:', labValues);
                            updateRenderingIntents(labValues, null); // No original data for RGB input
                        }
                    }).catch(error => {
                        console.error('LittleCMS API RGB conversion failed:', error);
                        // Show error state - no fallback to local JS conversion
                        preview.style.backgroundColor = '#f0f0f0';
                        preview.classList.remove('valid');
                        currentColorData = null;
                        currentOriginalInputData = null;
                        updateConvertedColorInfo(null);
                        
                        // Show error message to user
                        const infoEl = document.getElementById('cmw-converted-color-info');
                        if (infoEl) {
                            infoEl.innerHTML = '<span style="color: #dc2626;">LittleCMS API unavailable</span>';
                        }
                    });
                } else {
                    currentColorData = null;
                }
            }
           
            if (isValid && color) {
                preview.style.backgroundColor = color;
                preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                preview.classList.add('valid');
                if (selectedType !== 'name') {
                    preview.classList.remove('selected');
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    delete preview.dataset.originalHexInput;
                    updateSelectedColorInfo(null);
                }
            } else {
                preview.style.backgroundColor = '#f8fafc';
                preview.style.borderColor = '#e2e8f0';
                preview.classList.remove('valid');
               
                if (!isValid) {
                    preview.classList.remove('selected');
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    delete preview.dataset.originalHexInput;
                    if (selectedType !== 'name' || !preview.classList.contains('selected')) {
                        updateSelectedColorInfo(null);
                    }
                    if (selectedType !== 'lab') {
                        updateConvertedColorInfo(null);
                    }
                    updateGamutWarning(null);
                   
                    // Reset when no valid color
                    currentColorData = null;
                }
            }
        }

        // DEPRECATED: DO NOT USE for CMYK conversions - use convertColor() API instead
        // This function is kept only for reference but should never be called
        // All CMYK conversions MUST go through LittleCMS API with GRACoL2013.icc for accuracy
        function cmyk2rgb(c, m, y, k) {
            console.error('WARNING: cmyk2rgb() called - this should use LittleCMS API instead!');
            // Convert percentages to decimals
            c = c / 100;
            m = m / 100;
            y = y / 100;
            k = k / 100;
           
            // Standard CMYK to RGB conversion formula
            const r = Math.round(255 * (1 - c) * (1 - k));
            const g = Math.round(255 * (1 - m) * (1 - k));
            const b = Math.round(255 * (1 - y) * (1 - k));
           
            return {
                r: Math.max(0, Math.min(255, r)),
                g: Math.max(0, Math.min(255, g)),
                b: Math.max(0, Math.min(255, b))
            };
        }

        async function updateSelectedColorInfo(colorData = null) {
            const colorInfoEl = document.getElementById('cmw-selected-color-info');
            const colorLibraryEl = document.getElementById('cmw-selected-color-library');
            const colorLabEl = document.getElementById('cmw-selected-color-lab');
            const mainSwatch = document.getElementById('cmw-color-preview');
           
            if (colorData) {
                colorLibraryEl.textContent = colorData.libraryName || 'Unknown';
               
                // Get current rendering intent
                const currentIntent = document.getElementById('cmw-default-intent').value;
                const intentNames = {
                    'none': 'None',
                    '0': 'Perceptual',
                    '1': 'Relative Colorimetric',
                    '2': 'Saturation',
                    '3': 'Absolute Colorimetric'
                };
               
                // Show original library values
                const originalLab = `Lab(${colorData.L.toFixed(2)}, ${colorData.a.toFixed(2)}, ${colorData.b.toFixed(2)})`;
               
                // Set swatch color using LittleCMS with rendering intent applied
                const mainColor = lab2rgb(colorData.L, colorData.a, colorData.b);
                mainSwatch.style.backgroundColor = mainColor;
                mainSwatch.style.borderColor = '#e2e8f0';
                mainSwatch.classList.add('valid', 'selected');
               
                // Use LittleCMS to get the accurate color with rendering intent (Lab → RGB uses sRGB)
                convertColor({
                    lab: [colorData.L, colorData.a, colorData.b],
                    profile: 'sRGB.icc'
                }).then(data => {
                    if (data.hex) {
                        let hexColor = data.hex;
                        if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                        mainSwatch.style.backgroundColor = hexColor;
                    }
                }).catch(() => {
                    // Keep local conversion on error
                });
               
                // Show Lab values with rendering intent info
                const gamutToggle = document.getElementById('cmw-gamut-toggle');
                const showGamutColors = gamutToggle && gamutToggle.checked;
               
                if (showGamutColors) {
                    checkGamut(
                        { L: colorData.L, a: colorData.a, b: colorData.b },
                        'GRACoL2013.icc'
                    ).then(gamutData => {
                        let colorStyle = '';
                        if (gamutData) {
                            colorStyle = gamutData.inGamut ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                        }
                        colorLabEl.innerHTML = `<span ${colorStyle}>${originalLab}</span><br><small style="color: #6b7280;">(${intentNames[currentIntent]})</small>`;
                    }).catch(() => {
                        colorLabEl.innerHTML = `${originalLab}<br><small style="color: #6b7280;">(${intentNames[currentIntent]})</small>`;
                    });
                } else {
                    colorLabEl.innerHTML = `${originalLab}<br><small style="color: #6b7280;">(${intentNames[currentIntent]})</small>`;
                }
               
                colorInfoEl.classList.add('show');
               
                // Update rendering comparison if enabled
                const intentsToggle = document.getElementById('cmw-intents-toggle');
                if (intentsToggle && intentsToggle.checked && colorData.L && colorData.a !== undefined && colorData.b !== undefined) {
                    currentOriginalInputData = {
                        type: 'library',
                        colorName: colorData.name,
                        libraryName: colorData.libraryName
                    };
                    updateRenderingIntents({ L: colorData.L, a: colorData.a, b: colorData.b }, currentOriginalInputData);
                }
            } else {
                colorInfoEl.classList.remove('show');
                colorLibraryEl.textContent = '';
                colorLabEl.innerHTML = '';
            }
        }

        /* ─────────────────────
           Section 4 Java Part 2
           ───────────────────── */

        function updateConvertedColorInfo(labData = null, conversionMethod = '', profile = '', gamutStatus = null, renderingIntentData = null) {
            const convertedInfoEl = document.getElementById('cmw-converted-color-info');
            const convertedLabEl = document.getElementById('cmw-converted-color-lab');
            const convertedCmykEl = document.getElementById('cmw-converted-cmyk');
            const convertedTitleEl = convertedInfoEl.querySelector('div:first-child');
            
            // Helper to create gamut indicator text
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            const showGamutIndicator = gamutToggle && gamutToggle.checked;
            
            function getGamutIndicator(inGamut) {
                if (!showGamutIndicator || inGamut === null || inGamut === undefined) {
                    return '';
                }
                if (inGamut) {
                    return '<div style="margin-top: 4px; color: #10b981; font-weight: 600; font-size: 12px;">✓ In Gamut (GRACoL2013)</div>';
                } else {
                    return '<div style="margin-top: 4px; color: #ef4444; font-weight: 600; font-size: 12px;">⚠ Out of Gamut (GRACoL2013)</div>';
                }
            }
           
            if (labData) {
                let methodText = '';
                if (conversionMethod === 'api') {
                    methodText = profile ? ` (${profile})` : ' ';
                } else if (conversionMethod === 'direct') {
                    methodText = profile ? `<br><small style="color: #6b7280;">(${profile})</small>` : '';
                } else if (conversionMethod === 'library') {
                    // For library colors, show "Known Lab Values" as title
                    if (convertedTitleEl) {
                        convertedTitleEl.textContent = 'Known Lab Values';
                    }
                    methodText = profile ? `<br><small style="color: #6b7280;">(${profile})</small>` : '';
                }
                
                // Reset title for non-library methods
                if (conversionMethod !== 'library' && convertedTitleEl) {
                    convertedTitleEl.textContent = 'Converted Lab Values';
                }
               
                // Get current rendering intent and show both original and converted values if different
                const currentIntent = document.getElementById('cmw-default-intent').value;
                const intentsToggle = document.getElementById('cmw-intents-toggle');
                const showRenderingComparison = intentsToggle && intentsToggle.checked;
                const intentNames = {
                    '0': 'P.',
                    '1': 'R.C.',
                    '2': 'S.',
                    '3': 'A.C.'
                };
               
                // Only show rendering intent comparison if BOTH the toggle is ON and intent is not 'none'
                if (showRenderingComparison && currentIntent !== 'none') {
                    // Try to get rendering intent converted values
                    compareRenderingIntents(labData).then(data => {
                        const intentMap = {
                            '0': 'perceptual',
                            '1': 'relative',
                            '2': 'saturation',
                            '3': 'absolute'
                        };
                       
                        const selectedIntentName = intentMap[currentIntent];
                        if (data.renderingIntents[selectedIntentName] && data.renderingIntents[selectedIntentName].lab) {
                            const convertedLab = data.renderingIntents[selectedIntentName].lab;
                            const intentGamut = data.renderingIntents[selectedIntentName].gamut;
                           
                            // Apply color to Lab values based on gamut status ONLY if gamut indicator is enabled
                            let originalColorStyle = '';
                            if (showGamutIndicator && gamutStatus !== null) {
                                originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                            }
                           
                            let intentColorStyle = '';
                            if (showGamutIndicator && intentGamut) {
                                intentColorStyle = intentGamut.inGamut ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                            }
                           
                            const convertedLabText = `<span ${intentColorStyle}>Lab(${convertedLab[0].toFixed(2)}, ${convertedLab[1].toFixed(2)}, ${convertedLab[2].toFixed(2)})</span>`;
                            const originalLabText = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                           
                            // Check if values actually changed
                            const valuesChanged = (
                                Math.abs(labData.L - convertedLab[0]) > 0.05 ||
                                Math.abs(labData.a - convertedLab[1]) > 0.05 ||
                                Math.abs(labData.b - convertedLab[2]) > 0.05
                            );
                           
                            // Get CMYK conversion and then update display
                            const selectedType = document.getElementById('cmw-search-type-select').value;
                            if (selectedType === 'lab') {
                                convertColor({
                                    lab: [labData.L, labData.a, labData.b],
                                    profile: 'GRACoL2013.icc'
                                }).then(cmykData => {
                                    let cmykText = '';
                                    let mainGamutStatus = null;
                                    if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                        const cmyk = cmykData.gamut.cmykEquivalent;
                                        cmykText = `<br>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})`;
                                        mainGamutStatus = cmykData.gamut.inGamut;
                                    }
                                   
                                    if (valuesChanged) {
                                        // Show both Lab values + CMYK + gamut indicator
                                        convertedLabEl.innerHTML = `
                                            <div style="margin-bottom: 4px;">
                                                <strong>Main:</strong> ${originalLabText}
                                            </div>
                                            <div>
                                                <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                            </div>
                                            ${cmykText}
                                            <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                            ${getGamutIndicator(mainGamutStatus)}
                                        `;
                                    } else {
                                        // Values are the same, show single Lab value + CMYK + gamut indicator
                                        convertedLabEl.innerHTML = `${convertedLabText}${cmykText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>${getGamutIndicator(mainGamutStatus)}`;
                                    }
                                }).catch(() => {
                                    // CMYK conversion failed, show without CMYK
                                    if (valuesChanged) {
                                        convertedLabEl.innerHTML = `
                                            <div style="margin-bottom: 4px;">
                                                <strong>Main:</strong> ${originalLabText}
                                            </div>
                                            <div>
                                                <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                            </div>
                                            <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                            ${getGamutIndicator(gamutStatus)}
                                        `;
                                    } else {
                                        convertedLabEl.innerHTML = `${convertedLabText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>${getGamutIndicator(gamutStatus)}`;
                                    }
                                });
                        } else {
                            // Not Lab input, show without CMYK but check gamut
                            checkGamut(labData, 'GRACoL2013.icc').then(gamutData => {
                                const inGamut = gamutData && gamutData.inGamut;
                                if (valuesChanged) {
                                    convertedLabEl.innerHTML = `
                                        <div style="margin-bottom: 4px;">
                                            <strong>Main:</strong> ${originalLabText}
                                        </div>
                                        <div>
                                            <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                        </div>
                                        <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                        ${getGamutIndicator(inGamut)}
                                    `;
                                } else {
                                    convertedLabEl.innerHTML = `${convertedLabText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>${getGamutIndicator(inGamut)}`;
                                }
                            }).catch(() => {
                                if (valuesChanged) {
                                    convertedLabEl.innerHTML = `
                                        <div style="margin-bottom: 4px;">
                                            <strong>Main:</strong> ${originalLabText}
                                        </div>
                                        <div>
                                            <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                        </div>
                                        <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                    `;
                                } else {
                                    convertedLabEl.innerHTML = `${convertedLabText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>`;
                                }
                            });
                        }
                    } else {
                        // Fallback: show original values only
                        let originalColorStyle = '';
                        if (showGamutIndicator && gamutStatus !== null) {
                            originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                        }
                       
                        const selectedType = document.getElementById('cmw-search-type-select').value;
                        if (selectedType === 'lab') {
                            // Get CMYK for fallback case too
                            convertColor({
                                lab: [labData.L, labData.a, labData.b],
                                profile: 'GRACoL2013.icc'
                            }).then(cmykData => {
                                let cmykText = '';
                                let fallbackGamutStatus = null;
                                if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                    const cmyk = cmykData.gamut.cmykEquivalent;
                                    cmykText = `<br>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})`;
                                    fallbackGamutStatus = cmykData.gamut.inGamut;
                                }
                                convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${cmykText}${methodText}${getGamutIndicator(fallbackGamutStatus)}`;
                            }).catch(() => {
                                convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(gamutStatus)}`;
                            });
                        } else {
                            convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(gamutStatus)}`;
                        }
                    }
                       
                    }).catch(() => {
                        // Fallback: show original values only
                        let originalColorStyle = '';
                        if (showGamutIndicator && gamutStatus !== null) {
                            originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                        }
                       
                        const selectedType = document.getElementById('cmw-search-type-select').value;
                        if (selectedType === 'lab') {
                            // Get CMYK for error fallback case too
                            convertColor({
                                lab: [labData.L, labData.a, labData.b],
                                profile: 'GRACoL2013.icc'
                            }).then(cmykData => {
                                let cmykText = '';
                                let errorGamutStatus = null;
                                if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                    const cmyk = cmykData.gamut.cmykEquivalent;
                                    cmykText = `<br>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})`;
                                    errorGamutStatus = cmykData.gamut.inGamut;
                                }
                                convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${cmykText}${methodText}${getGamutIndicator(errorGamutStatus)}`;
                            }).catch(() => {
                                convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(gamutStatus)}`;
                            });
                        } else {
                            // For non-lab inputs, check gamut
                            checkGamut(labData, 'GRACoL2013.icc').then(gamutData => {
                                const inGamut = gamutData && gamutData.inGamut;
                                convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(inGamut)}`;
                            }).catch(() => {
                                convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(gamutStatus)}`;
                            });
                        }
                    });
                } else {
                    // No rendering intent, show original values only
                    let originalColorStyle = '';
                    if (showGamutIndicator && gamutStatus !== null) {
                        originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                    }
                   
                    const selectedType = document.getElementById('cmw-search-type-select').value;
                    if (selectedType === 'lab') {
                        // Get CMYK for "none" rendering intent case
                        convertColor({
                            lab: [labData.L, labData.a, labData.b],
                            profile: 'GRACoL2013.icc'
                        }).then(cmykData => {
                            let cmykText = '';
                            let noneGamutStatus = null;
                            if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                const cmyk = cmykData.gamut.cmykEquivalent;
                                cmykText = `<br>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})`;
                                noneGamutStatus = cmykData.gamut.inGamut;
                            }
                            convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${cmykText}${methodText}${getGamutIndicator(noneGamutStatus)}`;
                        }).catch(() => {
                            convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(gamutStatus)}`;
                        });
                    } else {
                        // For non-lab inputs with no rendering intent, check gamut
                        checkGamut(labData, 'GRACoL2013.icc').then(gamutData => {
                            const inGamut = gamutData && gamutData.inGamut;
                            convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(inGamut)}`;
                        }).catch(() => {
                            convertedLabEl.innerHTML = `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>${methodText}${getGamutIndicator(gamutStatus)}`;
                        });
                    }
                }
               
                convertedInfoEl.classList.add('show');
            } else {
                convertedInfoEl.classList.remove('show');
                convertedLabEl.innerHTML = '';
                // Keep CMYK element hidden since we integrate CMYK into Lab display now
                convertedCmykEl.innerHTML = '';
                convertedCmykEl.style.display = 'none';
            }
        }

        function updateGamutWarning(gamutData, profile) {
            // Gamut warnings are disabled - only show visual indicators
            const warningEl = document.getElementById('cmw-gamut-warning');
            warningEl.classList.remove('show');
        }

        /* 11. Color Harmony Functions */
       
        async function updateColorHarmonies(lab) {
            const harmonySection = document.getElementById('cmw-harmonies-section');
            const harmonyToggle = document.getElementById('cmw-harmony-toggle');
           
            if (!harmonyToggle.checked || !lab) {
                harmonySection.style.display = 'none';
                return;
            }
           
            harmonySection.style.display = 'block';
            const loadingEl = document.getElementById('cmw-harmony-loading');
            const colorsEl = document.getElementById('cmw-harmony-colors');
            const statusEl = document.getElementById('cmw-harmony-status');
           
            try {
                loadingEl.classList.add('show');
                colorsEl.innerHTML = '';
                statusEl.classList.remove('show');
               
                const harmonyType = document.getElementById('cmw-harmony-type').value;
               
                // Always use local calculation for now to ensure proper original color handling
                console.log('Calculating harmonies for Lab:', lab, 'Type:', harmonyType);
                const data = calculateLocalHarmoniesWithLibraryMatching(lab, harmonyType);
                displayHarmonyColors(data.colors);
               
                // Show success status
                const totalMatches = data.colors.reduce((sum, color) => {
                    if (color.libraryMatches) {
                        return sum + Object.values(color.libraryMatches).reduce((libSum, matches) => libSum + matches.length, 0);
                    }
                    return sum;
                }, 0);
               
                if (totalMatches > 0) {
                    statusEl.textContent = `Generated ${data.colors.length} ${harmonyType} harmony colors with library matches`;
                    statusEl.className = 'cmw-status success show';
                } else {
                    statusEl.textContent = `Generated ${data.colors.length} ${harmonyType} harmony colors`;
                    statusEl.className = 'cmw-status warning show';
                }
               
            } catch (error) {
                console.error('Harmony calculation failed:', error);
                statusEl.textContent = 'Failed to calculate color harmonies';
                statusEl.className = 'cmw-status error show';
            } finally {
                loadingEl.classList.remove('show');
            }
        }

        function displayHarmonyColors(colors) {
            const colorsEl = document.getElementById('cmw-harmony-colors');
            colorsEl.innerHTML = '';
           
            colors.forEach((colorData, index) => {
                const colorEl = document.createElement('div');
                colorEl.className = 'cmw-harmony-color';
               
                const swatchEl = document.createElement('div');
                const labValues = Array.isArray(colorData.lab) ? colorData.lab : [colorData.lab.L, colorData.lab.a, colorData.lab.b];
                swatchEl.className = `cmw-harmony-swatch ${colorData.gamut?.inGamut ? 'in-gamut' : ''}`;
                swatchEl.style.backgroundColor = lab2rgb(labValues[0], labValues[1], labValues[2]);
                swatchEl.style.cursor = 'pointer';
                // Store Lab values for click handler
                swatchEl.dataset.labL = labValues[0];
                swatchEl.dataset.labA = labValues[1];
                swatchEl.dataset.labB = labValues[2];
               
                const infoEl = document.createElement('div');
                infoEl.className = 'cmw-harmony-info';
               
                // Get best library match from your actual libraries
                let bestMatch = null;
                let bestDelta = Infinity;
               
                if (colorData.libraryMatches) {
                    // Check all library groups for the best match
                    Object.values(colorData.libraryMatches).forEach(matches => {
                        if (Array.isArray(matches) && matches.length > 0) {
                            const topMatch = matches[0];
                            if (topMatch.deltaE < bestDelta) {
                                bestMatch = topMatch;
                                bestDelta = topMatch.deltaE;
                            }
                        }
                    });
                }
               
                // Fallback: if no API matches, search locally
                if (!bestMatch) {
                    const localMatches = findClosestInAllLibraries(
                        { L: labValues[0], a: labValues[1], b: labValues[2] },
                        1
                    );
                    if (localMatches.length > 0) {
                        bestMatch = localMatches[0];
                        bestDelta = localMatches[0].deltaE;
                    }
                }
               
                // Determine the type label
                let typeLabel;
                if (colorData.isOriginal || index === 0) {
                    typeLabel = 'Main';
                } else {
                    typeLabel = `Harmony ${index}`;
                }
               
                // Extract color name and library properly
                let colorName = 'No close match';
                let libraryName = '';
               
                if (bestMatch) {
                    // Handle both API format and local format
                    if (bestMatch.name) {
                        colorName = bestMatch.name;
                    } else if (bestMatch.colorData && bestMatch.colorData.name) {
                        colorName = bestMatch.colorData.name;
                    }
                   
                    if (bestMatch.library) {
                        libraryName = bestMatch.library;
                    } else if (bestMatch.colorData && bestMatch.colorData.libraryName) {
                        libraryName = bestMatch.colorData.libraryName;
                    }
                }
                
                // Store color name and library for click handler
                swatchEl.dataset.colorName = colorName !== 'No close match' ? colorName : typeLabel;
                swatchEl.dataset.libraryName = libraryName;
               
                // Get CMYK (GRACoL2013.icc) and Hex (sRGB.icc) conversion from LittleCMS for harmony color
                Promise.all([
                    convertColor({
                        lab: [labValues[0], labValues[1], labValues[2]],
                        profile: 'GRACoL2013.icc'
                    }),
                    convertColor({
                        lab: [labValues[0], labValues[1], labValues[2]],
                        profile: 'sRGB.icc'
                    })
                ]).then(([cmykData, srgbData]) => {
                    let cmykText = 'CMYK: --';
                    if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                        const cmyk = cmykData.gamut.cmykEquivalent;
                        cmykText = `CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})`;
                    }
                   
                    // Get hex from sRGB.icc conversion for accurate RGB/Hex display
                    if (!srgbData.hex) {
                        throw new Error('LittleCMS did not return hex value');
                    }
                    let hexValue = srgbData.hex;
                    if (!hexValue.startsWith('#')) {
                        hexValue = '#' + hexValue;
                    }
                    hexValue = hexValue.toUpperCase();
                    
                    // Store the LittleCMS hex value for the popup to use
                    swatchEl.dataset.lcmsHex = hexValue;
                   
                    infoEl.innerHTML = `
                        <div class="cmw-harmony-type">${typeLabel}</div>
                        <div class="cmw-harmony-match">${colorName}</div>
                        <div class="cmw-harmony-brand">${libraryName}</div>
                        <div class="cmw-harmony-cmyk">${cmykText}</div>
                        <div class="cmw-harmony-hex">${hexValue}</div>
                        <div class="cmw-harmony-lab">Lab(${labValues.map(v => v.toFixed(2)).join(', ')})</div>
                    `;
                }).catch((error) => {
                    console.error('LittleCMS API unavailable for harmony colors:', error);
                    // Show error state - no fallback to local JS conversion
                    infoEl.innerHTML = `
                        <div class="cmw-harmony-type">${typeLabel}</div>
                        <div class="cmw-harmony-match">${colorName}</div>
                        <div class="cmw-harmony-brand">${libraryName}</div>
                        <div class="cmw-harmony-cmyk">API Error</div>
                        <div class="cmw-harmony-hex">API Error</div>
                        <div class="cmw-harmony-lab">Lab(${labValues.map(v => v.toFixed(2)).join(', ')})</div>
                    `;
                });
               
                colorEl.appendChild(swatchEl);
                colorEl.appendChild(infoEl);
                colorsEl.appendChild(colorEl);
            });
        }

        function calculateLocalHarmonies(lab, harmonyType) {
            // Fallback local harmony calculation
            const harmonies = [];
            const baseHue = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
           
            let hueOffsets = [];
            switch (harmonyType) {
                case 'complementary':
                    hueOffsets = [0, 180];
                    break;
                case 'triadic':
                    hueOffsets = [0, 120, 240];
                    break;
                case 'tetradic':
                    hueOffsets = [0, 90, 180, 270];
                    break;
                case 'analogous':
                    hueOffsets = [0, 30, -30];
                    break;
                case 'splitComplementary':
                    hueOffsets = [0, 150, 210];
                    break;
                case 'monochromatic':
                    hueOffsets = [0, 0, 0, 0, 0];
                    break;
                default:
                    hueOffsets = [0, 180];
            }
           
            hueOffsets.forEach((offset, index) => {
                let newLab;
                if (harmonyType === 'monochromatic') {
                    const lightnessMod = (index - 2) * 15; // Vary lightness
                    newLab = {
                        L: Math.max(0, Math.min(100, lab.L + lightnessMod)),
                        a: lab.a,
                        b: lab.b
                    };
                } else {
                    const newHue = (baseHue + offset) * Math.PI / 180;
                    const chroma = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
                    newLab = {
                        L: lab.L,
                        a: chroma * Math.cos(newHue),
                        b: chroma * Math.sin(newHue)
                    };
                }
               
                harmonies.push({
                    lab: [newLab.L, newLab.a, newLab.b],
                    gamut: { inGamut: true }, // Assume in gamut for fallback
                    libraryMatches: {}
                });
            });
           
            return harmonies;
        }

        /* 12. Rendering Intent Functions */
       
        // Store current color data for rendering intent calculations
        let currentColorData = null;
        let currentRenderingIntentData = null;
        let currentOriginalInputData = null; // Track original input for rendering intents

        // Function to apply rendering intent to any Lab values
        async function applyRenderingIntentToLab(lab, originalData = null) {
            const currentIntent = document.getElementById('cmw-default-intent').value;
           
            // If it's None, return original values
            if (currentIntent === 'none') {
                return {
                    lab: lab,
                    intent: 'None',
                    converted: false
                };
            }
           
            // If it's Relative Colorimetric (default), no conversion needed
            if (currentIntent === '1') {
                return {
                    lab: lab,
                    intent: 'Relative Colorimetric',
                    converted: false
                };
            }
           
            try {
                // Get rendering intent data for this color
                const data = await compareRenderingIntents(lab, originalData);
                const intentMap = {
                    '0': 'perceptual',
                    '1': 'relative',
                    '2': 'saturation',
                    '3': 'absolute'
                };
               
                const intentNames = {
                    'none': 'None',
                    '0': 'Perceptual',
                    '1': 'Relative Colorimetric',
                    '2': 'Saturation',
                    '3': 'Absolute Colorimetric'
                };
               
                const selectedIntentName = intentMap[currentIntent];
                if (data.renderingIntents[selectedIntentName] && data.renderingIntents[selectedIntentName].lab) {
                    return {
                        lab: {
                            L: data.renderingIntents[selectedIntentName].lab[0],
                            a: data.renderingIntents[selectedIntentName].lab[1],
                            b: data.renderingIntents[selectedIntentName].lab[2]
                        },
                        intent: intentNames[currentIntent],
                        converted: true,
                        gamut: data.renderingIntents[selectedIntentName].gamut
                    };
                }
            } catch (error) {
                console.warn('Failed to apply rendering intent:', error);
            }
           
            // Fallback to original values
            const intentNames = {
                'none': 'None',
                '0': 'Perceptual',
                '1': 'Relative Colorimetric',
                '2': 'Saturation',
                '3': 'Absolute Colorimetric'
            };
           
            return {
                lab: lab,
                intent: intentNames[currentIntent],
                converted: false
            };
        }

        async function updateRenderingIntents(lab, originalData = null) {
            const intentsSection = document.getElementById('cmw-intents-section');
            const intentsToggle = document.getElementById('cmw-intents-toggle');
            const loadingEl = document.getElementById('cmw-intents-loading');
            const statusEl = document.getElementById('cmw-intents-status');
            const currentIntent = document.getElementById('cmw-default-intent').value;
           
            if (!intentsToggle.checked || !lab || currentIntent === 'none') {
                intentsSection.style.display = 'none';
                resetIntentCards();
                currentRenderingIntentData = null;
                return;
            }
           
            intentsSection.style.display = 'block';
           
            try {
                loadingEl.classList.add('show');
                statusEl.classList.remove('show');
                resetIntentCards();
               
                console.log('=== Rendering Intent Comparison ===');
                console.log('Lab values:', lab);
                console.log('Original data:', originalData);
                console.log('API Base URL:', getApiBaseUrl());
               
                // Try API first with comprehensive error handling
                let renderingData = null;
                let apiError = null;
               
                try {
                    const data = await compareRenderingIntents(lab, originalData);
                    if (data && data.renderingIntents) {
                        renderingData = data.renderingIntents;
                        console.log('✓ API rendering intent data received:', renderingData);
                    } else {
                        console.warn('⚠ API returned unexpected format:', data);
                        throw new Error('Invalid API response format');
                    }
                } catch (error) {
                    apiError = error;
                    console.warn('✗ API rendering intent comparison failed:', error.message);
                }
               
                if (renderingData) {
                    // Success: Use API data
                    currentRenderingIntentData = renderingData;
                    displayRenderingIntents(renderingData);
                   
                    // Show success message with input type info
                    let inputTypeMsg = '';
                    if (originalData && originalData.type === 'library') {
                        inputTypeMsg = ' (Library color)';
                    } else if (originalData && originalData.type === 'cmyk') {
                        inputTypeMsg = ' (CMYK input)';
                    } else if (originalData && originalData.type === 'rgb') {
                        inputTypeMsg = ' (RGB input)';
                    } else if (originalData && originalData.type === 'hex') {
                        inputTypeMsg = ' (Hex input)';
                    } else {
                        inputTypeMsg = ' (Lab input)';
                    }
                   
                    statusEl.textContent = `Rendering intent comparison complete${inputTypeMsg}`;
                    statusEl.className = 'cmw-status success show';
                   
                    console.log('✓ Successfully displayed API rendering intents');
                   
                } else {
                    // Fallback: Generate demo data
                    console.log('→ Using fallback rendering intent display');
                    displayFallbackRenderingIntents(lab);
                    currentRenderingIntentData = null;
                   
                    // More concise error message
                    let errorMsg = 'Using fallback comparison';
                    if (apiError && apiError.message.includes('Failed to fetch')) {
                        errorMsg += ' (API server not reachable)';
                    }
                   
                    statusEl.textContent = errorMsg;
                    statusEl.className = 'cmw-status warning show';
                }
               
            } catch (error) {
                console.error('Critical error in rendering intent section:', error);
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.className = 'cmw-status error show';
               
                // Still try to show fallback
                displayFallbackRenderingIntents(lab);
               
            } finally {
                loadingEl.classList.remove('show');
            }
        }

        // Helper function to update preview with current data
        function updateColorPreviewWithCurrentData() {
            const selectedType = document.getElementById('cmw-search-type-select').value;
           
            // Only update for non-name searches where we have converted color info
            if (selectedType !== 'name' && currentAnalysisData) {
                const gamutToggle = document.getElementById('cmw-gamut-toggle');
                const showGamut = gamutToggle && gamutToggle.checked;
               
                if (showGamut || currentRenderingIntentData) {
                    // Update the converted color info with rendering intent data
                    updateConvertedColorInfo(
                        currentAnalysisData,
                        'direct',
                        'GRACoL2013.icc',
                        null,
                        currentRenderingIntentData
                    );
                }
            }
        }

        function resetIntentCards() {
            ['perceptual', 'relative', 'saturation', 'absolute'].forEach(intent => {
                const card = document.getElementById(`cmw-intent-${intent}`);
                if (card) {
                    card.classList.remove('current');
                    const swatch = card.querySelector('.cmw-intent-swatch');
                    const delta = card.querySelector('.cmw-intent-delta');
                    const labEl = card.querySelector('.cmw-intent-lab');
                   
                    swatch.style.backgroundColor = '#f8fafc';
                    swatch.classList.remove('in-gamut');
                    swatch.classList.add('no-gamut-indicator'); // Hide indicator when reset
                    delta.textContent = 'ΔE: --';
                    labEl.textContent = 'Lab: --';
                }
            });
        }

        function displayRenderingIntents(intents) {
            const currentIntent = document.getElementById('cmw-default-intent').value;
            const intentMap = {
                'none': 'none',
                '0': 'perceptual',
                '1': 'relative',
                '2': 'saturation',
                '3': 'absolute'
            };
           
            // Don't display anything if "none" is selected
            if (currentIntent === 'none') {
                return;
            }
            
            // Check if gamut indicator is enabled
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            const showGamutIndicator = gamutToggle && gamutToggle.checked;
           
            console.log('Displaying rendering intents:', intents);
            console.log('Current intent setting:', currentIntent, 'maps to:', intentMap[currentIntent]);
            console.log('Gamut indicator enabled:', showGamutIndicator);
           
            Object.entries(intents).forEach(([intentName, data]) => {
                const card = document.getElementById(`cmw-intent-${intentName}`);
                if (!card) {
                    console.warn(`Card not found for intent: cmw-intent-${intentName}`);
                    return;
                }
               
                if (data.error) {
                    console.warn(`Error in intent data for ${intentName}:`, data.error);
                    return;
                }
               
                const swatch = card.querySelector('.cmw-intent-swatch');
                const delta = card.querySelector('.cmw-intent-delta');
                const labEl = card.querySelector('.cmw-intent-lab');
               
                // Highlight current intent
                if (intentMap[currentIntent] === intentName) {
                    card.classList.add('current');
                    console.log(`Highlighted ${intentName} as current intent`);
                } else {
                    card.classList.remove('current');
                }
               
                // Set swatch color using LittleCMS for consistency with popup
                if (data.lab && data.lab.length >= 3) {
                    // Show immediate preview with local conversion
                    swatch.style.backgroundColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                   
                    // Then update with LittleCMS conversion for accuracy (Lab → RGB uses sRGB)
                    convertColor({
                        lab: [data.lab[0], data.lab[1], data.lab[2]],
                        profile: 'sRGB.icc'
                    }).then(lcmsData => {
                        if (lcmsData.hex) {
                            let hexColor = lcmsData.hex;
                            if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                            swatch.style.backgroundColor = hexColor;
                            // Store for popup consistency
                            swatch.dataset.lcmsHex = hexColor.toUpperCase();
                        }
                    }).catch(() => {
                        // Keep local conversion on error
                    });
                   
                    // Only show gamut indicator if gamut toggle is on
                    if (showGamutIndicator) {
                        // Remove the hide class first
                        swatch.classList.remove('no-gamut-indicator');
                        if (data.gamut && data.gamut.inGamut) {
                            swatch.classList.add('in-gamut');
                        } else {
                            swatch.classList.remove('in-gamut');
                            // Out of gamut - the default ::after shows the warning
                        }
                    } else {
                        // Hide gamut indicator when toggle is off
                        swatch.classList.remove('in-gamut');
                        swatch.classList.add('no-gamut-indicator');
                    }
                   
                    delta.textContent = `ΔE: ${(data.deltaE || 0).toFixed(2)}`;
                    labEl.textContent = `Lab(${data.lab.map(v => v.toFixed(2)).join(', ')})`;
                } else {
                    console.warn(`Invalid lab data for ${intentName}:`, data);
                    swatch.style.backgroundColor = '#f8fafc';
                    swatch.classList.remove('in-gamut');
                    delta.textContent = 'ΔE: --';
                    labEl.textContent = 'Lab: --';
                }
            });
        }

        function displayFallbackRenderingIntents(lab) {
            // No fallback - LittleCMS API is required for rendering intent calculations
            // Show error state for all intent cards
            console.error('LittleCMS API unavailable - cannot display rendering intents');
            
            ['perceptual', 'relative', 'saturation', 'absolute'].forEach(intentName => {
                const card = document.getElementById(`cmw-intent-${intentName}`);
                if (!card) return;
               
                const swatch = card.querySelector('.cmw-intent-swatch');
                const delta = card.querySelector('.cmw-intent-delta');
                const labEl = card.querySelector('.cmw-intent-lab');
               
                card.classList.remove('current');
                swatch.style.backgroundColor = '#f0f0f0';
                swatch.classList.remove('in-gamut');
                delta.textContent = 'API Error';
                labEl.textContent = 'LittleCMS unavailable';
            });
        }

        /* 13. Search and Results Functions */
       
        function searchByNameComplete(query) {
            const q = query.trim().toLowerCase();
            if (!q) return [];
           
            const results = [];
           
            let targetLibrary = null;
            let searchTerm = q;
           
            const brandPrefixes = {
                'behr': ['behr'],
                'sherwin': ['sherwin', 'sw', 'sherwin williams'],
                'bm': ['bm', 'benjamin', 'benjamin moore'],
                'pantone': ['pantone']
            };
           
            for (const [libId, prefixes] of Object.entries(brandPrefixes)) {
                for (const prefix of prefixes) {
                    if (q.startsWith(prefix + ' ') || q.startsWith(prefix + '-') || q.startsWith(prefix + '#')) {
                        targetLibrary = libId;
                        searchTerm = q.substring(prefix.length).replace(/^[\s\-#]+/, '').trim();
                        break;
                    }
                }
                if (targetLibrary) break;
            }
           
            const libsToSearch = targetLibrary ? [targetLibrary] : Object.keys(libs);
            const activeLibs = getActiveLibraries();
           
            for (const libId of libsToSearch) {
                const lib = libs[libId];
                for (const color of lib || []) {
                    const colorName = color.name.toLowerCase();
                    const matchAgainst = targetLibrary ? searchTerm : q;
                   
                    let matchType = null;
                    if (colorName === matchAgainst ||
                        (targetLibrary && colorName.includes(matchAgainst)) ||
                        (!targetLibrary && colorName === q)) {
                        matchType = 'exact';
                    } else if (colorName.includes(matchAgainst)) {
                        matchType = 'partial';
                    }
                   
                    if (matchType) {
                        results.push({
                            color,
                            matchType,
                            isFromActiveLibrary: activeLibs.includes(libId),
                            isTargetLibrary: !!targetLibrary
                        });
                    }
                }
            }
           
            results.sort((a, b) => {
                if (a.isTargetLibrary && !b.isTargetLibrary) return -1;
                if (!a.isTargetLibrary && b.isTargetLibrary) return 1;
                if (a.isFromActiveLibrary && !b.isFromActiveLibrary) return -1;
                if (!a.isFromActiveLibrary && b.isFromActiveLibrary) return 1;
                if (a.matchType === 'exact' && b.matchType === 'partial') return -1;
                if (a.matchType === 'partial' && b.matchType === 'exact') return 1;
                return 0;
            });
           
            return results;
        }

        function displayResults(matches, profile = null) {
            const table = document.getElementById('cmw-out');
            const tbody = table.querySelector('tbody');
            const thead = table.querySelector('thead tr');
           
            tbody.innerHTML = '';
           
            // Check if Amazon link filter is enabled
            const amazonFilter = document.getElementById('cmw-filter-amazon');
            const filterControls = document.getElementById('cmw-filter-controls');
            const filterCount = document.getElementById('cmw-filter-count');
            
            // Count colors with Amazon links (check multiple possible field names)
            const colorsWithAmazon = matches.filter(m => m.c && (m.c.amazon_link || m.c.amazonLink)).length;
            
            console.log('🔍 Amazon Filter Check:', {
                totalMatches: matches.length,
                colorsWithAmazon: colorsWithAmazon,
                sampleColor: matches[0]?.c
            });
            
            // Show/hide filter controls based on whether any colors have Amazon links
            if (colorsWithAmazon > 0) {
                filterControls.style.display = 'block';
                filterCount.textContent = `${colorsWithAmazon} available`;
                console.log('✅ Amazon filter shown:', colorsWithAmazon, 'colors with links');
            } else {
                filterControls.style.display = 'none';
                console.log('⚠️ No colors with Amazon links found in results');
            }
            
            // Apply Amazon link filter if enabled
            let filteredMatches = matches;
            if (amazonFilter && amazonFilter.checked) {
                filteredMatches = matches.filter(m => m.c && (m.c.amazon_link || m.c.amazonLink));
                console.log('🎯 Filter applied:', filteredMatches.length, 'colors with Amazon links shown');
            }
           
            // Check if gamut checking is enabled
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            const showGamut = gamutToggle && gamutToggle.checked;
           
            // Update table header - always show Lab column, gamut info will be in the color
            thead.innerHTML = `
                <th>Swatch</th>
                <th>Name</th>
                <th>Library</th>
                <th>ΔE</th>
                <th>Lab</th>
            `;
           
            // Determine which profile to use for gamut checking
            let gamutProfile = 'GRACoL2013.icc';
            if (showGamut) {
                const searchType = document.getElementById('cmw-search-type-select').value;
                if (searchType === 'cmyk' && profile && profile.includes('SWOP')) {
                    gamutProfile = profile;
                }
            }
           
            // Process matches asynchronously for gamut checking
            const processMatches = async () => {
                for (const { c, d } of filteredMatches) {
                    const col = lab2rgb(c.L, c.a, c.b);
                   
                    let labDisplay = `${c.L.toFixed(2)}, ${c.a.toFixed(2)}, ${c.b.toFixed(2)}`;
                   
                    if (showGamut) {
                        try {
                            const gamutData = await checkGamut({ L: c.L, a: c.a, b: c.b }, gamutProfile);
                            if (gamutData) {
                                const labColor = gamutData.inGamut ? '#10b981' : '#ef4444'; // green if in gamut, red if out
                                labDisplay = `<span style="color: ${labColor};">${labDisplay}</span>`;
                            }
                        } catch (error) {
                            console.error('Gamut check failed for', c.name, ':', error);
                        }
                    }
                   
                    // Shorten "Pantone" to "PMS" in display
                    const displayName = c.name.replace(/^Pantone\s*/i, 'PMS ');
                    const displayLibrary = (c.libraryName || 'Unknown').replace(/^Pantone$/i, 'PMS');
                    
                    // Add Amazon link indicator if present (check both field names)
                    const hasAmazonLink = c.amazon_link || c.amazonLink;
                    const amazonIndicator = hasAmazonLink ? ' <img src="https://www.amazon.com/favicon.ico" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 4px;" title="Available on Amazon">' : '';
                    
                    // Store all color data in row dataset for click handler
                    const rowHTML = `
                        <tr style="cursor: pointer;" 
                            title="${hasAmazonLink ? 'Click for details and purchase link' : 'Click for details'}"
                            data-color-name="${c.name.replace(/"/g, '&quot;')}"
                            data-color-l="${c.L}"
                            data-color-a="${c.a}"
                            data-color-b="${c.b}"
                            data-library-name="${(c.libraryName || '').replace(/"/g, '&quot;')}"
                            data-amazon-link="${(c.amazon_link || c.amazonLink || '').replace(/"/g, '&quot;')}"
                            data-manufacturer-link="${(c.manufacturer_link || c.manufacturerLink || '').replace(/"/g, '&quot;')}"
                            data-hex="${(c.hex || '').replace(/"/g, '&quot;')}"
                            data-manufacturer="${(c.manufacturer || '').replace(/"/g, '&quot;')}"
                            data-filament-type="${(c.filament_type || '').replace(/"/g, '&quot;')}">
                            <td><div class="cmw-swatch" style="background:${col}"></div></td>
                            <td>${displayName}${amazonIndicator}</td>
                            <td>${displayLibrary}</td>
                            <td>${d.toFixed(2)}</td>
                            <td>${labDisplay}</td>
                        </tr>
                    `;
                   
                    tbody.insertAdjacentHTML('beforeend', rowHTML);
                }
            };
           
            processMatches();
            table.hidden = false;
        }

        /* 14. Main Search Function */
       
        async function performUnifiedSearch() {
            if (!libsLoaded) {
                showStatus('Color libraries are still loading. Please wait.', 'error');
                return;
            }
           
            const activeLibs = getActiveLibraries();
            if (activeLibs.length === 0) {
                showStatus('Please select at least one color library for results.', 'error');
                return;
            }
           
            const selectedType = document.getElementById('cmw-search-type-select').value;
            let finalLab = null;
            let searchType = '';
            let selectedColorName = null; // Track selected color name for exclusion from results
           
            showLoading(true);
           
            try {
                if (selectedType === 'name') {
                    const nameInput = document.getElementById('cmw-name-input');
                    const query = nameInput.value.trim();
                    const preview = document.getElementById('cmw-color-preview');
                   
                    if (!query) {
                        throw new Error('Please enter a hex or color name.');
                    }
                   
                    // Check if there's already a selected library color with stored Lab values
                    // Use those directly instead of re-searching
                    if (preview.dataset.selectedL && preview.dataset.selectedA && preview.dataset.selectedB && preview.dataset.selectedName) {
                        const L = parseFloat(preview.dataset.selectedL);
                        const a = parseFloat(preview.dataset.selectedA);
                        const b = parseFloat(preview.dataset.selectedB);
                        const displayName = preview.dataset.selectedName;
                        const libraryName = preview.dataset.selectedLibrary || '';
                        
                        finalLab = { L, a, b };
                        searchType = displayName;
                        selectedColorName = displayName;
                        
                        // Store original library color data for rendering intent comparison
                        currentOriginalInputData = {
                            type: 'library',
                            colorName: displayName,
                            libraryName: libraryName
                        };
                        
                        document.getElementById('cmw-name-suggestions').classList.remove('show');
                        
                        console.log('Using stored library Lab values:', L, a, b);
                    } else if (isValidHex(query)) {
                        const rgb = hex2rgb(query);
                        const data = await convertColor({
                            rgb: [rgb.r, rgb.g, rgb.b],
                            profile: 'sRGB.icc'
                        });
                        finalLab = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                        searchType = `hex ${query}`;
                        document.getElementById('cmw-name-suggestions').classList.remove('show');
                        // Don't reset selected color info for hex searches - preserve intent swatch
                       
                        // Clear original input data for hex search
                        currentOriginalInputData = null;
                    } else {
                        // Handle name search with suggestions
                        const nameResults = searchByNameComplete(query);
                       
                        if (nameResults.length === 0) {
                            throw new Error(`No colors found matching "${query}" in any library. Try a different search term or hex value.`);
                        }
                       
                        const exactMatch = nameResults.find(r => r.matchType === 'exact');
                        if (exactMatch) {
                            // Shorten "Pantone" to "PMS" for display
                            const displayName = exactMatch.color.name.replace(/^Pantone\s*/i, 'PMS ');
                            finalLab = { L: exactMatch.color.L, a: exactMatch.color.a, b: exactMatch.color.b };
                            searchType = displayName;
                           
                            // Store the selected color name for exclusion from results
                            selectedColorName = exactMatch.color.name;
                           
                            // Store original library color data for rendering intent comparison (Lab-based but with context)
                            currentOriginalInputData = {
                                type: 'library',
                                colorName: displayName,
                                libraryName: exactMatch.color.libraryName
                            };
                           
                            // Update preview for exact match
                            const exactColor = lab2rgb(exactMatch.color.L, exactMatch.color.a, exactMatch.color.b);
                            preview.style.backgroundColor = exactColor;
                            preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                            preview.classList.add('valid', 'selected');
                           
                            preview.dataset.selectedL = exactMatch.color.L;
                            preview.dataset.selectedA = exactMatch.color.a;
                            preview.dataset.selectedB = exactMatch.color.b;
                            preview.dataset.selectedColor = exactColor;
                            preview.dataset.selectedName = displayName;
                            preview.dataset.selectedLibrary = exactMatch.color.libraryName;
                            preview.dataset.amazonLink = exactMatch.color.amazon_link || exactMatch.color.amazonLink || '';
                            preview.dataset.manufacturerLink = exactMatch.color.manufacturer_link || exactMatch.color.manufacturerLink || '';
                           
                            updateSelectedColorInfo({
                                name: displayName,
                                libraryName: exactMatch.color.libraryName,
                                L: exactMatch.color.L,
                                a: exactMatch.color.a,
                                b: exactMatch.color.b
                            });
                           
                            // Update converted color info with library's known Lab values
                            const gamutToggle = document.getElementById('cmw-gamut-toggle');
                            const showGamut = gamutToggle && gamutToggle.checked;
                            const libLab = { L: exactMatch.color.L, a: exactMatch.color.a, b: exactMatch.color.b };
                            if (showGamut) {
                                checkGamut(libLab, 'GRACoL2013.icc')
                                    .then(gamutData => {
                                        updateConvertedColorInfo(
                                            libLab,
                                            'library',
                                            `${exactMatch.color.libraryName} Library`,
                                            gamutData ? gamutData.inGamut : null
                                        );
                                    })
                                    .catch(() => {
                                        updateConvertedColorInfo(libLab, 'library', `${exactMatch.color.libraryName} Library`);
                                    });
                            } else {
                                updateConvertedColorInfo(libLab, 'library', `${exactMatch.color.libraryName} Library`);
                            }
                           
                            document.getElementById('cmw-name-suggestions').classList.remove('show');
                        } else {
                            showSuggestions(query);
                            showStatus(`Found ${nameResults.length} partial matches. Click a suggestion to find closest colors.`, 'success', true);
                            showLoading(false);
                            return;
                        }
                    }
                   
                } else if (selectedType === 'lab') {
                    const L = parseFloat(document.getElementById('cmw-lab-l').value);
                    const a = parseFloat(document.getElementById('cmw-lab-a').value);
                    const b = parseFloat(document.getElementById('cmw-lab-b').value);
                   
                    if (isNaN(L) || isNaN(a) || isNaN(b)) {
                        throw new Error('Please enter all Lab values (L*, a*, b*).');
                    }
                   
                    if (L < 0 || L > 100) {
                        throw new Error('L* value must be between 0 and 100.');
                    }
                    if (a < -128 || a > 127 || b < -128 || b > 127) {
                        throw new Error('a* and b* values must be between -128 and 127.');
                    }
                   
                    finalLab = { L, a, b };
                    searchType = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)})`;
                   
                    // Clear original input data for Lab search
                    currentOriginalInputData = null;
                   
                } else if (selectedType === 'cmyk') {
                    const c = parseFloat(document.getElementById('cmw-cmyk-c').value);
                    const m = parseFloat(document.getElementById('cmw-cmyk-m').value);
                    const y = parseFloat(document.getElementById('cmw-cmyk-y').value);
                    const k = parseFloat(document.getElementById('cmw-cmyk-k').value);
                   
                    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
                        throw new Error('Please enter all CMYK values (C, M, Y, K).');
                    }
                   
                    if (c < 0 || c > 100 || m < 0 || m > 100 || y < 0 || y > 100 || k < 0 || k > 100) {
                        throw new Error('CMYK values must be between 0 and 100.');
                    }
                   
                    const profile = document.getElementById('cmw-profile-select').value;
                    const data = await convertColor({
                        cmyk: [c, m, y, k],
                        profile: profile
                    });
                    finalLab = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                    searchType = `CMYK(${c}, ${m}, ${y}, ${k}) via ${profile}`;
                   
                    // Store CMYK info for display purposes only (not used for rendering intent API calls)
                    currentOriginalInputData = {
                        type: 'cmyk',
                        values: [c, m, y, k],
                        profile: profile
                    };
                   
                } else if (selectedType === 'rgb') {
                    const r = parseFloat(document.getElementById('cmw-rgb-r').value);
                    const g = parseFloat(document.getElementById('cmw-rgb-g').value);
                    const b = parseFloat(document.getElementById('cmw-rgb-b').value);
                   
                    if (isNaN(r) || isNaN(g) || isNaN(b)) {
                        throw new Error('Please enter all RGB values (R, G, B).');
                    }
                   
                    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
                        throw new Error('RGB values must be between 0 and 255.');
                    }
                   
                    const data = await convertColor({
                        rgb: [r, g, b],
                        profile: 'sRGB.icc'
                    });
                    finalLab = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                    searchType = `RGB(${r}, ${g}, ${b}) via sRGB.icc`;
                   
                    // Clear original input data for RGB search
                    currentOriginalInputData = null;
                }
               
                if (!finalLab) {
                    throw new Error('Unable to determine color values for search.');
                }
               
                // Store current analysis data for features
                currentAnalysisData = finalLab;
                console.log('Set currentAnalysisData:', currentAnalysisData);
               
                // Update the intent swatch for the search color (maintain rendering intent display)
                updateIntentSwatch(finalLab);
               
                // Perform search
                const resultsCount = getResultsCount();
                console.log('Performing search with resultsCount:', resultsCount, 'selectedColorName:', selectedColorName);
                // Exclude the selected color from results if it was an exact name match
                const matches = nearest(finalLab.L, finalLab.a, finalLab.b, resultsCount, selectedColorName || null);
                console.log('Search matches found:', matches.length, matches);
               
                // Store results globally for 3D visualization
                currentSearchResults = matches;
                console.log('=== Search Results Storage ===');
                console.log('Stored', matches.length, 'results for 3D visualization');
                console.log('Rendering intent enabled:', document.getElementById('cmw-default-intent').value !== 'none');
               
                // Debug: Check for duplicates in stored results
                const resultNames = matches.map(m => m.c.name);
                const uniqueNames = new Set(resultNames);
                if (resultNames.length !== uniqueNames.size) {
                    console.warn('⚠️ Duplicate names detected in search results:');
                    const nameCount = {};
                    resultNames.forEach(name => {
                        nameCount[name] = (nameCount[name] || 0) + 1;
                    });
                    Object.entries(nameCount).forEach(([name, count]) => {
                        if (count > 1) {
                            console.warn(`  - "${name}": ${count} times`);
                        }
                    });
                }
               
                const profile = selectedType === 'cmyk' ? document.getElementById('cmw-profile-select').value : null;
                displayResults(matches, profile);
               
                // Update advanced features if enabled
                const harmonyToggle = document.getElementById('cmw-harmony-toggle');
                if (harmonyToggle.checked) {
                    updateColorHarmonies(finalLab);
                }
               
                // Always try to update rendering intents if enabled - ensure CMYK works like other types
                const intentsToggle = document.getElementById('cmw-intents-toggle');
                if (intentsToggle.checked) {
                    console.log('=== Updating Rendering Intents from Search ===');
                    console.log('Final Lab values:', finalLab);
                   
                    // For CMYK, use null to ensure consistent Lab-based processing like other input types
                    const renderingOriginalData = (selectedType === 'cmyk') ? null : currentOriginalInputData;
                    console.log('Original input data for rendering:', renderingOriginalData);
                    console.log('Calling updateRenderingIntents...');
                    updateRenderingIntents(finalLab, renderingOriginalData);
                }
               
                document.getElementById('cmw-name-suggestions').classList.remove('show');
               
                // For non-name searches, clear library color info but preserve intent swatch
                if (selectedType !== 'name') {
                    const colorInfoEl = document.getElementById('cmw-selected-color-info');
                    colorInfoEl.classList.remove('show');
                   
                    const preview = document.getElementById('cmw-color-preview');
                    preview.classList.remove('selected');
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    // Don't call updateSelectedColorInfo(null) as it would reset the intent swatch
                }
               
                showStatus(`Found ${matches.length} closest colors to ${searchType}`, 'success', true);
               
            } catch (error) {
                showStatus(error.message, 'error');
            } finally {
                showLoading(false);
            }
        }
        /* ─────────────────────
           Section 5 Java Part 3
           ───────────────────── */
        /* 15. Suggestion Functions */
       
        let currentSuggestionQuery = '';
        let currentSuggestionOffset = 0;
        let allMatchedColors = [];
        let isLoadingMoreSuggestions = false;
        let hasMoreSuggestions = true;
        const SUGGESTIONS_BATCH_SIZE = 20;

        function initializeSuggestions(query) {
            currentSuggestionQuery = query;
            currentSuggestionOffset = 0;
            hasMoreSuggestions = true;
            isLoadingMoreSuggestions = false;
           
            allMatchedColors = searchByNameComplete(query);
           
            const suggestionsContent = document.querySelector('.cmw-suggestions-content');
            suggestionsContent.innerHTML = '';
           
            const loadingMore = document.getElementById('cmw-loading-more');
            const noMoreResults = document.getElementById('cmw-no-more-results');
            loadingMore.classList.remove('show');
            noMoreResults.classList.remove('show');
           
            if (allMatchedColors.length === 0) {
                return false;
            }
           
            const firstBatch = allMatchedColors.slice(0, SUGGESTIONS_BATCH_SIZE);
            appendSuggestions(firstBatch);
            currentSuggestionOffset = SUGGESTIONS_BATCH_SIZE;
           
            if (allMatchedColors.length <= SUGGESTIONS_BATCH_SIZE) {
                hasMoreSuggestions = false;
                if (allMatchedColors.length === SUGGESTIONS_BATCH_SIZE) {
                    noMoreResults.classList.add('show');
                }
            }
           
            return true;
        }

        function appendSuggestions(suggestions) {
            const suggestionsContent = document.querySelector('.cmw-suggestions-content');
            const preview = document.getElementById('cmw-color-preview');
           
            suggestions.forEach(s => {
                const suggestionEl = document.createElement('div');
                suggestionEl.className = `cmw-suggestion ${!s.isFromActiveLibrary ? 'cmw-disabled-library' : ''}`;
                suggestionEl.dataset.name = s.color.name;
                suggestionEl.dataset.l = s.color.L;
                suggestionEl.dataset.a = s.color.a;
                suggestionEl.dataset.b = s.color.b;
                suggestionEl.dataset.library = s.color.libraryName;
                suggestionEl.dataset.amazonLink = s.color.amazon_link || s.color.amazonLink || '';
                suggestionEl.dataset.manufacturerLink = s.color.manufacturer_link || s.color.manufacturerLink || '';
                // Shorten "Pantone" to "PMS" in color names for display
                const displayName = s.color.name.replace(/^Pantone\s*/i, 'PMS ');
                const displayLibrary = (s.color.libraryName || 'Unknown').replace(/^Pantone$/i, 'PMS');
                // Get the color for the swatch
                const swatchColor = lab2rgb(s.color.L, s.color.a, s.color.b);
                suggestionEl.innerHTML = `
                    <div class="cmw-suggestion-swatch" style="background-color: ${swatchColor};"></div>
                    <div class="cmw-suggestion-info">
                        <div class="cmw-suggestion-name">${displayName}</div>
                        <div class="cmw-suggestion-library">${displayLibrary}</div>
                    </div>
                `;
               
                if (!('ontouchstart' in window)) {
                    let isHovering = false;
                   
                    suggestionEl.addEventListener('mouseenter', () => {
                        isHovering = true;
                        const L = parseFloat(suggestionEl.dataset.l);
                        const a = parseFloat(suggestionEl.dataset.a);
                        const b = parseFloat(suggestionEl.dataset.b);
                       
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            const color = lab2rgb(L, a, b);
                            preview.style.backgroundColor = color;
                            preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                            preview.classList.add('valid');
                            preview.dataset.isHovering = 'true';
                           
                            updateSelectedColorInfo({
                                name: suggestionEl.dataset.name,
                                libraryName: suggestionEl.dataset.library,
                                L: L,
                                a: a,
                                b: b
                            });
                        }
                    });
                   
                    suggestionEl.addEventListener('mouseleave', () => {
                        isHovering = false;
                        preview.dataset.isHovering = 'false';
                        setTimeout(() => {
                            if (!isHovering && preview.dataset.isHovering === 'false') {
                                updateColorPreview();
                            }
                        }, 50);
                    });
                }
               
                suggestionEl.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                   
                    console.log('Suggestion clicked:', suggestionEl.dataset.name);
                   
                    const nameInput = document.getElementById('cmw-name-input');
                    // Shorten "Pantone" to "PMS" for display
                    const displayName = suggestionEl.dataset.name.replace(/^Pantone\s*/i, 'PMS ');
                    nameInput.value = displayName;
                    document.getElementById('cmw-name-suggestions').classList.remove('show');
                   
                    const L = parseFloat(suggestionEl.dataset.l);
                    const a = parseFloat(suggestionEl.dataset.a);
                    const b = parseFloat(suggestionEl.dataset.b);
                   
                    console.log('Lab values from suggestion:', L, a, b);
                   
                    if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                        const resultsCount = getResultsCount();
                        const clickedColor = lab2rgb(L, a, b);
                        preview.style.backgroundColor = clickedColor;
                        preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                        preview.classList.add('valid', 'selected');
                        preview.dataset.isHovering = 'false';
                       
                        preview.dataset.selectedL = L;
                        preview.dataset.selectedA = a;
                        preview.dataset.selectedB = b;
                        preview.dataset.selectedColor = clickedColor;
                        preview.dataset.selectedName = displayName;
                        preview.dataset.selectedLibrary = suggestionEl.dataset.library;
                        preview.dataset.amazonLink = suggestionEl.dataset.amazonLink || '';
                        preview.dataset.manufacturerLink = suggestionEl.dataset.manufacturerLink || '';
                       
                        console.log('About to call updateSelectedColorInfo');
                        await updateSelectedColorInfo({
                            name: displayName,
                            libraryName: suggestionEl.dataset.library,
                            L: L,
                            a: a,
                            b: b
                        });
                       
                        // Update converted color info with library's known Lab values
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        const showGamut = gamutToggle && gamutToggle.checked;
                        if (showGamut) {
                            checkGamut({ L, a, b }, 'GRACoL2013.icc')
                                .then(gamutData => {
                                    updateConvertedColorInfo(
                                        { L, a, b },
                                        'library',
                                        `${suggestionEl.dataset.library} Library`,
                                        gamutData ? gamutData.inGamut : null
                                    );
                                })
                                .catch(() => {
                                    updateConvertedColorInfo({ L, a, b }, 'library', `${suggestionEl.dataset.library} Library`);
                                });
                        } else {
                            updateConvertedColorInfo({ L, a, b }, 'library', `${suggestionEl.dataset.library} Library`);
                        }
                       
                        // Store for features and pass color name for exclusion
                        currentAnalysisData = { L: L, a: a, b: b };
                       
                        console.log('About to call nearest() for results');
                        const matches = nearest(L, a, b, resultsCount, suggestionEl.dataset.name);
                       
                        // Store results globally for 3D visualization
                        currentSearchResults = matches;
                       
                        const profile = document.getElementById('cmw-search-type-select').value === 'cmyk' ?
                            document.getElementById('cmw-profile-select').value : null;
                        console.log('About to display results:', matches);
                        displayResults(matches, profile);
                       
                        // Update features
                        const harmonyToggle = document.getElementById('cmw-harmony-toggle');
                        if (harmonyToggle.checked) {
                            updateColorHarmonies({ L: L, a: a, b: b });
                        }
                       
                        // Update rendering intents for library color
                        const intentsToggle = document.getElementById('cmw-intents-toggle');
                        if (intentsToggle.checked) {
                            const libraryOriginalData = {
                                type: 'library',
                                colorName: suggestionEl.dataset.name,
                                libraryName: suggestionEl.dataset.library
                            };
                            updateRenderingIntents({ L: L, a: a, b: b }, libraryOriginalData);
                        }
                       
                        showStatus(`Showing closest colors to "${suggestionEl.dataset.name}"`, 'success', true);
                    }
                });
               
                suggestionsContent.appendChild(suggestionEl);
            });
        }

        function showSuggestions(query) {
            const suggestionsEl = document.getElementById('cmw-name-suggestions');
           
            if (!query || query.length < 3) {
                suggestionsEl.classList.remove('show');
                return;
            }
           
            const hasResults = initializeSuggestions(query);
           
            if (hasResults) {
                suggestionsEl.classList.add('show');
            } else {
                suggestionsEl.classList.remove('show');
            }
        }

        function setupInfiniteScroll() {
            const suggestionsEl = document.getElementById('cmw-name-suggestions');
           
            suggestionsEl.addEventListener('scroll', () => {
                const scrollTop = suggestionsEl.scrollTop;
                const scrollHeight = suggestionsEl.scrollHeight;
                const clientHeight = suggestionsEl.clientHeight;
               
                if (scrollTop + clientHeight >= scrollHeight - 50) {
                    loadMoreSuggestions();
                }
            });
        }

        function loadMoreSuggestions() {
            if (isLoadingMoreSuggestions || !hasMoreSuggestions) return;
           
            isLoadingMoreSuggestions = true;
            const loadingMore = document.getElementById('cmw-loading-more');
            const noMoreResults = document.getElementById('cmw-no-more-results');
           
            loadingMore.classList.add('show');
            noMoreResults.classList.remove('show');
           
            setTimeout(() => {
                const startIndex = currentSuggestionOffset;
                const endIndex = Math.min(startIndex + SUGGESTIONS_BATCH_SIZE, allMatchedColors.length);
                const batch = allMatchedColors.slice(startIndex, endIndex);
               
                if (batch.length === 0) {
                    hasMoreSuggestions = false;
                    loadingMore.classList.remove('show');
                    noMoreResults.classList.add('show');
                    isLoadingMoreSuggestions = false;
                    return;
                }
               
                appendSuggestions(batch);
                currentSuggestionOffset = endIndex;
               
                if (endIndex >= allMatchedColors.length) {
                    hasMoreSuggestions = false;
                    noMoreResults.classList.add('show');
                }
               
                loadingMore.classList.remove('show');
                isLoadingMoreSuggestions = false;
            }, 200);
        }

        /* 18. 3D Color Space Widget - REMOVED */
        // See 3D_WIDGET_DOCUMENTATION.md for implementation details
        // Removed on 2025-12-25 - Feature deprecated
       
        /* 19. API Connectivity Check */
       
        // Simple API connectivity check for initialization
        async function checkApiConnectivity() {
            const apiUrl = getApiBaseUrl();
            console.log('Checking API connectivity:', apiUrl);
           
            try {
                // Try a simple endpoint to see if API is responding
                const response = await fetch(`${apiUrl}/convert`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lab: [50, 0, 0], // Test with neutral gray
                        profile: 'GRACoL2013.icc'
                    })
                });
               
                if (response.ok) {
                    console.log('✓ API server responding');
                    showStatus('API server connected - enhanced features available!', 'success');
                    return true;
                } else if (response.status === 400 || response.status === 422) {
                    // Bad request might be expected for test data, but server is responding
                    console.log('✓ API server responding (got expected error for test data)');
                    showStatus('API server connected - enhanced features available!', 'success');
                    return true;
                } else {
                    console.log('⚠ API server returned:', response.status);
                    showStatus(`API server returned ${response.status} - some features may be limited`, 'warning');
                    return false;
                }
            } catch (error) {
                if (error.message.includes('Failed to fetch')) {
                    console.log('✗ API server not reachable');
                    showStatus('API server not reachable - using basic color matching only', 'warning');
                } else {
                    console.log('✗ API connectivity error:', error.message);
                    showStatus('API connectivity issue - some features may be limited', 'warning');
                }
                return false;
            }
        }
       
        // Fetch gamut boundary points from the API
        async function fetchGamutBoundary(profile, resolution = 25, currentLab = null) {
            const apiUrl = `${getApiBaseUrl()}/gamut-boundary`;
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        profile: profile,
                        resolution: resolution,
                        currentLab: currentLab
                    })
                });
               
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const data = await response.json();
                return data.boundaryPoints; // [[L,a,b], [L,a,b], ...]
               
            } catch (error) {
                console.warn('Gamut boundary API failed, using mock data:', error);
               
                // Fallback: Generate mock gamut boundary data for testing
                return generateMockGamutBoundary(resolution);
            }
        }

        // Generate mock gamut boundary data for testing when API is unavailable
        function generateMockGamutBoundary(resolution = 25) {
            const points = [];
            const step = 100 / resolution;
           
            // Create a rough cylindrical gamut shape in Lab space
            for (let L = 0; L <= 100; L += step) {
                for (let angle = 0; angle < 360; angle += 15) {
                    const rad = angle * Math.PI / 180;
                   
                    // Vary radius based on lightness to create gamut-like shape
                    let radius;
                    if (L < 20 || L > 90) {
                        radius = 20; // Smaller gamut at extremes
                    } else {
                        radius = 60; // Larger gamut in middle lightness
                    }
                   
                    const a = radius * Math.cos(rad);
                    const b = radius * Math.sin(rad);
                   
                    points.push([L, a, b]);
                }
            }
           
            console.log(`Generated ${points.length} mock gamut boundary points`);
            return points;
        }

        (function init() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
                return;
            }

            const nameInput = document.getElementById('cmw-name-input');
            const searchBtn = document.getElementById('cmw-search-btn');
            const searchTypeSelect = document.getElementById('cmw-search-type-select');
            const labInputs = ['cmw-lab-l', 'cmw-lab-a', 'cmw-lab-b'].map(id => document.getElementById(id));
            const cmykInputs = ['cmw-cmyk-c', 'cmw-cmyk-m', 'cmw-cmyk-y', 'cmw-cmyk-k'].map(id => document.getElementById(id));
            const rgbInputs = ['cmw-rgb-r', 'cmw-rgb-g', 'cmw-rgb-b'].map(id => document.getElementById(id));
            const harmonyTypeSelect = document.getElementById('cmw-harmony-type');
            const harmonyToggle = document.getElementById('cmw-harmony-toggle');

            setupInfiniteScroll();
            
            // Initialize with dynamic library loading
            showLoading(true);
            initializeLibraries()
                .then(() => {
                    showLoading(false);
                    libsLoaded = true;
                    const totalColors = Object.values(libs).reduce((sum, lib) => sum + (lib?.length || 0), 0);
                    showStatus(`Color libraries loaded successfully! ${totalColors} colors available.`);
                    console.log('All library fetches completed');
                   
                    // Update library counts after loading
                    initializeLibraryCounts();
                    
                    // Check API connectivity after libraries are loaded
                    setTimeout(() => {
                        checkApiConnectivity();
                    }, 1000);
                })
                .catch((error) => {
                    showLoading(false);
                    console.error('Library initialization failed:', error);
                    showStatus('Failed to load some color libraries. Functionality may be limited.', 'error');
                    initializeLibraryCounts(); // Still initialize counts even on error
                });
           
            // Initialize collapsible settings
            const settingsToggle = document.getElementById('cmw-settings-toggle');
            const settingsContent = document.getElementById('cmw-settings-content');
           
            settingsToggle.addEventListener('click', () => {
                const isCollapsed = settingsToggle.classList.contains('collapsed');
               
                if (isCollapsed) {
                    // Expand
                    settingsToggle.classList.remove('collapsed');
                    settingsContent.classList.remove('collapsed');
                } else {
                    // Collapse
                    settingsToggle.classList.add('collapsed');
                    settingsContent.classList.add('collapsed');
                }
            });
           
            searchBtn.addEventListener('click', performUnifiedSearch);

            // Amazon link filter event listener
            const amazonFilterCheckbox = document.getElementById('cmw-filter-amazon');
            if (amazonFilterCheckbox) {
                amazonFilterCheckbox.addEventListener('change', () => {
                    // Re-display results with filter applied
                    if (currentSearchResults && currentSearchResults.length > 0) {
                        const searchType = document.getElementById('cmw-search-type-select').value;
                        let profile = null;
                        if (searchType === 'cmyk') {
                            profile = document.getElementById('cmw-cmyk-profile').value;
                        }
                        displayResults(currentSearchResults, profile);
                    }
                });
            }
            
            // Reset Amazon filter when library toggles change
            function resetAmazonFilter() {
                if (amazonFilterCheckbox && amazonFilterCheckbox.checked) {
                    amazonFilterCheckbox.checked = false;
                    console.log('Amazon filter reset due to library toggle change');
                }
            }
            
            // Add listeners to built-in library toggles
            ['pantone', 'behr', 'sherwin', 'bm'].forEach(libId => {
                const checkbox = document.getElementById(`toggle-${libId}`);
                if (checkbox) {
                    checkbox.addEventListener('change', resetAmazonFilter);
                }
            });
            
            // Monitor custom libraries container for dynamically added toggles
            const customLibrariesContainer = document.getElementById('cmw-custom-libraries-container');
            if (customLibrariesContainer) {
                // Use event delegation for custom library toggles (since they're added dynamically)
                customLibrariesContainer.addEventListener('change', (e) => {
                    if (e.target.type === 'checkbox') {
                        resetAmazonFilter();
                    }
                });
            }

            searchTypeSelect.addEventListener('change', (e) => {
                document.getElementById('cmw-name-inputs').classList.remove('active');
                document.getElementById('cmw-lab-inputs').classList.remove('active');
                document.getElementById('cmw-cmyk-inputs').classList.remove('active');
                document.getElementById('cmw-rgb-inputs').classList.remove('active');
               
                const selectedType = e.target.value;
                if (selectedType) {
                    document.getElementById(`cmw-${selectedType}-inputs`).classList.add('active');
                }
               
                // Show/hide profile selector based on selection
                const profileSelector = document.getElementById('cmw-profile-selector');
                if (selectedType === 'cmyk') {
                    profileSelector.style.display = 'block';
                } else {
                    profileSelector.style.display = 'none';
                }
               
                if (selectedType !== 'name') {
                    nameInput.value = '';
                    const preview = document.getElementById('cmw-color-preview');
                    preview.classList.remove('selected');
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    updateSelectedColorInfo(null);
                }
                [...labInputs, ...cmykInputs, ...rgbInputs].forEach(input => {
                    if (input) input.value = '';
                });
               
                if (selectedType !== 'name') {
                    document.getElementById('cmw-name-suggestions').classList.remove('show');
                }
               
                updateConvertedColorInfo(null);
                // Clear CMYK display when switching input types
                const convertedCmykEl = document.getElementById('cmw-converted-cmyk');
                convertedCmykEl.style.display = 'none';
                updateColorPreview();
            });

            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performUnifiedSearch();
            });

            let searchTimeout;
            nameInput.addEventListener('input', (e) => {
                updateColorPreview();
               
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const query = e.target.value.trim();
                    const selectedType = searchTypeSelect.value;
                   
                    if (query.length > 2 && libsLoaded && selectedType === 'name') {
                        showSuggestions(query);
                    } else {
                        document.getElementById('cmw-name-suggestions').classList.remove('show');
                    }
                }, 300);
            });

            [...labInputs, ...cmykInputs, ...rgbInputs].forEach(input => {
                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') performUnifiedSearch();
                    });
                    input.addEventListener('input', updateColorPreview);
                }
            });

            // Harmony controls
            harmonyToggle.addEventListener('change', () => {
                if (harmonyToggle.checked && currentAnalysisData) {
                    updateColorHarmonies(currentAnalysisData);
                } else {
                    document.getElementById('cmw-harmonies-section').style.display = 'none';
                }
            });

            harmonyTypeSelect.addEventListener('change', (e) => {
                currentHarmonyType = e.target.value;
                if (harmonyToggle.checked && currentAnalysisData) {
                    updateColorHarmonies(currentAnalysisData);
                }
            });

            // Rendering intent controls
            const intentsToggle = document.getElementById('cmw-intents-toggle');
           
            intentsToggle.addEventListener('change', () => {
                console.log('=== Rendering Intent Toggle Changed ===');
                console.log('Toggle checked:', intentsToggle.checked);
                console.log('Current analysis data:', currentAnalysisData);
                console.log('API URL:', getApiBaseUrl());
                
                if (intentsToggle.checked) {
                    // Check for current analysis data first
                    if (currentAnalysisData) {
                        console.log('→ Calling updateRenderingIntents with currentAnalysisData...');
                        updateRenderingIntents(currentAnalysisData, currentOriginalInputData);
                    } else {
                        // Check if there's a selected library color
                        const preview = document.getElementById('cmw-color-preview');
                        if (preview.dataset.selectedL && preview.dataset.selectedA && preview.dataset.selectedB) {
                            const labData = {
                                L: parseFloat(preview.dataset.selectedL),
                                a: parseFloat(preview.dataset.selectedA),
                                b: parseFloat(preview.dataset.selectedB)
                            };
                           
                            // Create library color original data
                            const libraryOriginalData = {
                                type: 'library',
                                colorName: preview.dataset.selectedName,
                                libraryName: preview.dataset.selectedLibrary
                            };
                           
                            console.log('→ Calling updateRenderingIntents with selected library color:', labData);
                            updateRenderingIntents(labData, libraryOriginalData);
                        } else {
                            // Check if there's valid currentColorData
                            if (currentColorData && currentColorData.L !== undefined) {
                                console.log('→ Calling updateRenderingIntents with currentColorData:', currentColorData);
                                updateRenderingIntents(currentColorData, currentOriginalInputData);
                            } else {
                                // Show the section but with a message
                                const intentsSection = document.getElementById('cmw-intents-section');
                                const statusEl = document.getElementById('cmw-intents-status');
                                intentsSection.style.display = 'block';
                                statusEl.textContent = 'Enter a color to compare rendering intents';
                                statusEl.className = 'cmw-status warning show';
                                resetIntentCards();
                                console.log('→ No color data available for rendering intent comparison');
                            }
                        }
                    }
                } else {
                    document.getElementById('cmw-intents-section').style.display = 'none';
                    resetIntentCards();
                    console.log('→ Hiding rendering intent section');
                    
                    // Refresh converted color info to remove rendering intent values
                    if (currentColorData) {
                        const selectedType = document.getElementById('cmw-search-type-select').value;
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        let profile = 'GRACoL2013.icc';
                        let method = 'direct';
                        
                        if (selectedType === 'cmyk') {
                            profile = document.getElementById('cmw-profile-select').value;
                            method = 'api';
                        } else if (selectedType === 'rgb' || (selectedType === 'name' && isValidHex(document.getElementById('cmw-name-input').value.trim()))) {
                            method = 'api';
                        }
                        
                        // Update without rendering intent data
                        if (gamutToggle && gamutToggle.checked) {
                            checkGamut(currentColorData, profile).then(gamutData => {
                                updateConvertedColorInfo(currentColorData, method, profile, gamutData ? gamutData.inGamut : null);
                            }).catch(() => {
                                updateConvertedColorInfo(currentColorData, method, profile, null);
                            });
                        } else {
                            updateConvertedColorInfo(currentColorData, method, profile, null);
                        }
                    }
                }
            });

            // Rendering intent change handler
            document.getElementById('cmw-default-intent').addEventListener('change', () => {
                console.log('Rendering intent changed, currentAnalysisData:', currentAnalysisData);
               
                const currentIntent = document.getElementById('cmw-default-intent').value;
               
                // Update rendering intents if section is visible
                if (intentsToggle.checked && currentAnalysisData && currentIntent !== 'none') {
                    updateRenderingIntents(currentAnalysisData, currentOriginalInputData);
                }
               
                // Update ALL color displays when rendering intent changes
                const selectedType = document.getElementById('cmw-search-type-select').value;
                const preview = document.getElementById('cmw-color-preview');
               
                // For library colors (name input with selected color)
                if (preview.dataset.selectedName && preview.dataset.selectedL) {
                    const selectedColorData = {
                        name: preview.dataset.selectedName,
                        libraryName: preview.dataset.selectedLibrary,
                        L: parseFloat(preview.dataset.selectedL),
                        a: parseFloat(preview.dataset.selectedA),
                        b: parseFloat(preview.dataset.selectedB)
                    };
                    updateSelectedColorInfo(selectedColorData);
                }
               
                // For converted color info (Lab, CMYK, RGB, Hex inputs) - update with new rendering intent values
                if (currentColorData) {
                    let profile = 'GRACoL2013.icc';
                    let method = 'direct';
                   
                    if (selectedType === 'cmyk') {
                        profile = document.getElementById('cmw-profile-select').value;
                        method = 'api';
                    } else if (selectedType === 'rgb' || (selectedType === 'name' && isValidHex(document.getElementById('cmw-name-input').value.trim()))) {
                        method = 'api';
                    }
                   
                    updateConvertedColorInfo(currentColorData, method, profile);
                }
               
                // Update intent swatch for ANY valid color currently displayed
                if (currentColorData && currentIntent !== 'none') {
                    updateIntentSwatch(currentColorData);
                }
            });

            // Gamut toggle change handler - refresh converted color info when toggled
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            gamutToggle.addEventListener('change', () => {
                console.log('Gamut toggle changed:', gamutToggle.checked);
                
                // Refresh the converted color info to show/hide gamut indicator
                if (currentColorData) {
                    const selectedType = document.getElementById('cmw-search-type-select').value;
                    let profile = 'GRACoL2013.icc';
                    let method = 'direct';
                    
                    if (selectedType === 'cmyk') {
                        profile = document.getElementById('cmw-profile-select').value;
                        method = 'api';
                    } else if (selectedType === 'rgb' || (selectedType === 'name' && isValidHex(document.getElementById('cmw-name-input').value.trim()))) {
                        method = 'api';
                    }
                    
                    // Re-call updateConvertedColorInfo to refresh the gamut indicator
                    if (gamutToggle.checked) {
                        // When turning ON, fetch gamut status and update
                        checkGamut(currentColorData, profile).then(gamutData => {
                            updateConvertedColorInfo(currentColorData, method, profile, gamutData ? gamutData.inGamut : null);
                        }).catch(() => {
                            updateConvertedColorInfo(currentColorData, method, profile, null);
                        });
                    } else {
                        // When turning OFF, just refresh without gamut status
                        updateConvertedColorInfo(currentColorData, method, profile, null);
                    }
                }
                
                // Also refresh the rendering intent display if it's visible
                // Use currentAnalysisData if available, otherwise currentColorData
                const labDataForIntents = currentAnalysisData || currentColorData;
                if (intentsToggle.checked && labDataForIntents) {
                    updateRenderingIntents(labDataForIntents, currentOriginalInputData);
                }
            });

            /* ─────────────────────
               Color Consensus Feature
               ───────────────────── */
            
            // Consensus sample storage
            const consensusSamples = [];
            let sampleIdCounter = 0;
            
            // Helper: Parse color value from input based on format
            function parseColorInput(format, value) {
                value = value.trim();
                
                if (format === 'hex') {
                    // Handle hex input
                    if (!value.startsWith('#')) value = '#' + value;
                    if (!/^#[0-9A-Fa-f]{6}$/.test(value)) {
                        throw new Error('Invalid hex format. Use #RRGGBB');
                    }
                    return { format: 'hex', value: value };
                }
                
                if (format === 'lab') {
                    // Parse Lab values (comma or space separated)
                    const parts = value.split(/[,\s]+/).map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
                    if (parts.length !== 3) {
                        throw new Error('Lab requires 3 values: L, a, b');
                    }
                    if (parts[0] < 0 || parts[0] > 100) {
                        throw new Error('L must be between 0 and 100');
                    }
                    return { format: 'lab', value: parts };
                }
                
                if (format === 'rgb') {
                    // Parse RGB values
                    const parts = value.split(/[,\s]+/).map(v => parseInt(v.trim())).filter(v => !isNaN(v));
                    if (parts.length !== 3) {
                        throw new Error('RGB requires 3 values: R, G, B');
                    }
                    if (parts.some(v => v < 0 || v > 255)) {
                        throw new Error('RGB values must be between 0 and 255');
                    }
                    return { format: 'rgb', value: parts };
                }
                
                if (format === 'cmyk') {
                    // Parse CMYK values
                    const parts = value.split(/[,\s]+/).map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
                    if (parts.length !== 4) {
                        throw new Error('CMYK requires 4 values: C, M, Y, K');
                    }
                    if (parts.some(v => v < 0 || v > 100)) {
                        throw new Error('CMYK values must be between 0 and 100');
                    }
                    return { format: 'cmyk', value: parts, profile: 'GRACoL2013.icc' };
                }
                
                throw new Error('Unknown format');
            }
            
            // Helper: Get preview hex for a sample
            function getSamplePreviewHex(sample) {
                try {
                    if (sample.format === 'hex') {
                        return sample.value;
                    }
                    if (sample.format === 'lab') {
                        return lab2rgb(sample.value[0], sample.value[1], sample.value[2]);
                    }
                    if (sample.format === 'rgb') {
                        const [r, g, b] = sample.value;
                        return `rgb(${r}, ${g}, ${b})`;
                    }
                    if (sample.format === 'cmyk') {
                        // Use pre-computed preview color from LittleCMS if available
                        if (sample.previewColor) {
                            return sample.previewColor;
                        }
                        // Fallback: use lab2rgb if normalizedLab is available (from API response)
                        if (sample.normalizedLab) {
                            return lab2rgb(sample.normalizedLab[0], sample.normalizedLab[1], sample.normalizedLab[2]);
                        }
                        // Last resort fallback (should not happen if API works)
                        console.warn('CMYK preview using fallback - LittleCMS should be used');
                        const [c, m, y, k] = sample.value.map(v => v / 100);
                        const r = Math.round(255 * (1 - c) * (1 - k));
                        const g = Math.round(255 * (1 - m) * (1 - k));
                        const b = Math.round(255 * (1 - y) * (1 - k));
                        return `rgb(${r}, ${g}, ${b})`;
                    }
                } catch (e) {
                    return '#808080';
                }
                return '#808080';
            }
            
            // Helper: Format value for display
            function formatSampleValue(sample) {
                let originalValue = '';
                if (sample.format === 'hex') {
                    originalValue = sample.value;
                } else if (sample.format === 'lab') {
                    originalValue = `Lab(${sample.value[0].toFixed(2)}, ${sample.value[1].toFixed(2)}, ${sample.value[2].toFixed(2)})`;
                } else if (sample.format === 'rgb') {
                    originalValue = `RGB(${sample.value.join(', ')})`;
                } else if (sample.format === 'cmyk') {
                    originalValue = `CMYK(${sample.value.map(v => v.toFixed(2)).join(', ')})`;
                } else {
                    originalValue = String(sample.value);
                }
                
                // If we have normalized Lab values (after calculation), show them too
                if (sample.normalizedLab && Array.isArray(sample.normalizedLab)) {
                    const labStr = `Lab(${sample.normalizedLab[0].toFixed(2)}, ${sample.normalizedLab[1].toFixed(2)}, ${sample.normalizedLab[2].toFixed(2)})`;
                    if (sample.format !== 'lab') {
                        return `${originalValue}<br><span style="color: #6b7280; font-size: 12px;">→ ${labStr}</span>`;
                    }
                    return labStr;
                }
                
                return originalValue;
            }
            
            // Render samples list
            function renderConsensusSamples() {
                const container = document.getElementById('cmw-consensus-samples');
                container.innerHTML = '';
                
                consensusSamples.forEach((sample, index) => {
                    const row = document.createElement('div');
                    row.className = 'cmw-sample-row' + (sample.excluded ? ' excluded' : '');
                    row.dataset.sampleId = sample.id;
                    
                    row.innerHTML = `
                        <div class="cmw-sample-swatch" style="background: ${getSamplePreviewHex(sample)}"></div>
                        <div class="cmw-sample-info">
                            <div class="cmw-sample-label">${sample.label || 'Sample ' + (index + 1)}</div>
                            <div class="cmw-sample-values">${formatSampleValue(sample)}</div>
                            ${sample.deltaToConsensus !== undefined ? `<div class="cmw-sample-delta">ΔE2000 to consensus: ${sample.deltaToConsensus.toFixed(2)}</div>` : ''}
                        </div>
                        <button class="cmw-sample-remove" data-sample-id="${sample.id}">×</button>
                    `;
                    
                    container.appendChild(row);
                });
                
                // Update calculate button state
                const calcBtn = document.getElementById('cmw-calculate-consensus-btn');
                calcBtn.disabled = consensusSamples.length < 2;
            }
            
            // Get values from individual input fields based on format
            function getColorValuesFromInputs(format) {
                if (format === 'hex') {
                    let hex = document.getElementById('cmw-sample-hex').value.trim();
                    if (!hex) throw new Error('Please enter a hex color');
                    if (!hex.startsWith('#')) hex = '#' + hex;
                    if (!/^#[0-9A-Fa-f]{6}$/i.test(hex)) {
                        throw new Error('Invalid hex format. Use RRGGBB');
                    }
                    return { format: 'hex', value: hex.toUpperCase() };
                }
                
                if (format === 'lab') {
                    const L = parseFloat(document.getElementById('cmw-sample-lab-l').value);
                    const a = parseFloat(document.getElementById('cmw-sample-lab-a').value);
                    const b = parseFloat(document.getElementById('cmw-sample-lab-b').value);
                    if (isNaN(L) || isNaN(a) || isNaN(b)) {
                        throw new Error('Please fill in all Lab values');
                    }
                    if (L < 0 || L > 100) throw new Error('L* must be between 0 and 100');
                    return { format: 'lab', value: [L, a, b] };
                }
                
                if (format === 'rgb') {
                    const r = parseInt(document.getElementById('cmw-sample-rgb-r').value);
                    const g = parseInt(document.getElementById('cmw-sample-rgb-g').value);
                    const b = parseInt(document.getElementById('cmw-sample-rgb-b').value);
                    if (isNaN(r) || isNaN(g) || isNaN(b)) {
                        throw new Error('Please fill in all RGB values');
                    }
                    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
                        throw new Error('RGB values must be between 0 and 255');
                    }
                    return { format: 'rgb', value: [r, g, b] };
                }
                
                if (format === 'cmyk') {
                    const c = parseFloat(document.getElementById('cmw-sample-cmyk-c').value);
                    const m = parseFloat(document.getElementById('cmw-sample-cmyk-m').value);
                    const y = parseFloat(document.getElementById('cmw-sample-cmyk-y').value);
                    const k = parseFloat(document.getElementById('cmw-sample-cmyk-k').value);
                    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
                        throw new Error('Please fill in all CMYK values');
                    }
                    if (c < 0 || c > 100 || m < 0 || m > 100 || y < 0 || y > 100 || k < 0 || k > 100) {
                        throw new Error('CMYK values must be between 0 and 100');
                    }
                    return { format: 'cmyk', value: [c, m, y, k], profile: 'GRACoL2013.icc' };
                }
                
                throw new Error('Unknown format');
            }
            
            // Clear color input fields based on format
            function clearColorInputs(format) {
                if (format === 'hex') {
                    document.getElementById('cmw-sample-hex').value = '';
                } else if (format === 'lab') {
                    document.getElementById('cmw-sample-lab-l').value = '';
                    document.getElementById('cmw-sample-lab-a').value = '';
                    document.getElementById('cmw-sample-lab-b').value = '';
                } else if (format === 'rgb') {
                    document.getElementById('cmw-sample-rgb-r').value = '';
                    document.getElementById('cmw-sample-rgb-g').value = '';
                    document.getElementById('cmw-sample-rgb-b').value = '';
                } else if (format === 'cmyk') {
                    document.getElementById('cmw-sample-cmyk-c').value = '';
                    document.getElementById('cmw-sample-cmyk-m').value = '';
                    document.getElementById('cmw-sample-cmyk-y').value = '';
                    document.getElementById('cmw-sample-cmyk-k').value = '';
                }
            }
            
            // Add sample
            async function addConsensusSample() {
                const format = document.getElementById('cmw-sample-format').value;
                const labelInput = document.getElementById('cmw-sample-label');
                const statusEl = document.getElementById('cmw-consensus-status');
                
                try {
                    const parsed = getColorValuesFromInputs(format);
                    const sample = {
                        id: ++sampleIdCounter,
                        ...parsed,
                        label: labelInput.value.trim() || null,
                        // Use sRGB.icc for hex/rgb, GRACoL2013.icc for CMYK
                        profile: (format === 'hex' || format === 'rgb') ? 'sRGB.icc' : (format === 'cmyk' ? 'GRACoL2013.icc' : null)
                    };
                    
                    // Pre-compute preview color for CMYK using LittleCMS
                    if (format === 'cmyk') {
                        try {
                            const data = await convertColor({
                                cmyk: sample.value,
                                profile: 'GRACoL2013.icc'
                            });
                            if (data && data.lab) {
                                sample.previewColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                            }
                        } catch (e) {
                            console.error('CMYK preview conversion failed:', e);
                        }
                    }
                    
                    consensusSamples.push(sample);
                    renderConsensusSamples();
                    
                    // Clear inputs
                    clearColorInputs(format);
                    labelInput.value = '';
                    statusEl.className = 'cmw-status';
                    statusEl.textContent = '';
                    
                } catch (e) {
                    statusEl.textContent = e.message;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Remove sample
            function removeSample(sampleId) {
                const index = consensusSamples.findIndex(s => s.id === parseInt(sampleId));
                if (index !== -1) {
                    consensusSamples.splice(index, 1);
                    renderConsensusSamples();
                }
            }
            
            // Clear all samples
            function clearAllSamples() {
                consensusSamples.length = 0;
                sampleIdCounter = 0;
                renderConsensusSamples();
                document.getElementById('cmw-consensus-result').classList.remove('show');
                document.getElementById('cmw-consensus-status').className = 'cmw-status';
            }
            
            // Calculate consensus
            async function calculateConsensus() {
                const statusEl = document.getElementById('cmw-consensus-status');
                const loadingEl = document.getElementById('cmw-consensus-loading');
                const resultEl = document.getElementById('cmw-consensus-result');
                
                if (consensusSamples.length < 2) {
                    statusEl.textContent = 'Need at least 2 color samples';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                loadingEl.style.display = 'flex';
                resultEl.classList.remove('show');
                statusEl.className = 'cmw-status';
                
                try {
                    const apiUrl = getApiBaseUrl();
                    const threshold = parseFloat(document.getElementById('cmw-outlier-threshold').value) || 3.0;
                    
                    // Pre-convert samples to Lab using convertColor() for consistency with Color Search
                    // RGB/Hex uses sRGB.icc, CMYK uses GRACoL2013.icc (or selected profile)
                    const colors = await Promise.all(consensusSamples.map(async (s, i) => {
                        const label = s.label || `Sample ${i + 1}`;
                        
                        if (s.format === 'hex') {
                            // Convert hex to Lab using sRGB.icc (same as Color Search)
                            const cleanHex = s.value.replace('#', '');
                            const r = parseInt(cleanHex.substring(0, 2), 16);
                            const g = parseInt(cleanHex.substring(2, 4), 16);
                            const b = parseInt(cleanHex.substring(4, 6), 16);
                            
                            console.log(`[Consensus] Converting hex ${s.value} -> RGB(${r}, ${g}, ${b})`);
                            
                            try {
                                const data = await convertColor({
                                    rgb: [r, g, b],
                                    profile: 'sRGB.icc'
                                });
                                console.log(`[Consensus] Hex ${s.value} -> Lab(${data.lab[0]}, ${data.lab[1]}, ${data.lab[2]})`);
                                // Send as Lab to ensure consistency
                                return {
                                    format: 'lab',
                                    value: data.lab,
                                    label: label,
                                    profile: null
                                };
                            } catch (err) {
                                console.warn('[Consensus] Failed to convert hex, sending as-is:', err);
                                return {
                                    format: s.format,
                                    value: s.value,
                                    label: label,
                                    profile: 'sRGB.icc'
                                };
                            }
                        } else if (s.format === 'rgb') {
                            // Convert RGB to Lab using sRGB.icc
                            try {
                                const data = await convertColor({
                                    rgb: s.value,
                                    profile: 'sRGB.icc'
                                });
                                return {
                                    format: 'lab',
                                    value: data.lab,
                                    label: label,
                                    profile: null
                                };
                            } catch (err) {
                                console.warn('Failed to convert RGB, sending as-is:', err);
                                return {
                                    format: s.format,
                                    value: s.value,
                                    label: label,
                                    profile: 'sRGB.icc'
                                };
                            }
                        } else if (s.format === 'cmyk') {
                            // Convert CMYK to Lab using GRACoL2013.icc
                            try {
                                const data = await convertColor({
                                    cmyk: s.value,
                                    profile: 'GRACoL2013.icc'
                                });
                                return {
                                    format: 'lab',
                                    value: data.lab,
                                    label: label,
                                    profile: null
                                };
                            } catch (err) {
                                console.warn('Failed to convert CMYK, sending as-is:', err);
                                return {
                                    format: s.format,
                                    value: s.value,
                                    label: label,
                                    profile: 'GRACoL2013.icc'
                                };
                            }
                        } else {
                            // Lab - send as-is
                            return {
                                format: s.format,
                                value: s.value,
                                label: label,
                                profile: null
                            };
                        }
                    }));
                    
                    console.log('[Consensus] Sending colors to API:', JSON.stringify(colors, null, 2));
                    
                    // Log what we're actually sending for each sample
                    colors.forEach((c, i) => {
                        console.log(`[Consensus] Sample ${i + 1}: format=${c.format}, value=${JSON.stringify(c.value)}`);
                        if (c.format === 'lab') {
                            console.log(`[Consensus] Sample ${i + 1} Lab values: L=${c.value[0].toFixed(4)}, a=${c.value[1].toFixed(4)}, b=${c.value[2].toFixed(4)}`);
                        }
                    });
                    
                    // Include rendering intent to match Color Search behavior
                    const currentIntent = document.getElementById('cmw-default-intent').value;
                    const requestBody = {
                        colors: colors,
                        outlier_threshold: threshold,
                        include_pairwise: true,
                        include_hex_preview: true
                    };
                    
                    // Only add rendering intent if it's not "none"
                    if (currentIntent !== 'none') {
                        requestBody.renderingIntent = parseInt(currentIntent);
                    }
                    
                    const response = await fetch(`${apiUrl}/color-consensus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const errData = await response.json().catch(() => ({}));
                        throw new Error(errData.detail || 'API request failed');
                    }
                    
                    const data = await response.json();
                    console.log('Consensus API response:', data);
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Consensus calculation failed');
                    }
                    
                    // Log the consensus result Lab values
                    if (data.consensus && data.consensus.lab) {
                        console.log(`[Consensus] Result Lab: L=${data.consensus.lab[0].toFixed(4)}, a=${data.consensus.lab[1].toFixed(4)}, b=${data.consensus.lab[2].toFixed(4)}`);
                    }
                    
                    // Update sample deltas and excluded status based on actual API response
                    const includedSamples = data.samples?.included || [];
                    const excludedSamples = data.samples?.excluded || [];
                    
                    // Log each sample's Lab values from the API response
                    console.log('[Consensus] Included samples from API:');
                    includedSamples.forEach(s => {
                        if (s.lab) {
                            console.log(`  ${s.label}: Lab(${s.lab[0].toFixed(4)}, ${s.lab[1].toFixed(4)}, ${s.lab[2].toFixed(4)})`);
                        }
                    });
                    console.log('[Consensus] Excluded samples from API:');
                    excludedSamples.forEach(s => {
                        if (s.lab) {
                            console.log(`  ${s.label}: Lab(${s.lab[0].toFixed(4)}, ${s.lab[1].toFixed(4)}, ${s.lab[2].toFixed(4)})`);
                        }
                    });
                    const excludedLabels = new Set(excludedSamples.map(s => s.label || ''));
                    
                    // Create a map of label -> sample data for quick lookup
                    const sampleDataMap = {};
                    includedSamples.forEach(s => { sampleDataMap[s.label] = { ...s, excluded: false }; });
                    excludedSamples.forEach(s => { sampleDataMap[s.label] = { ...s, excluded: true }; });
                    
                    consensusSamples.forEach((sample, i) => {
                        const label = sample.label || `Sample ${i + 1}`;
                        const apiSample = sampleDataMap[label];
                        if (apiSample) {
                            sample.normalizedLab = apiSample.lab;
                            sample.deltaToConsensus = apiSample.deltaE_to_consensus;
                            sample.excluded = apiSample.excluded;
                        }
                    });
                    renderConsensusSamples();
                    
                    // Display results
                    displayConsensusResult(data);
                    
                } catch (e) {
                    console.error('Consensus error:', e);
                    statusEl.textContent = e.message || 'Failed to calculate consensus';
                    statusEl.className = 'cmw-status error show';
                } finally {
                    loadingEl.style.display = 'none';
                }
            }
            
            // Display consensus results
            function displayConsensusResult(data) {
                const resultEl = document.getElementById('cmw-consensus-result');
                
                // Consensus color - from data.consensus.lab (actual API structure)
                const consensus = data.consensus || {};
                const consensusLab = consensus.lab || [50, 0, 0];
                const L = consensusLab[0] ?? 50;
                const a = consensusLab[1] ?? 0;
                const b = consensusLab[2] ?? 0;
                const consensusHex = consensus.hex || '';
                
                // Use LittleCMS hex - show error if not available
                if (!consensusHex) {
                    console.error('LittleCMS API did not return consensus hex');
                    document.getElementById('cmw-consensus-swatch').style.background = '#f0f0f0';
                } else {
                    document.getElementById('cmw-consensus-swatch').style.background = consensusHex;
                }
                document.getElementById('cmw-consensus-lab').textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)})`;
                document.getElementById('cmw-consensus-hex').textContent = consensusHex;
                
                // Stats from actual API response
                const includedCount = data.included_count || 0;
                const excludedCount = data.excluded_count || 0;
                const maxDelta = consensus.max_deltaE || 0;
                
                document.getElementById('cmw-stat-included').textContent = includedCount;
                document.getElementById('cmw-stat-excluded').textContent = excludedCount;
                document.getElementById('cmw-stat-max-delta').textContent = maxDelta.toFixed(2);
                
                // Warning
                const warningEl = document.getElementById('cmw-consensus-warning');
                if (data.warning) {
                    warningEl.textContent = data.warning;
                    warningEl.style.display = 'block';
                } else {
                    warningEl.style.display = 'none';
                }
                
                // Pairwise comparisons - from data.pairwise_comparisons (actual API structure)
                const pairwiseGrid = document.getElementById('cmw-pairwise-grid');
                pairwiseGrid.innerHTML = '';
                
                const pairwiseData = data.pairwise_comparisons || [];
                if (pairwiseData.length > 0) {
                    pairwiseData.forEach(pair => {
                        if (pair) {
                            const item = document.createElement('div');
                            item.className = 'cmw-pairwise-item';
                            // API returns: { sample1, sample2, deltaE2000 }
                            const label1 = pair.sample1 || '?';
                            const label2 = pair.sample2 || '?';
                            const deltaE = pair.deltaE2000 || 0;
                            item.innerHTML = `
                                <span class="cmw-pairwise-pair">${label1} ↔ ${label2}</span>
                                <span class="cmw-pairwise-delta">ΔE ${deltaE.toFixed(2)}</span>
                            `;
                            pairwiseGrid.appendChild(item);
                        }
                    });
                }
                
                resultEl.classList.add('show');
            }
            
            // Event listeners for consensus feature
            document.getElementById('cmw-add-sample-btn').addEventListener('click', addConsensusSample);
            
            // Enter key support for all input fields
            document.getElementById('cmw-sample-hex').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-lab-l').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-lab-a').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-lab-b').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-rgb-r').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-rgb-g').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-rgb-b').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-c').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-m').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-y').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-k').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-label').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            
            document.getElementById('cmw-consensus-samples').addEventListener('click', (e) => {
                if (e.target.classList.contains('cmw-sample-remove')) {
                    removeSample(e.target.dataset.sampleId);
                }
            });
            
            document.getElementById('cmw-clear-samples-btn').addEventListener('click', clearAllSamples);
            
            document.getElementById('cmw-calculate-consensus-btn').addEventListener('click', calculateConsensus);
            
            document.getElementById('cmw-pairwise-toggle').addEventListener('click', () => {
                const grid = document.getElementById('cmw-pairwise-grid');
                const toggle = document.getElementById('cmw-pairwise-toggle');
                const isShown = grid.classList.toggle('show');
                toggle.classList.toggle('expanded', isShown);
                toggle.querySelector('span:last-child').textContent = isShown ? 'Hide Pairwise Comparisons' : 'Show Pairwise Comparisons';
            });
            
            // Show/hide input groups based on format selection
            document.getElementById('cmw-sample-format').addEventListener('change', (e) => {
                const format = e.target.value;
                // Hide all input groups
                document.getElementById('cmw-sample-hex-inputs').classList.remove('active');
                document.getElementById('cmw-sample-lab-inputs').classList.remove('active');
                document.getElementById('cmw-sample-rgb-inputs').classList.remove('active');
                document.getElementById('cmw-sample-cmyk-inputs').classList.remove('active');
                // Show selected input group
                document.getElementById(`cmw-sample-${format}-inputs`).classList.add('active');
                // Update swatch preview
                updateSamplePreviewSwatch();
            });
            
            // Update the sample preview swatch as user types
            async function updateSamplePreviewSwatch() {
                const format = document.getElementById('cmw-sample-format').value;
                const swatch = document.getElementById('cmw-sample-preview-swatch');
                let hexColor = '#f0f0f0'; // Default gray
                
                try {
                    if (format === 'hex') {
                        const hex = document.getElementById('cmw-sample-hex').value.trim();
                        if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                            hexColor = '#' + hex;
                        }
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById('cmw-sample-lab-l').value);
                        const a = parseFloat(document.getElementById('cmw-sample-lab-a').value);
                        const b = parseFloat(document.getElementById('cmw-sample-lab-b').value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            hexColor = lab2rgb(L, a, b);
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById('cmw-sample-rgb-r').value);
                        const g = parseInt(document.getElementById('cmw-sample-rgb-g').value);
                        const b = parseInt(document.getElementById('cmw-sample-rgb-b').value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            hexColor = `rgb(${r}, ${g}, ${b})`;
                        }
                    } else if (format === 'cmyk') {
                        // Use LittleCMS API for accurate CMYK → Lab → RGB conversion
                        const c = parseFloat(document.getElementById('cmw-sample-cmyk-c').value);
                        const m = parseFloat(document.getElementById('cmw-sample-cmyk-m').value);
                        const y = parseFloat(document.getElementById('cmw-sample-cmyk-y').value);
                        const k = parseFloat(document.getElementById('cmw-sample-cmyk-k').value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            try {
                                // CMYK → Lab via LittleCMS with GRACoL profile
                                const data = await convertColor({
                                    cmyk: [c, m, y, k],
                                    profile: 'GRACoL2013.icc'
                                });
                                if (data && data.lab) {
                                    hexColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                                }
                            } catch (e) {
                                console.error('CMYK preview conversion failed:', e);
                            }
                        }
                    }
                } catch (e) {
                    // Keep default gray on error
                }
                
                swatch.style.background = hexColor;
            }
            
            // Add input event listeners for live swatch preview
            document.getElementById('cmw-sample-hex').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-lab-l').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-lab-a').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-lab-b').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-rgb-r').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-rgb-g').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-rgb-b').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-c').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-m').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-y').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-k').addEventListener('input', updateSamplePreviewSwatch);
            
            // Consensus section collapsible toggle
            const consensusToggle = document.getElementById('cmw-consensus-toggle');
            const consensusContent = document.getElementById('cmw-consensus-content');
            
            consensusToggle.addEventListener('click', () => {
                const isCollapsed = consensusToggle.classList.contains('collapsed');
                
                if (isCollapsed) {
                    // Expand
                    consensusToggle.classList.remove('collapsed');
                    consensusContent.classList.remove('collapsed');
                } else {
                    // Collapse
                    consensusToggle.classList.add('collapsed');
                    consensusContent.classList.add('collapsed');
                }
            });

            /* ─────────────────────
               Color Compare Feature
               ───────────────────── */
            
            // Color Compare section collapsible toggle
            const compareToggle = document.getElementById('cmw-compare-toggle');
            const compareContent = document.getElementById('cmw-compare-content');
            
            compareToggle.addEventListener('click', () => {
                const isCollapsed = compareToggle.classList.contains('collapsed');
                
                if (isCollapsed) {
                    compareToggle.classList.remove('collapsed');
                    compareContent.classList.remove('collapsed');
                } else {
                    compareToggle.classList.add('collapsed');
                    compareContent.classList.add('collapsed');
                }
            });
            
            // Store compare colors data
            let compareColor1 = null;
            let compareColor2 = null;
            
            // Get color data from compare inputs and convert using LittleCMS API
            async function getCompareColorData(colorNum) {
                const format = document.getElementById(`cmw-compare-format-${colorNum}`).value;
                
                try {
                    if (format === 'hex') {
                        const input = document.getElementById(`cmw-compare-hex-${colorNum}`).value.trim();
                        // Remove # if present and check if it's a valid 6-digit hex only
                        const cleanHex = input.replace(/^#/, '');
                        if (/^[0-9A-Fa-f]{6}$/.test(cleanHex)) {
                            // Use LittleCMS API to convert hex to Lab
                            const rgb = hex2rgb(cleanHex);
                            const data = await convertColor({
                                rgb: [rgb.r, rgb.g, rgb.b],
                                profile: 'sRGB.icc'
                            });
                            return {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex ? (data.hex.startsWith('#') ? data.hex : '#' + data.hex) : '#' + cleanHex
                            };
                        }
                        return null;
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById(`cmw-compare-lab-l-${colorNum}`).value);
                        const a = parseFloat(document.getElementById(`cmw-compare-lab-a-${colorNum}`).value);
                        const b = parseFloat(document.getElementById(`cmw-compare-lab-b-${colorNum}`).value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            // Use LittleCMS API to convert Lab to hex (Lab → RGB uses sRGB)
                            const data = await convertColor({
                                lab: [L, a, b],
                                profile: 'sRGB.icc'
                            });
                            if (!data.hex) {
                                throw new Error('LittleCMS did not return hex value');
                            }
                            return {
                                lab: { L, a, b },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex
                            };
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById(`cmw-compare-rgb-r-${colorNum}`).value);
                        const g = parseInt(document.getElementById(`cmw-compare-rgb-g-${colorNum}`).value);
                        const b = parseInt(document.getElementById(`cmw-compare-rgb-b-${colorNum}`).value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            // Use LittleCMS API to convert RGB to Lab
                            const data = await convertColor({
                                rgb: [r, g, b],
                                profile: 'sRGB.icc'
                            });
                            if (!data.hex || !data.lab) {
                                throw new Error('LittleCMS did not return required values');
                            }
                            return {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex
                            };
                        }
                    } else if (format === 'cmyk') {
                        const c = parseFloat(document.getElementById(`cmw-compare-cmyk-c-${colorNum}`).value);
                        const m = parseFloat(document.getElementById(`cmw-compare-cmyk-m-${colorNum}`).value);
                        const y = parseFloat(document.getElementById(`cmw-compare-cmyk-y-${colorNum}`).value);
                        const k = parseFloat(document.getElementById(`cmw-compare-cmyk-k-${colorNum}`).value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            // Use LittleCMS API to convert CMYK to Lab
                            const data = await convertColor({
                                cmyk: [c, m, y, k],
                                profile: 'GRACoL2013.icc'
                            });
                            if (!data.hex || !data.lab) {
                                throw new Error('LittleCMS did not return required values');
                            }
                            return {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex
                            };
                        }
                    }
                } catch (e) {
                    console.error('Error converting color via API:', e);
                }
                
                return null;
            }
            
            // Update swatch preview for compare color using LittleCMS
            async function updateCompareSwatchPreview(colorNum) {
                const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                
                const colorData = await getCompareColorData(colorNum);
                
                if (colorData) {
                    swatch.style.background = colorData.hex;
                    valuesEl.textContent = `Lab(${colorData.lab.L.toFixed(2)}, ${colorData.lab.a.toFixed(2)}, ${colorData.lab.b.toFixed(2)}) | ${colorData.hex}`;
                    
                    if (colorNum === 1) {
                        compareColor1 = colorData;
                    } else {
                        compareColor2 = colorData;
                    }
                } else {
                    swatch.style.background = '#f0f0f0';
                    valuesEl.textContent = 'Lab: — | Hex: —';
                    
                    if (colorNum === 1) {
                        compareColor1 = null;
                    } else {
                        compareColor2 = null;
                    }
                }
            }
            
            // Format change handlers
            function setupCompareFormatHandler(colorNum) {
                document.getElementById(`cmw-compare-format-${colorNum}`).addEventListener('change', (e) => {
                    const format = e.target.value;
                    // Hide all input groups
                    document.getElementById(`cmw-compare-hex-inputs-${colorNum}`).classList.remove('active');
                    document.getElementById(`cmw-compare-lab-inputs-${colorNum}`).classList.remove('active');
                    document.getElementById(`cmw-compare-rgb-inputs-${colorNum}`).classList.remove('active');
                    document.getElementById(`cmw-compare-cmyk-inputs-${colorNum}`).classList.remove('active');
                    // Show selected input group
                    document.getElementById(`cmw-compare-${format}-inputs-${colorNum}`).classList.add('active');
                    updateCompareSwatchPreview(colorNum);
                });
            }
            
            setupCompareFormatHandler(1);
            setupCompareFormatHandler(2);
            
            // Input change handlers for live preview
            function setupCompareInputHandlers(colorNum) {
                // Hex/Name input - only update preview for valid 6-digit hex values
                document.getElementById(`cmw-compare-hex-${colorNum}`).addEventListener('input', () => {
                    const input = document.getElementById(`cmw-compare-hex-${colorNum}`).value.trim();
                    const cleanHex = input.replace(/^#/, '');
                    // Only update preview if it's exactly a 6-digit hex value
                    if (/^[0-9A-Fa-f]{6}$/.test(cleanHex)) {
                        updateCompareSwatchPreview(colorNum);
                    }
                });
                
                // Lab inputs
                ['l', 'a', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-lab-${comp}-${colorNum}`).addEventListener('input', () => {
                        updateCompareSwatchPreview(colorNum);
                    });
                });
                
                // RGB inputs
                ['r', 'g', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-rgb-${comp}-${colorNum}`).addEventListener('input', () => {
                        updateCompareSwatchPreview(colorNum);
                    });
                });
                
                // CMYK inputs
                ['c', 'm', 'y', 'k'].forEach(comp => {
                    document.getElementById(`cmw-compare-cmyk-${comp}-${colorNum}`).addEventListener('input', () => {
                        updateCompareSwatchPreview(colorNum);
                    });
                });
            }
            
            setupCompareInputHandlers(1);
            setupCompareInputHandlers(2);
            
            // Color name search functionality for compare (uses the same hex/name input)
            function setupCompareNameSearch(colorNum) {
                const hexInput = document.getElementById(`cmw-compare-hex-${colorNum}`);
                const suggestionsEl = document.getElementById(`cmw-compare-suggestions-${colorNum}`);
                
                let debounceTimer = null;
                
                hexInput.addEventListener('input', () => {
                    clearTimeout(debounceTimer);
                    const query = hexInput.value.trim();
                    
                    // Only treat as hex if it's exactly 6 hex digits (with optional #)
                    // This allows numbers like "185" to trigger color name search (e.g., PANTONE 185)
                    const cleanHex = query.replace(/^#/, '');
                    const isValidHexCode = /^[0-9A-Fa-f]{6}$/.test(cleanHex);
                    
                    // If it's a valid 6-digit hex, update preview and hide suggestions
                    if (isValidHexCode) {
                        suggestionsEl.style.display = 'none';
                        updateCompareSwatchPreview(colorNum);
                        return;
                    }
                    
                    if (query.length < 2) {
                        suggestionsEl.style.display = 'none';
                        return;
                    }
                    
                    debounceTimer = setTimeout(async () => {
                        const results = searchByNameComplete(query);
                        
                        if (results.length === 0) {
                            suggestionsEl.style.display = 'none';
                            return;
                        }
                        
                        // Show up to 8 suggestions
                        const limitedResults = results.slice(0, 8);
                        
                        // Build suggestions with LittleCMS hex conversion
                        const suggestionHtmlPromises = limitedResults.map(async result => {
                            const color = result.color;
                            const libName = color.libraryName || libNames[color.library] || color.library || '';
                            // Shorten "Pantone" to "PMS" in color names for display
                            const displayName = color.name.replace(/^Pantone\s*/i, 'PMS ');
                            
                            // Use LittleCMS to convert Lab to hex
                            try {
                                const data = await convertColor({
                                    lab: [color.L, color.a, color.b],
                                    profile: 'sRGB.icc'
                                });
                                const hex = data.hex ? (data.hex.startsWith('#') ? data.hex : '#' + data.hex) : '#888888';
                                return `
                                    <div class="cmw-compare-suggestion-item" data-hex="${hex.replace('#', '')}" data-lab-l="${color.L}" data-lab-a="${color.a}" data-lab-b="${color.b}" data-name="${color.name}" data-library="${libName}">
                                        <div class="cmw-compare-suggestion-swatch" style="background: ${hex};"></div>
                                        <div class="cmw-compare-suggestion-info">
                                            <div class="cmw-compare-suggestion-name">${displayName}</div>
                                            <div class="cmw-compare-suggestion-library">${libName}</div>
                                        </div>
                                    </div>
                                `;
                            } catch (err) {
                                console.error('LittleCMS API unavailable for suggestion:', err);
                                return `
                                    <div class="cmw-compare-suggestion-item" data-hex="888888" data-lab-l="${color.L}" data-lab-a="${color.a}" data-lab-b="${color.b}" data-name="${color.name}" data-library="${libName}">
                                        <div class="cmw-compare-suggestion-swatch" style="background: #888888;"></div>
                                        <div class="cmw-compare-suggestion-info">
                                            <div class="cmw-compare-suggestion-name">${displayName}</div>
                                            <div class="cmw-compare-suggestion-library">${libName} (API Error)</div>
                                        </div>
                                    </div>
                                `;
                            }
                        });
                        
                        const suggestionHtml = await Promise.all(suggestionHtmlPromises);
                        suggestionsEl.innerHTML = suggestionHtml.join('');
                        
                        suggestionsEl.style.display = 'block';
                    }, 150);
                });
                
                // Handle suggestion click
                suggestionsEl.addEventListener('click', async (e) => {
                    const item = e.target.closest('.cmw-compare-suggestion-item');
                    if (item) {
                        const colorName = item.dataset.name;
                        const libraryName = item.dataset.library || '';
                        // Shorten "Pantone" to "PMS" for display
                        const displayName = colorName.replace(/^Pantone\s*/i, 'PMS ');
                        // Use the known Lab values from the library directly
                        const L = parseFloat(item.dataset.labL);
                        const a = parseFloat(item.dataset.labA);
                        const b = parseFloat(item.dataset.labB);
                        
                        // Keep the color name in the input (don't convert to hex)
                        hexInput.value = displayName;
                        suggestionsEl.style.display = 'none';
                        
                        // Use LittleCMS to get accurate hex for display only (Lab → RGB uses sRGB)
                        try {
                            const data = await convertColor({
                                lab: [L, a, b],
                                profile: 'sRGB.icc'
                            });
                            if (!data.hex) {
                                throw new Error('LittleCMS did not return hex value');
                            }
                            const hex = data.hex.startsWith('#') ? data.hex : '#' + data.hex;
                            
                            // Store the original library Lab values, name, and library
                            const colorData = { lab: { L, a, b }, hex, isLibraryColor: true, name: displayName, libraryName: libraryName };
                            const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                            const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                            
                            swatch.style.background = hex;
                            valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | ${hex}`;
                            
                            if (colorNum === 1) {
                                compareColor1 = colorData;
                            } else {
                                compareColor2 = colorData;
                            }
                        } catch (err) {
                            console.error('LittleCMS API unavailable:', err);
                            // Show error state - no fallback
                            const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                            const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                            
                            swatch.style.background = '#f0f0f0';
                            valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | API Error`;
                            
                            // Still store Lab values for Delta E calculation (Lab values are known)
                            const colorData = { lab: { L, a, b }, hex: null, isLibraryColor: true, name: displayName, libraryName: libraryName };
                            if (colorNum === 1) {
                                compareColor1 = colorData;
                            } else {
                                compareColor2 = colorData;
                            }
                        }
                    }
                });
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!hexInput.contains(e.target) && !suggestionsEl.contains(e.target)) {
                        suggestionsEl.style.display = 'none';
                    }
                });
                
                // Handle Enter key to select first suggestion
                hexInput.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        const firstItem = suggestionsEl.querySelector('.cmw-compare-suggestion-item');
                        if (firstItem && suggestionsEl.style.display !== 'none') {
                            const colorName = firstItem.dataset.name;
                            const libraryName = firstItem.dataset.library || '';
                            // Shorten "Pantone" to "PMS" for display
                            const displayName = colorName.replace(/^Pantone\s*/i, 'PMS ');
                            // Use the known Lab values from the library directly
                            const L = parseFloat(firstItem.dataset.labL);
                            const a = parseFloat(firstItem.dataset.labA);
                            const b = parseFloat(firstItem.dataset.labB);
                            
                            // Keep the color name in the input
                            hexInput.value = displayName;
                            suggestionsEl.style.display = 'none';
                            e.preventDefault();
                            
                            // Use LittleCMS to get accurate hex for display only (Lab → RGB uses sRGB)
                            try {
                                const data = await convertColor({
                                    lab: [L, a, b],
                                    profile: 'sRGB.icc'
                                });
                                if (!data.hex) {
                                    throw new Error('LittleCMS did not return hex value');
                                }
                                const hex = data.hex.startsWith('#') ? data.hex : '#' + data.hex;
                                
                                // Store the original library Lab values, name, and library
                                const colorData = { lab: { L, a, b }, hex, isLibraryColor: true, name: displayName, libraryName: libraryName };
                                const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                                const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                                
                                swatch.style.background = hex;
                                valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | ${hex}`;
                                
                                if (colorNum === 1) {
                                    compareColor1 = colorData;
                                } else {
                                    compareColor2 = colorData;
                                }
                            } catch (err) {
                                console.error('LittleCMS API unavailable:', err);
                                // Show error state - no fallback
                                const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                                const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                                
                                swatch.style.background = '#f0f0f0';
                                valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | API Error`;
                                
                                // Still store Lab values for Delta E calculation (Lab values are known)
                                const colorData = { lab: { L, a, b }, hex: null, isLibraryColor: true, name: displayName, libraryName: libraryName };
                                if (colorNum === 1) {
                                    compareColor1 = colorData;
                                } else {
                                    compareColor2 = colorData;
                                }
                            }
                        }
                    } else if (e.key === 'Escape') {
                        suggestionsEl.style.display = 'none';
                    }
                });
            }
            
            setupCompareNameSearch(1);
            setupCompareNameSearch(2);
            
            // Interpret deltaE value
            function interpretDeltaE(deltaE) {
                if (deltaE < 1) return 'Perfect Match';       // < 1
                if (deltaE <= 2) return 'Great Match';        // 1 - 2
                if (deltaE < 4) return 'Acceptable Match';    // 2.1 - 3.9
                if (deltaE <= 5) return 'Noticeable Difference';  // 4 - 5
                if (deltaE <= 10) return 'Clearly Different'; // 5.1 - 10
                return 'Very Different';                      // 10+
            }
            
            // Compare button click handler
            document.getElementById('cmw-compare-btn').addEventListener('click', async () => {
                const resultEl = document.getElementById('cmw-compare-result');
                const statusEl = document.getElementById('cmw-compare-status');
                
                statusEl.textContent = 'Converting colors...';
                statusEl.className = 'cmw-status show';
                
                // Only update colors that aren't already set from library selection
                // Library colors already have accurate Lab values stored
                if (!compareColor1 || !compareColor1.isLibraryColor) {
                    await updateCompareSwatchPreview(1);
                }
                if (!compareColor2 || !compareColor2.isLibraryColor) {
                    await updateCompareSwatchPreview(2);
                }
                
                if (!compareColor1 || !compareColor2) {
                    statusEl.textContent = 'Please enter valid values for both colors';
                    statusEl.className = 'cmw-status error show';
                    resultEl.classList.remove('show');
                    return;
                }
                
                statusEl.className = 'cmw-status';
                
                // Calculate deltaE2000 using the stored Lab values
                // For library colors, these are the original accurate values
                const lab1 = compareColor1.lab;
                const lab2 = compareColor2.lab;
                
                // Debug logging to trace Delta E calculation
                console.log('=== Color Compare Delta E Calculation ===');
                console.log('Color 1:', compareColor1.isLibraryColor ? 'LIBRARY' : 'CONVERTED', 
                    `Lab(${lab1.L}, ${lab1.a}, ${lab1.b})`, 
                    compareColor1.name || compareColor1.hex);
                console.log('Color 2:', compareColor2.isLibraryColor ? 'LIBRARY' : 'CONVERTED', 
                    `Lab(${lab2.L}, ${lab2.a}, ${lab2.b})`, 
                    compareColor2.name || compareColor2.hex);
                
                const deltaE = dE(lab1.L, lab1.a, lab1.b, lab2.L, lab2.a, lab2.b);
                console.log('Delta E 2000:', deltaE);
                
                // Update result display
                const deltaValueEl = document.getElementById('cmw-compare-delta-value');
                deltaValueEl.textContent = deltaE.toFixed(2);
                
                // Apply gradient color based on Delta E value
                // 1-3: green, 3-5: green to yellow to red gradient, 5+: red
                deltaValueEl.classList.remove('good', 'moderate', 'poor');
                let color;
                if (deltaE <= 3) {
                    // Solid green for 0-3
                    color = `hsl(120, 85%, 40%)`;
                } else if (deltaE <= 5) {
                    // Green (120°) to Yellow (60°) to Red (0°) - interpolate hue
                    // At 3: green, at 4: yellow, at 5: red
                    const t = (deltaE - 3) / 2; // 0 at deltaE=3, 0.5 at deltaE=4, 1 at deltaE=5
                    const hue = 120 - (t * 120); // 120 (green) -> 60 (yellow) -> 0 (red)
                    color = `hsl(${hue}, 85%, 45%)`;
                } else {
                    // Red for anything above 5
                    color = `hsl(0, 85%, 45%)`;
                }
                deltaValueEl.style.color = color;
                
                document.getElementById('cmw-compare-delta-interpretation').textContent = interpretDeltaE(deltaE);
                
                // Show result
                resultEl.classList.add('show');
            });
            
            // Clear button
            document.getElementById('cmw-compare-clear-btn').addEventListener('click', () => {
                // Clear inputs
                document.getElementById('cmw-compare-hex-1').value = '';
                document.getElementById('cmw-compare-hex-2').value = '';
                ['l', 'a', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-lab-${comp}-1`).value = '';
                    document.getElementById(`cmw-compare-lab-${comp}-2`).value = '';
                });
                ['r', 'g', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-rgb-${comp}-1`).value = '';
                    document.getElementById(`cmw-compare-rgb-${comp}-2`).value = '';
                });
                ['c', 'm', 'y', 'k'].forEach(comp => {
                    document.getElementById(`cmw-compare-cmyk-${comp}-1`).value = '';
                    document.getElementById(`cmw-compare-cmyk-${comp}-2`).value = '';
                });
                
                // Hide suggestions
                document.getElementById('cmw-compare-suggestions-1').style.display = 'none';
                document.getElementById('cmw-compare-suggestions-2').style.display = 'none';
                
                // Reset swatches
                document.getElementById('cmw-compare-swatch-1').style.background = '#f0f0f0';
                document.getElementById('cmw-compare-swatch-2').style.background = '#f0f0f0';
                document.getElementById('cmw-compare-values-1').textContent = 'Lab: — | Hex: —';
                document.getElementById('cmw-compare-values-2').textContent = 'Lab: — | Hex: —';
                
                // Hide result and reset delta value color
                document.getElementById('cmw-compare-result').classList.remove('show');
                document.getElementById('cmw-compare-delta-value').style.color = '';
                document.getElementById('cmw-compare-status').className = 'cmw-status';
                
                // Reset colors
                compareColor1 = null;
                compareColor2 = null;
            });
            
            // Compare swatch click handlers for modal popup
            document.getElementById('cmw-compare-swatch-1').addEventListener('click', () => {
                if (compareColor1 && compareColor1.lab) {
                    showColorModal({
                        name: compareColor1.name || 'Color 1',
                        libraryName: compareColor1.libraryName || '',
                        L: compareColor1.lab.L,
                        a: compareColor1.lab.a,
                        b: compareColor1.lab.b
                    });
                }
            });
            
            document.getElementById('cmw-compare-swatch-2').addEventListener('click', () => {
                if (compareColor2 && compareColor2.lab) {
                    showColorModal({
                        name: compareColor2.name || 'Color 2',
                        libraryName: compareColor2.libraryName || '',
                        L: compareColor2.lab.L,
                        a: compareColor2.lab.a,
                        b: compareColor2.lab.b
                    });
                }
            });
            

            /* ─────────────────────
               Custom Libraries Feature (Multi-Library)
               ───────────────────── */
            
            // Storage for all custom libraries: { libraryId: { name, colors: [] } }
            const CUSTOM_LIBRARIES_KEY = 'cmw_custom_libraries';
            let customLibraries = {};
            let currentCustomLibraryId = null;
            
            // Generate a unique library ID
            function generateLibraryId(name) {
                return 'custom_' + name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_' + Date.now();
            }
            
            // Load all custom libraries from localStorage
            function loadCustomLibraries() {
                try {
                    const stored = localStorage.getItem(CUSTOM_LIBRARIES_KEY);
                    if (stored) {
                        customLibraries = JSON.parse(stored);
                    }
                } catch (e) {
                    console.error('Failed to load custom libraries:', e);
                    customLibraries = {};
                }
                updateLibraryToggles();
                updateLibrarySelector();
                syncCustomLibsToSearch();
            }
            
            // Save all custom libraries to localStorage
            function saveCustomLibraries() {
                try {
                    localStorage.setItem(CUSTOM_LIBRARIES_KEY, JSON.stringify(customLibraries));
                    updateLibraryToggles();
                    syncCustomLibsToSearch();
                } catch (e) {
                    console.error('Failed to save custom libraries:', e);
                }
            }
            
            // Sync custom libraries to the libs object for search
            function syncCustomLibsToSearch() {
                // Remove old custom libs from libs object
                Object.keys(libs).forEach(key => {
                    if (key.startsWith('custom_')) {
                        delete libs[key];
                        delete libNames[key];
                    }
                });
                // Add current custom libraries with libraryName set
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    if (lib.colors && lib.colors.length > 0) {
                        // Add libraryName to each color so it shows correctly in results
                        libs[id] = lib.colors.map(color => ({
                            ...color,
                            library: id,
                            libraryName: lib.name // Use the custom library's name
                        }));
                        // Also add to libNames for fallback lookups
                        libNames[id] = lib.name;
                        
                        // Debug: Check if Amazon links are present
                        const colorsWithLinks = lib.colors.filter(c => c.amazon_link || c.amazonLink).length;
                        if (colorsWithLinks > 0) {
                            console.log(`📦 Library "${lib.name}": ${colorsWithLinks}/${lib.colors.length} colors have Amazon links`);
                        }
                    }
                });
            }
            
            // Update the library toggles in the main list (only show libraries with colors)
            function updateLibraryToggles() {
                const container = document.getElementById('cmw-custom-libraries-container');
                container.innerHTML = '';
                
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    if (lib.colors && lib.colors.length > 0) {
                        const div = document.createElement('div');
                        div.className = 'cmw-toggle-item';
                        div.innerHTML = `
                            <input type="checkbox" id="toggle-${id}" value="${id}" checked>
                            <label for="toggle-${id}">${lib.name} <span class="cmw-library-count" id="count-${id}">(${lib.colors.length})</span></label>
                        `;
                        container.appendChild(div);
                    }
                });
            }
            
            // Update the library selector dropdown
            function updateLibrarySelector() {
                const select = document.getElementById('cmw-custom-library-select');
                const currentValue = select.value;
                
                select.innerHTML = '<option value="">-- Select or Create --</option>';
                
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${lib.name} (${lib.colors?.length || 0})`;
                    select.appendChild(option);
                });
                
                // Restore selection if still valid
                if (currentValue && customLibraries[currentValue]) {
                    select.value = currentValue;
                }
            }
            
            // Select a library to edit
            function selectLibrary(libraryId) {
                currentCustomLibraryId = libraryId;
                
                const infoEl = document.getElementById('cmw-current-library-info');
                const formEl = document.getElementById('cmw-custom-add-form');
                const listEl = document.getElementById('cmw-custom-library-list');
                
                if (!libraryId || !customLibraries[libraryId]) {
                    currentCustomLibraryId = null;
                    infoEl.style.display = 'none';
                    formEl.style.display = 'none';
                    listEl.innerHTML = '<div class="cmw-custom-empty">Select or create a library to add colors.</div>';
                    return;
                }
                
                const lib = customLibraries[libraryId];
                
                // Show library info
                document.getElementById('cmw-current-library-name').textContent = lib.name;
                document.getElementById('cmw-current-library-count').textContent = `(${lib.colors?.length || 0} colors)`;
                infoEl.style.display = 'block';
                formEl.style.display = 'flex';
                
                // Render colors
                renderCurrentLibraryColors();
            }
            
            // Render colors for the current library
            function renderCurrentLibraryColors() {
                const container = document.getElementById('cmw-custom-library-list');
                
                if (!currentCustomLibraryId || !customLibraries[currentCustomLibraryId]) {
                    container.innerHTML = '<div class="cmw-custom-empty">Select or create a library to add colors.</div>';
                    return;
                }
                
                const colors = customLibraries[currentCustomLibraryId].colors || [];
                
                if (colors.length === 0) {
                    container.innerHTML = '<div class="cmw-custom-empty">No colors in this library yet. Add colors below.</div>';
                    return;
                }
                
                container.innerHTML = colors.map((color, index) => {
                    const hasAmazonLink = color.amazon_link || color.amazonLink;
                    const amazonIndicator = hasAmazonLink ? ' <img src="https://www.amazon.com/favicon.ico" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 4px;" title="Available on Amazon">' : '';
                    
                    return `
                        <div class="cmw-custom-color-item" data-index="${index}" style="cursor: pointer;" title="${hasAmazonLink ? 'Click for details and purchase link' : 'Click for details'}">
                            <div class="cmw-custom-color-swatch" style="background: ${lab2rgb(color.L, color.a, color.b)}"></div>
                            <div class="cmw-custom-color-info">
                                <div class="cmw-custom-color-name">${color.name}${amazonIndicator}</div>
                                <div class="cmw-custom-color-values">Lab(${color.L.toFixed(2)}, ${color.a.toFixed(2)}, ${color.b.toFixed(2)})</div>
                            </div>
                            <button class="cmw-custom-color-remove" data-index="${index}" title="Remove color" onclick="event.stopPropagation()">×</button>
                        </div>
                    `;
                }).join('');
                
                // Add click handlers to show unified modal with all metadata
                container.querySelectorAll('.cmw-custom-color-item').forEach((item, index) => {
                    item.addEventListener('click', (e) => {
                        // Don't open modal if clicking the remove button
                        if (e.target.classList.contains('cmw-custom-color-remove')) return;
                        
                        const color = colors[index];
                        const libraryName = customLibraries[currentCustomLibraryId].name;
                        
                        // Use the unified showColorModal function with all metadata
                        showColorModal({
                            name: color.name,
                            L: color.L,
                            a: color.a,
                            b: color.b,
                            libraryName: libraryName,
                            amazon_link: color.amazon_link || color.amazonLink,
                            manufacturer_link: color.manufacturer_link || color.manufacturerLink,
                            originalHex: color.hex,
                            manufacturer: color.manufacturer,
                            filament_type: color.filament_type
                        });
                    });
                });
                
                // Update count display
                document.getElementById('cmw-current-library-count').textContent = `(${colors.length} colors)`;
            }
            
            // Create a new library
            function createNewLibrary() {
                const nameInput = document.getElementById('cmw-new-library-name');
                const statusEl = document.getElementById('cmw-custom-status');
                const name = nameInput.value.trim();
                
                if (!name) {
                    statusEl.textContent = 'Please enter a library name';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                // Check for duplicate names
                const exists = Object.values(customLibraries).some(lib => 
                    lib.name.toLowerCase() === name.toLowerCase()
                );
                
                if (exists) {
                    statusEl.textContent = 'A library with this name already exists';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                const id = generateLibraryId(name);
                customLibraries[id] = { name, colors: [] };
                saveCustomLibraries();
                updateLibrarySelector();
                
                // Select the new library
                document.getElementById('cmw-custom-library-select').value = id;
                selectLibrary(id);
                
                nameInput.value = '';
                statusEl.textContent = `Created library "${name}"`;
                statusEl.className = 'cmw-status success show';
                setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
            }
            
            // Delete the current library
            function deleteCurrentLibrary() {
                if (!currentCustomLibraryId) return;
                
                const lib = customLibraries[currentCustomLibraryId];
                if (!confirm(`Delete library "${lib.name}" and all its colors?`)) return;
                
                delete customLibraries[currentCustomLibraryId];
                saveCustomLibraries();
                updateLibrarySelector();
                
                document.getElementById('cmw-custom-library-select').value = '';
                selectLibrary(null);
                
                const statusEl = document.getElementById('cmw-custom-status');
                statusEl.textContent = `Deleted library "${lib.name}"`;
                statusEl.className = 'cmw-status success show';
                setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
            }
            
            // Get custom color values from inputs (uses LittleCMS API for conversions)
            async function getCustomColorValues() {
                const format = document.getElementById('cmw-custom-format').value;
                const name = document.getElementById('cmw-custom-color-name').value.trim();
                
                if (!name) {
                    throw new Error('Please enter a color name');
                }
                
                let L, a, b;
                
                if (format === 'hex') {
                    let hex = document.getElementById('cmw-custom-hex').value.trim();
                    if (!hex) throw new Error('Please enter a hex color');
                    if (!hex.startsWith('#')) hex = '#' + hex;
                    if (!/^#[0-9A-Fa-f]{6}$/i.test(hex)) {
                        throw new Error('Invalid hex format. Use RRGGBB');
                    }
                    const rgb = hex2rgb(hex);
                    // Use LittleCMS API for hex → Lab conversion
                    const data = await convertColor({
                        rgb: [rgb.r, rgb.g, rgb.b],
                        profile: 'sRGB.icc'
                    });
                    L = data.lab[0]; a = data.lab[1]; b = data.lab[2];
                } else if (format === 'lab') {
                    L = parseFloat(document.getElementById('cmw-custom-lab-l').value);
                    a = parseFloat(document.getElementById('cmw-custom-lab-a').value);
                    b = parseFloat(document.getElementById('cmw-custom-lab-b').value);
                    if (isNaN(L) || isNaN(a) || isNaN(b)) {
                        throw new Error('Please fill in all Lab values');
                    }
                    if (L < 0 || L > 100) throw new Error('L* must be between 0 and 100');
                } else if (format === 'rgb') {
                    const r = parseInt(document.getElementById('cmw-custom-rgb-r').value);
                    const g = parseInt(document.getElementById('cmw-custom-rgb-g').value);
                    const bVal = parseInt(document.getElementById('cmw-custom-rgb-b').value);
                    if (isNaN(r) || isNaN(g) || isNaN(bVal)) {
                        throw new Error('Please fill in all RGB values');
                    }
                    if (r < 0 || r > 255 || g < 0 || g > 255 || bVal < 0 || bVal > 255) {
                        throw new Error('RGB values must be between 0 and 255');
                    }
                    // Use LittleCMS API for RGB → Lab conversion
                    const data = await convertColor({
                        rgb: [r, g, bVal],
                        profile: 'sRGB.icc'
                    });
                    L = data.lab[0]; a = data.lab[1]; b = data.lab[2];
                } else if (format === 'cmyk') {
                    const c = parseFloat(document.getElementById('cmw-custom-cmyk-c').value);
                    const m = parseFloat(document.getElementById('cmw-custom-cmyk-m').value);
                    const y = parseFloat(document.getElementById('cmw-custom-cmyk-y').value);
                    const k = parseFloat(document.getElementById('cmw-custom-cmyk-k').value);
                    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
                        throw new Error('Please fill in all CMYK values');
                    }
                    // Use LittleCMS API for CMYK → Lab conversion
                    const data = await convertColor({
                        cmyk: [c, m, y, k],
                        profile: 'GRACoL2013.icc'
                    });
                    L = data.lab[0]; a = data.lab[1]; b = data.lab[2];
                }
                
                return { name, L, a, b };
            }
            
            // Clear custom color inputs
            function clearCustomInputs() {
                document.getElementById('cmw-custom-color-name').value = '';
                document.getElementById('cmw-custom-hex').value = '';
                document.getElementById('cmw-custom-lab-l').value = '';
                document.getElementById('cmw-custom-lab-a').value = '';
                document.getElementById('cmw-custom-lab-b').value = '';
                document.getElementById('cmw-custom-rgb-r').value = '';
                document.getElementById('cmw-custom-rgb-g').value = '';
                document.getElementById('cmw-custom-rgb-b').value = '';
                document.getElementById('cmw-custom-cmyk-c').value = '';
                document.getElementById('cmw-custom-cmyk-m').value = '';
                document.getElementById('cmw-custom-cmyk-y').value = '';
                document.getElementById('cmw-custom-cmyk-k').value = '';
            }
            
            // Add a color to the current library
            async function addCustomColor() {
                const statusEl = document.getElementById('cmw-custom-status');
                
                if (!currentCustomLibraryId) {
                    statusEl.textContent = 'Please select or create a library first';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                try {
                    statusEl.textContent = 'Converting color...';
                    statusEl.className = 'cmw-status show';
                    
                    const color = await getCustomColorValues();
                    customLibraries[currentCustomLibraryId].colors.push(color);
                    saveCustomLibraries();
                    renderCurrentLibraryColors();
                    updateLibrarySelector();
                    clearCustomInputs();
                    
                    statusEl.textContent = `Added "${color.name}" to ${customLibraries[currentCustomLibraryId].name}`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
                } catch (e) {
                    statusEl.textContent = e.message;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Remove a color from the current library
            function removeCustomColor(index) {
                if (!currentCustomLibraryId) return;
                customLibraries[currentCustomLibraryId].colors.splice(index, 1);
                saveCustomLibraries();
                renderCurrentLibraryColors();
                updateLibrarySelector();
            }
            
            // Export current library as JSON
            function exportCurrentLibrary() {
                if (!currentCustomLibraryId) {
                    alert('Please select a library to export');
                    return;
                }
                
                const lib = customLibraries[currentCustomLibraryId];
                if (!lib.colors || lib.colors.length === 0) {
                    alert('Library has no colors to export');
                    return;
                }
                
                // Show export format modal
                showExportFormatModal(lib);
            }
            
            function showExportFormatModal(library) {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                // Create modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 400px;
                    width: 90%;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                `;
                
                modal.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #0065a3; font-size: 1.4rem;">Export "${library.name}"</h3>
                    <p style="color: #666; margin-bottom: 24px; font-size: 0.95rem;">Select export format:</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button class="export-format-btn" data-format="json" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            cursor: pointer;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                        ">
                            <span style="font-weight: 600; color: #0065a3;">JSON</span>
                            <span style="color: #888; font-size: 0.85rem;">- Universal format, easy to edit</span>
                        </button>
                        
                        <button class="export-format-btn" data-format="csv" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            cursor: pointer;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                        ">
                            <span style="font-weight: 600; color: #0065a3;">CSV</span>
                            <span style="color: #888; font-size: 0.85rem;">- Excel compatible spreadsheet</span>
                        </button>
                        
                        <div class="export-format-btn-container" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                        ">
                            <div style="font-weight: 600; color: #0065a3; margin-bottom: 8px;">ASE - Adobe Swatch Exchange</div>
                            <div style="color: #666; font-size: 0.9rem; margin-bottom: 8px;">Photoshop/Illustrator/InDesign</div>
                            
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 8px; font-size: 0.9rem;">Color Mode:</div>
                                
                                <label style="display: flex; align-items: start; gap: 8px; margin-bottom: 8px; cursor: pointer; padding: 8px; border-radius: 4px; background: #f8f9fa;">
                                    <input type="radio" name="ase-color-mode" value="rgb" checked style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: #0065a3; font-size: 0.9rem;">RGB (Recommended)</div>
                                        <div style="color: #666; font-size: 0.8rem;">Best for general use, web, digital • No gamut issues</div>
                                    </div>
                                </label>
                                
                                <label style="display: flex; align-items: start; gap: 8px; cursor: pointer; padding: 8px; border-radius: 4px;">
                                    <input type="radio" name="ase-color-mode" value="cmyk" style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: #333; font-size: 0.9rem;">CMYK (Print)</div>
                                        <div style="color: #666; font-size: 0.8rem;">GRACoL profile • Professional print workflows</div>
                                    </div>
                                </label>
                                
                                <button class="export-ase-btn" data-format="ase" style="
                                    margin-top: 12px;
                                    width: 100%;
                                    padding: 10px 16px;
                                    border: none;
                                    border-radius: 6px;
                                    background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
                                    color: white;
                                    cursor: pointer;
                                    font-size: 0.95rem;
                                    font-weight: 600;
                                    transition: all 0.2s;
                                ">Export ASE</button>
                            </div>
                        </div>
                        
                        <button class="export-format-btn" data-format="cxf" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            cursor: pointer;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                        ">
                            <span style="font-weight: 600; color: #0065a3;">CXF</span>
                            <span style="color: #888; font-size: 0.85rem;">- Color Exchange Format (X-Rite standard)</span>
                        </button>
                    </div>
                    
                    <button id="export-cancel-btn" style="
                        margin-top: 20px;
                        width: 100%;
                        padding: 12px;
                        border: 2px solid #ddd;
                        border-radius: 8px;
                        background: white;
                        cursor: pointer;
                        font-size: 1rem;
                        color: #666;
                    ">Cancel</button>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                // Add hover effects to containers and buttons
                const formatContainers = modal.querySelectorAll('.export-format-btn-container');
                formatContainers.forEach(container => {
                    container.addEventListener('mouseenter', () => {
                        container.style.borderColor = '#0065a3';
                        container.style.background = '#f0f8ff';
                    });
                    container.addEventListener('mouseleave', () => {
                        container.style.borderColor = '#ddd';
                        container.style.background = 'white';
                    });
                    
                    // Add hover effect to radio button labels
                    const labels = container.querySelectorAll('label');
                    labels.forEach(label => {
                        label.addEventListener('mouseenter', () => {
                            label.style.background = '#e8f4f8';
                        });
                        label.addEventListener('mouseleave', () => {
                            const radio = label.querySelector('input[type="radio"]');
                            if (!radio.checked) {
                                label.style.background = radio.value === 'rgb' ? '#f8f9fa' : 'transparent';
                            }
                        });
                    });
                });
                
                // Add click handlers to standard format buttons (JSON, CSV, CXF)
                const formatButtons = modal.querySelectorAll('.export-format-btn');
                formatButtons.forEach(btn => {
                    btn.addEventListener('mouseenter', () => {
                        btn.style.borderColor = '#0065a3';
                        btn.style.background = '#f0f8ff';
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.borderColor = '#ddd';
                        btn.style.background = 'white';
                    });
                    
                    btn.addEventListener('click', async () => {
                        const format = btn.dataset.format;
                        document.body.removeChild(overlay);
                        await exportLibraryInFormat(library, format, null);
                    });
                });
                
                // Handle ASE export button separately
                const aseBtn = modal.querySelector('.export-ase-btn');
                if (aseBtn) {
                    aseBtn.addEventListener('mouseenter', () => {
                        aseBtn.style.background = 'linear-gradient(135deg, #0077c2 0%, #005a8a 100%)';
                        aseBtn.style.transform = 'translateY(-2px)';
                        aseBtn.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                    });
                    aseBtn.addEventListener('mouseleave', () => {
                        aseBtn.style.background = 'linear-gradient(135deg, #0065a3 0%, #004d7a 100%)';
                        aseBtn.style.transform = 'translateY(0)';
                        aseBtn.style.boxShadow = 'none';
                    });
                    
                    aseBtn.addEventListener('click', async () => {
                        const selectedMode = modal.querySelector('input[name="ase-color-mode"]:checked');
                        const colorMode = selectedMode ? selectedMode.value : 'rgb';  // Default to RGB
                        console.log('ASE Export clicked - Color Mode:', colorMode);
                        
                        document.body.removeChild(overlay);
                        await exportLibraryInFormat(library, 'ase', colorMode);
                    });
                }
                
                // Cancel button
                modal.querySelector('#export-cancel-btn').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                });
                
                // Click outside to close
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                    }
                });
            }
            
            async function exportLibraryInFormat(library, format, colorMode = null) {
                console.log('exportLibraryInFormat called:', { format, colorMode, library: library.name });
                const sanitizedName = library.name.replace(/[^a-z0-9]/gi, '_');
                
                try {
                    switch (format) {
                        case 'json':
                            exportAsJSON(library, sanitizedName);
                            break;
                        case 'csv':
                            exportAsCSV(library, sanitizedName);
                            break;
                        case 'ase':
                            console.log('Calling exportAsASE with colorMode:', colorMode || 'rgb');
                            await exportAsASE(library, sanitizedName, colorMode || 'rgb');
                            break;
                        case 'cxf':
                            await exportAsCXF(library, sanitizedName);
                            break;
                    }
                } catch (error) {
                    console.error('Export error:', error);
                    alert(`Failed to export: ${error.message}`);
                }
            }
            
            function exportAsJSON(library, filename) {
                const exportData = {
                    libraryName: library.name,
                    colors: library.colors
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                downloadBlob(blob, `${filename}_colors.json`);
            }
            
            function exportAsCSV(library, filename) {
                // Create CSV header (use L*, a*, b* to match import expectations)
                let csv = 'Name,L*,a*,b*,Hex,Notes\n';
                
                // Add each color
                library.colors.forEach(color => {
                    const name = `"${(color.name || '').replace(/"/g, '""')}"`;
                    // Handle both data formats: {L, a, b} and {lab: [L, a, b]}
                    const L = (color.L !== undefined ? color.L : color.lab[0]).toFixed(2);
                    const a = (color.a !== undefined ? color.a : color.lab[1]).toFixed(2);
                    const b = (color.b !== undefined ? color.b : color.lab[2]).toFixed(2);
                    
                    // Convert Lab to Hex for preview
                    const hex = lab2hex(parseFloat(L), parseFloat(a), parseFloat(b));
                    const notes = `"${(color.notes || '').replace(/"/g, '""')}"`;
                    
                    csv += `${name},${L},${a},${b},${hex},${notes}\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                downloadBlob(blob, `${filename}_colors.csv`);
            }
            
            async function exportAsASE(library, filename, colorMode) {
                // Send to backend for ASE generation
                const apiUrl = getApiBaseUrl();
                const response = await fetch(`${apiUrl}/export-ase`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        library_name: library.name,
                        colors: library.colors,
                        color_mode: colorMode  // Default: 'lab' (device-independent)
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`ASE export failed: ${errorText}`);
                }
                
                // Check for gamut warnings
                const warningCount = response.headers.get('X-Gamut-Warnings');
                const warningDetails = response.headers.get('X-Warning-Details');
                
                if (warningCount && parseInt(warningCount) > 0) {
                    const modeLabel = colorMode === 'rgb' ? 'sRGB' : 'CMYK/GRACoL';
                    let message = `⚠️ Gamut Warning: ${warningCount} color(s) are out of ${modeLabel} gamut and were clipped.\n\n`;
                    
                    if (warningDetails) {
                        message += `Examples:\n${warningDetails.replace(/; /g, '\n')}`;
                    }
                    
                    message += `\n\nThe colors were exported, but some may not match exactly due to gamut limitations.`;
                    alert(message);
                }
                
                const blob = await response.blob();
                const modeLabel = colorMode.toUpperCase();
                downloadBlob(blob, `${filename}_${modeLabel}_colors.ase`);
            }
            
            async function exportAsCXF(library, filename) {
                // Send to backend for CXF generation
                const apiUrl = getApiBaseUrl();
                const response = await fetch(`${apiUrl}/export-cxf`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        library_name: library.name,
                        colors: library.colors
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`CXF export failed: ${errorText}`);
                }
                
                const blob = await response.blob();
                downloadBlob(blob, `${filename}_colors.cxf`);
            }
            
            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // Import library from JSON
            function importLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        
                        let libraryName, colors;
                        
                        // Support both formats: { libraryName, colors } or just array of colors
                        if (imported.libraryName && Array.isArray(imported.colors)) {
                            libraryName = imported.libraryName;
                            colors = imported.colors;
                        } else if (Array.isArray(imported)) {
                            // Prompt for library name
                            libraryName = prompt('Enter a name for the imported library:', 'Imported Library');
                            if (!libraryName) return;
                            colors = imported;
                        } else {
                            throw new Error('Invalid format');
                        }
                        
                        // Validate colors and preserve all metadata (amazon_link, manufacturer_link, etc.)
                        const validColors = colors.filter(c => 
                            c && typeof c.name === 'string' && 
                            typeof c.L === 'number' && 
                            typeof c.a === 'number' && 
                            typeof c.b === 'number'
                        ).map(c => ({
                            ...c, // Preserve all fields from original color object
                            name: c.name,
                            L: c.L,
                            a: c.a,
                            b: c.b
                        }));
                        
                        if (validColors.length === 0) {
                            throw new Error('No valid colors found in file');
                        }
                        
                        // Create new library
                        const id = generateLibraryId(libraryName);
                        customLibraries[id] = { name: libraryName, colors: validColors };
                        saveCustomLibraries();
                        updateLibrarySelector();
                        
                        // Select the new library
                        document.getElementById('cmw-custom-library-select').value = id;
                        selectLibrary(id);
                        
                        statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors`;
                        statusEl.className = 'cmw-status success show';
                        setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
                    } catch (e) {
                        statusEl.textContent = `Import failed: ${e.message}`;
                        statusEl.className = 'cmw-status error show';
                    }
                };
                
                reader.readAsText(file);
            }
            
            // Import library from CXF (Color Exchange Format) file
            async function importCxfLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing CXF file...';
                statusEl.className = 'cmw-status show';
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch(`${API_URL}/import-cxf`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'CXF import failed');
                    }
                    
                    const data = await response.json();
                    
                    if (!data.colors || data.colors.length === 0) {
                        throw new Error('No colors found in CXF file');
                    }
                    
                    // Prompt for library name
                    let libraryName = data.file_info?.description || file.name.replace('.cxf', '');
                    libraryName = prompt('Enter a name for the imported library:', libraryName);
                    if (!libraryName) {
                        statusEl.className = 'cmw-status';
                        return;
                    }
                    
                    // Validate and format colors
                    const validColors = data.colors.filter(c => 
                        c && typeof c.name === 'string' && 
                        typeof c.L === 'number' && 
                        typeof c.a === 'number' && 
                        typeof c.b === 'number'
                    ).map(c => ({
                        name: c.name,
                        L: c.L,
                        a: c.a,
                        b: c.b,
                        // Include any additional data from CXF
                        ...(c.rgb && { rgb: c.rgb }),
                        ...(c.cmyk && { cmyk: c.cmyk }),
                        source: 'cxf'
                    }));
                    
                    if (validColors.length === 0) {
                        throw new Error('No valid Lab colors found in CXF file');
                    }
                    
                    // Create new library
                    const id = generateLibraryId(libraryName);
                    customLibraries[id] = { 
                        name: libraryName, 
                        colors: validColors,
                        source: 'cxf',
                        importedFrom: file.name,
                        importedAt: new Date().toISOString()
                    };
                    saveCustomLibraries();
                    updateLibrarySelector();
                    
                    // Select the new library
                    document.getElementById('cmw-custom-library-select').value = id;
                    selectLibrary(id);
                    
                    statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors from CXF`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                    
                } catch (e) {
                    console.error('CXF import error:', e);
                    statusEl.textContent = `CXF import failed: ${e.message}`;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Import library from ASE (Adobe Swatch Exchange) file
            async function importAseLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing ASE file...';
                statusEl.className = 'cmw-status show';
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch(`${API_URL}/import-ase`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'ASE import failed');
                    }
                    
                    const data = await response.json();
                    
                    if (!data.colors || data.colors.length === 0) {
                        throw new Error('No colors found in ASE file');
                    }
                    
                    // Prompt for library name
                    let libraryName = file.name.replace('.ase', '');
                    libraryName = prompt('Enter a name for the imported library:', libraryName);
                    if (!libraryName) {
                        statusEl.className = 'cmw-status';
                        return;
                    }
                    
                    // Validate and format colors
                    const validColors = data.colors.filter(c => 
                        c && typeof c.name === 'string' && 
                        typeof c.L === 'number' && 
                        typeof c.a === 'number' && 
                        typeof c.b === 'number'
                    ).map(c => ({
                        name: c.name,
                        L: c.L,
                        a: c.a,
                        b: c.b,
                        source: 'ase'
                    }));
                    
                    if (validColors.length === 0) {
                        throw new Error('No valid Lab colors found in ASE file');
                    }
                    
                    // Create new library
                    const id = generateLibraryId(libraryName);
                    customLibraries[id] = { 
                        name: libraryName, 
                        colors: validColors,
                        source: 'ase',
                        importedFrom: file.name,
                        importedAt: new Date().toISOString()
                    };
                    saveCustomLibraries();
                    updateLibrarySelector();
                    
                    // Select the new library
                    document.getElementById('cmw-custom-library-select').value = id;
                    selectLibrary(id);
                    
                    statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors from ASE`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                    
                } catch (e) {
                    console.error('ASE import error:', e);
                    statusEl.textContent = `ASE import failed: ${e.message}`;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Import library from FilamentColors JSON format
            async function importFilamentColorsLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing Filament Colors...';
                statusEl.className = 'cmw-status show';
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch(`${API_URL}/import-filament-colors`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Filament colors import failed');
                    }
                    
                    const data = await response.json();
                    
                    if (!data.colors || data.colors.length === 0) {
                        throw new Error('No colors found in file');
                    }
                    
                    // Prompt for library name
                    let libraryName = data.source || file.name.replace('.json', '');
                    libraryName = prompt('Enter a name for the imported library:', libraryName);
                    if (!libraryName) {
                        statusEl.className = 'cmw-status';
                        return;
                    }
                    
                    // Format colors (they already have L, a, b from backend)
                    const validColors = data.colors.map(c => ({
                        name: c.name,
                        L: c.L,
                        a: c.a,
                        b: c.b,
                        manufacturer: c.manufacturer,
                        filament_type: c.filament_type,
                        hex: c.hex,
                        amazon_link: c.amazon_link,
                        manufacturer_link: c.manufacturer_link,
                        source: 'filament'
                    }));
                    
                    // Create new library
                    const id = generateLibraryId(libraryName);
                    customLibraries[id] = { 
                        name: libraryName, 
                        colors: validColors,
                        source: 'filament',
                        importedFrom: file.name,
                        importedAt: new Date().toISOString(),
                        stats: data.stats
                    };
                    saveCustomLibraries();
                    updateLibrarySelector();
                    
                    // Select the new library
                    document.getElementById('cmw-custom-library-select').value = id;
                    selectLibrary(id);
                    
                    let statsMsg = '';
                    if (data.stats) {
                        statsMsg = ` (${data.stats.converted_from_rgb} converted from RGB)`;
                    }
                    
                    statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors${statsMsg}`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                    
                } catch (e) {
                    console.error('Filament colors import error:', e);
                    statusEl.textContent = `Import failed: ${e.message}`;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // CSV Import function
            async function importCsvLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing CSV file...';
                statusEl.className = 'cmw-status show';
                
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        const csvText = e.target.result;
                        const lines = csvText.split(/\r?\n/).filter(line => line.trim());
                        
                        if (lines.length < 2) {
                            throw new Error('CSV file must have a header row and at least one data row');
                        }
                        
                        // Parse header to find column indices
                        const header = lines[0].toLowerCase().split(',').map(h => h.trim().replace(/"/g, ''));
                        
                        // DEBUG: Show what we're looking at
                        console.log('CSV Header:', header);
                        
                        // Find column indices (flexible naming)
                        const findCol = (...names) => {
                            for (const name of names) {
                                const idx = header.findIndex(h => h.includes(name));
                                if (idx !== -1) return idx;
                            }
                            return -1;
                        };
                        
                        const nameCol = findCol('name', 'color', 'swatch');
                        
                        // Lab column detection - be VERY specific to avoid confusion with RGB 'b'
                        const lCol = (() => {
                            // Look for L* or L column (but not 'blue' or 'lightness')
                            const idx = header.findIndex(h => {
                                if (h.includes('blue') || h.includes('lightness')) return false;
                                return h === 'l' || h === 'l*' || h.includes('l*') || h.includes('l ') || h.includes(' l');
                            });
                            return idx;
                        })();
                        
                        const aCol = (() => {
                            // Look for a* or a column (but not 'alpha')
                            const idx = header.findIndex(h => {
                                if (h.includes('alpha')) return false;
                                return h === 'a' || h === 'a*' || h.includes('a*') || h.includes('a ') || h.includes(' a');
                            });
                            return idx;
                        })();
                        
                        const bCol = (() => {
                            // Look for b* column ONLY (not 'b' alone, which could be blue or RGB b)
                            const idx = header.findIndex(h => {
                                if (h.includes('blue')) return false;
                                return h === 'b' || h === 'b*' || h.includes('b*') || h.includes('b ') || h.includes(' b');
                            });
                            return idx;
                        })();
                        
                        const hexCol = findCol('hex', '#');
                        const rCol = findCol('r', 'red');
                        const gCol = findCol('g', 'green');
                        const blueCol = findCol('blue'); // Only look for 'blue', not 'b'
                        
                        // DEBUG: Show column detection
                        console.log('Column detection:', {
                            nameCol, lCol, aCol, bCol, hexCol, rCol, gCol, blueCol
                        });
                        
                        // Determine which format we have
                        const hasLab = lCol !== -1 && aCol !== -1 && bCol !== -1;
                        const hasHex = hexCol !== -1;
                        const hasRgb = rCol !== -1 && gCol !== -1 && blueCol !== -1 && !hasLab; // Only use RGB if no Lab
                        
                        console.log('Format detection:', { hasLab, hasHex, hasRgb });
                        console.log('IMPORTANT: hasLab =', hasLab, '- Will use Lab columns:', hasLab ? 'YES (ignoring Hex)' : 'NO');
                        
                        if (!hasLab && !hasHex && !hasRgb) {
                            throw new Error('CSV must have Lab (L*, a*, b*), Hex, or RGB columns');
                        }
                        
                        if (nameCol === -1) {
                            throw new Error('CSV must have a Name/Color column');
                        }
                        
                        const colors = [];
                        const parseValue = (val) => {
                            if (!val) return null;
                            val = val.trim().replace(/"/g, '');
                            const num = parseFloat(val);
                            return isNaN(num) ? null : num;
                        };
                        
                        // Process data rows
                        for (let i = 1; i < lines.length; i++) {
                            // Handle CSV with quoted values containing commas
                            const row = [];
                            let current = '';
                            let inQuotes = false;
                            for (const char of lines[i]) {
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    row.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            row.push(current.trim());
                            
                            const name = row[nameCol]?.replace(/"/g, '').trim();
                            if (!name) continue;
                            
                            let L, a, b;
                            
                            // HARD RULE: If Lab columns exist, NEVER use Hex conversion
                            if (hasLab) {
                                // Direct Lab values - use these first!
                                L = parseValue(row[lCol]);
                                a = parseValue(row[aCol]);
                                b = parseValue(row[bCol]);
                                console.log(`Row ${i}: ${name} -> L=${L}, a=${a}, b=${b} (from Lab columns - Hex IGNORED)`);
                                
                                // Skip to validation - DO NOT try Hex conversion
                            } 
                            // Only use Hex conversion if NO Lab columns were found
                            else if (!hasLab && hasHex) {
                                // Convert Hex to Lab using API
                                let hex = row[hexCol]?.replace(/"/g, '').trim();
                                if (!hex) continue;
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                
                                try {
                                    const result = await convertColor({ hex, profile: 'sRGB.icc' });
                                    if (result && result.lab) {
                                        L = result.lab.L;
                                        a = result.lab.a;
                                        b = result.lab.b;
                                    }
                                } catch (err) {
                                    console.warn(`Failed to convert hex ${hex} for ${name}:`, err);
                                    continue;
                                }
                            } 
                            // Only use RGB if we have neither Lab nor Hex
                            else if (hasRgb && !hasLab && !hasHex) {
                                // Convert RGB to Lab using API
                                const r = parseValue(row[rCol]);
                                const g = parseValue(row[gCol]);
                                const blue = parseValue(row[blueCol]);
                                
                                if (r === null || g === null || blue === null) continue;
                                
                                try {
                                    const result = await convertColor({ rgb: [r, g, blue], profile: 'sRGB.icc' });
                                    if (result && result.lab) {
                                        L = result.lab.L;
                                        a = result.lab.a;
                                        b = result.lab.b;
                                    }
                                } catch (err) {
                                    console.warn(`Failed to convert RGB for ${name}:`, err);
                                    continue;
                                }
                            }
                            
                            if (L !== null && a !== null && b !== null) {
                                colors.push({ name, L, a, b, source: 'csv' });
                            }
                        }
                        
                        if (colors.length === 0) {
                            console.error('No colors extracted from CSV. Processed', lines.length - 1, 'data rows');
                            throw new Error('No valid colors found in CSV file. Check console for details.');
                        }
                        
                        console.log('Successfully extracted', colors.length, 'colors from CSV');
                        
                        // Prompt for library name
                        let libraryName = file.name.replace(/\.csv$/i, '');
                        libraryName = prompt('Enter a name for the imported library:', libraryName);
                        if (!libraryName) {
                            statusEl.className = 'cmw-status';
                            return;
                        }
                        
                        // Create new library
                        const id = generateLibraryId(libraryName);
                        customLibraries[id] = { 
                            name: libraryName, 
                            colors: colors,
                            source: 'csv',
                            importedFrom: file.name,
                            importedAt: new Date().toISOString()
                        };
                        saveCustomLibraries();
                        updateLibrarySelector();
                        
                        // Select the new library
                        document.getElementById('cmw-custom-library-select').value = id;
                        selectLibrary(id);
                        
                        statusEl.textContent = `Imported "${libraryName}" with ${colors.length} colors from CSV`;
                        statusEl.className = 'cmw-status success show';
                        setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                        
                    } catch (e) {
                        console.error('CSV import error:', e);
                        statusEl.textContent = `CSV import failed: ${e.message}`;
                        statusEl.className = 'cmw-status error show';
                    }
                };
                
                reader.onerror = () => {
                    statusEl.textContent = 'Failed to read CSV file';
                    statusEl.className = 'cmw-status error show';
                };
                
                reader.readAsText(file);
            }
            
            // Custom library toggle
            const customLibraryToggle = document.getElementById('cmw-custom-library-toggle');
            const customLibraryContent = document.getElementById('cmw-custom-library-content');
            
            customLibraryToggle.addEventListener('click', () => {
                const isCollapsed = customLibraryToggle.classList.contains('collapsed');
                
                if (isCollapsed) {
                    customLibraryToggle.classList.remove('collapsed');
                    customLibraryContent.classList.remove('collapsed');
                } else {
                    customLibraryToggle.classList.add('collapsed');
                    customLibraryContent.classList.add('collapsed');
                }
            });
            
            // Library selector
            document.getElementById('cmw-custom-library-select').addEventListener('change', (e) => {
                selectLibrary(e.target.value);
            });
            
            // Create library button
            document.getElementById('cmw-create-library-btn').addEventListener('click', createNewLibrary);
            document.getElementById('cmw-new-library-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') createNewLibrary();
            });
            
            // Delete library button
            document.getElementById('cmw-delete-library-btn').addEventListener('click', deleteCurrentLibrary);
            
            // Custom library format selector
            document.getElementById('cmw-custom-format').addEventListener('change', (e) => {
                const format = e.target.value;
                document.getElementById('cmw-custom-hex-inputs').classList.remove('active');
                document.getElementById('cmw-custom-lab-inputs').classList.remove('active');
                document.getElementById('cmw-custom-rgb-inputs').classList.remove('active');
                document.getElementById('cmw-custom-cmyk-inputs').classList.remove('active');
                document.getElementById(`cmw-custom-${format}-inputs`).classList.add('active');
                // Update swatch preview
                updateCustomPreviewSwatch();
            });
            
            // Update the custom library preview swatch as user types
            async function updateCustomPreviewSwatch() {
                const format = document.getElementById('cmw-custom-format').value;
                const swatch = document.getElementById('cmw-custom-preview-swatch');
                let hexColor = '#f0f0f0'; // Default gray
                
                try {
                    if (format === 'hex') {
                        const hex = document.getElementById('cmw-custom-hex').value.trim();
                        if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                            hexColor = '#' + hex;
                        }
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById('cmw-custom-lab-l').value);
                        const a = parseFloat(document.getElementById('cmw-custom-lab-a').value);
                        const b = parseFloat(document.getElementById('cmw-custom-lab-b').value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            hexColor = lab2rgb(L, a, b);
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById('cmw-custom-rgb-r').value);
                        const g = parseInt(document.getElementById('cmw-custom-rgb-g').value);
                        const b = parseInt(document.getElementById('cmw-custom-rgb-b').value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            hexColor = `rgb(${r}, ${g}, ${b})`;
                        }
                    } else if (format === 'cmyk') {
                        // Use LittleCMS API for accurate CMYK → Lab → RGB conversion
                        const c = parseFloat(document.getElementById('cmw-custom-cmyk-c').value);
                        const m = parseFloat(document.getElementById('cmw-custom-cmyk-m').value);
                        const y = parseFloat(document.getElementById('cmw-custom-cmyk-y').value);
                        const k = parseFloat(document.getElementById('cmw-custom-cmyk-k').value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            try {
                                // CMYK → Lab via LittleCMS with GRACoL profile
                                const data = await convertColor({
                                    cmyk: [c, m, y, k],
                                    profile: 'GRACoL2013.icc'
                                });
                                if (data && data.lab) {
                                    hexColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                                }
                            } catch (e) {
                                console.error('CMYK preview conversion failed:', e);
                            }
                        }
                    }
                } catch (e) {
                    // Keep default gray on error
                }
                
                swatch.style.background = hexColor;
            }
            
            // Add input event listeners for live custom swatch preview
            document.getElementById('cmw-custom-hex').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-lab-l').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-lab-a').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-lab-b').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-rgb-r').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-rgb-g').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-rgb-b').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-c').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-m').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-y').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-k').addEventListener('input', updateCustomPreviewSwatch);
            
            // Add color button
            document.getElementById('cmw-custom-add-btn').addEventListener('click', addCustomColor);
            
            // Export/Import buttons
            document.getElementById('cmw-custom-export-btn').addEventListener('click', exportCurrentLibrary);
            document.getElementById('cmw-custom-import-btn').addEventListener('click', () => {
                document.getElementById('cmw-custom-import-file').click();
            });
            document.getElementById('cmw-custom-import-file').addEventListener('change', async (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const ext = file.name.split('.').pop().toLowerCase();
                    
                    if (ext === 'json') {
                        // Check if it's a filament colors JSON
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            try {
                                const jsonContent = JSON.parse(e.target.result);
                                // Detect filament colors format
                                if (jsonContent.metadata && jsonContent.swatches && Array.isArray(jsonContent.swatches)) {
                                    // It's a filament colors JSON - use API import
                                    await importFilamentColorsLibrary(file);
                                } else {
                                    // Regular JSON import
                                    importLibrary(file);
                                }
                            } catch (err) {
                                console.error('Error detecting JSON format:', err);
                                importLibrary(file); // Fallback to regular import
                            }
                        };
                        reader.readAsText(file);
                    } else if (ext === 'cxf') {
                        importCxfLibrary(file);
                    } else if (ext === 'csv') {
                        importCsvLibrary(file);
                    } else if (ext === 'ase') {
                        importAseLibrary(file);
                    } else {
                        const statusEl = document.getElementById('cmw-custom-status');
                        statusEl.textContent = 'Unsupported file format. Use JSON, CXF, CSV, or ASE.';
                        statusEl.className = 'cmw-status error show';
                        setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
                    }
                    e.target.value = '';
                }
            });
            
            // Remove color button delegation
            document.getElementById('cmw-custom-library-list').addEventListener('click', (e) => {
                if (e.target.classList.contains('cmw-custom-color-remove')) {
                    removeCustomColor(parseInt(e.target.dataset.index));
                }
            });
            
            // Enter key support
            document.getElementById('cmw-custom-color-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCustomColor();
            });
            document.getElementById('cmw-custom-hex').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCustomColor();
            });
            
            // Load custom libraries on init
            loadCustomLibraries();

            /* ─────────────────────
               Color Info Modal
               ───────────────────── */
            
            const colorModal = {
                overlay: document.getElementById('cmw-color-modal-overlay'),
                swatch: document.getElementById('cmw-color-modal-swatch'),
                name: document.getElementById('cmw-color-modal-name'),
                lab: document.getElementById('cmw-modal-lab'),
                hex: document.getElementById('cmw-modal-hex'),
                rgb: document.getElementById('cmw-modal-rgb'),
                cmyk: document.getElementById('cmw-modal-cmyk'),
                closeBtn: document.getElementById('cmw-color-modal-close'),
                purchaseLinks: document.getElementById('cmw-modal-purchase-links'),
                amazonLink: document.getElementById('cmw-modal-amazon-link'),
                manufacturerLink: document.getElementById('cmw-modal-manufacturer-link'),
                currentColor: null
            };
            
            // Show the color modal with LittleCMS API conversion
            // If originalHex is provided, it will be displayed as the hex value (for user-entered hex)
            async function showColorModal(colorData) {
                const { name, L, a, b, originalHex, libraryName, amazon_link, manufacturer_link } = colorData;
                
                // Format the display name based on library
                let displayName = name || 'Color';
                if (libraryName) {
                    // Check if this is a Pantone/PMS color
                    if (libraryName === 'PMS' || libraryName.toLowerCase() === 'pantone') {
                        // For Pantone, format as "Pantone # C" (extract just the number/code part)
                        const pmsMatch = displayName.match(/^(?:PMS|Pantone)\s*(.+)$/i);
                        if (pmsMatch) {
                            displayName = `Pantone ${pmsMatch[1]}`;
                        } else {
                            displayName = `Pantone ${displayName}`;
                        }
                    } else {
                        // For other libraries, prepend library name
                        displayName = `${libraryName} ${displayName}`;
                    }
                }
                
                // Store Lab values for adding to library
                colorModal.currentLabValues = { L, a, b };
                
                // Reset the add to library section when opening modal
                const modalAddContent = document.getElementById('cmw-modal-add-content');
                const modalAddToggle = document.getElementById('cmw-modal-add-toggle');
                if (modalAddContent) modalAddContent.style.display = 'none';
                if (modalAddToggle) modalAddToggle.querySelector('span').textContent = '+ Add to Library';
                const modalAddStatus = document.getElementById('cmw-modal-add-status');
                if (modalAddStatus) modalAddStatus.className = 'cmw-modal-add-status';
                
                // Fetch LittleCMS conversions BEFORE showing modal to prevent flicker
                try {
                    const apiUrl = getApiBaseUrl();
                    const currentIntent = document.getElementById('cmw-default-intent')?.value || '1';
                    const renderingIntent = currentIntent !== 'none' ? parseInt(currentIntent) : 1;
                    
                    // Make two API calls: one for RGB (sRGB.icc) and one for CMYK (GRACoL2013.icc)
                    const [srgbResponse, cmykResponse] = await Promise.all([
                        fetch(`${apiUrl}/convert`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                lab: [L, a, b],
                                profile: 'sRGB.icc',
                                renderingIntent: renderingIntent
                            })
                        }),
                        fetch(`${apiUrl}/convert`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                lab: [L, a, b],
                                profile: 'GRACoL2013.icc',
                                renderingIntent: renderingIntent
                            })
                        })
                    ]);
                    
                    if (!srgbResponse.ok) {
                        throw new Error(`API error (sRGB): ${srgbResponse.status}`);
                    }
                    
                    const srgbData = await srgbResponse.json();
                    const cmykData = cmykResponse.ok ? await cmykResponse.json() : null;
                    console.log('LittleCMS color conversion (sRGB):', srgbData);
                    console.log('LittleCMS color conversion (CMYK):', cmykData);
                    
                    // Extract values from API response
                    let hexValue = '#000000';
                    let rgbValues = { r: 0, g: 0, b: 0 };
                    let cmykValues = { c: 0, m: 0, y: 0, k: 100 };
                    
                    // Get RGB from sRGB API response
                    if (srgbData.rgb && Array.isArray(srgbData.rgb)) {
                        rgbValues = {
                            r: Math.round(srgbData.rgb[0]),
                            g: Math.round(srgbData.rgb[1]),
                            b: Math.round(srgbData.rgb[2])
                        };
                    }
                    
                    // Get Hex from sRGB API
                    if (srgbData.hex) {
                        hexValue = srgbData.hex.toUpperCase();
                        if (!hexValue.startsWith('#')) hexValue = '#' + hexValue;
                    } else {
                        // Build from RGB if no hex provided
                        hexValue = `#${rgbValues.r.toString(16).padStart(2, '0')}${rgbValues.g.toString(16).padStart(2, '0')}${rgbValues.b.toString(16).padStart(2, '0')}`.toUpperCase();
                    }
                    
                    // Get CMYK from GRACoL2013 API response
                    if (cmykData && cmykData.gamut && cmykData.gamut.cmykEquivalent && Array.isArray(cmykData.gamut.cmykEquivalent)) {
                        const cmyk = cmykData.gamut.cmykEquivalent;
                        cmykValues = {
                            c: parseFloat(cmyk[0].toFixed(1)),
                            m: parseFloat(cmyk[1].toFixed(1)),
                            y: parseFloat(cmyk[2].toFixed(1)),
                            k: parseFloat(cmyk[3].toFixed(1))
                        };
                    } else if (cmykData && cmykData.cmyk && Array.isArray(cmykData.cmyk)) {
                        // Fallback to direct cmyk field if present
                        cmykValues = {
                            c: parseFloat(cmykData.cmyk[0].toFixed(1)),
                            m: parseFloat(cmykData.cmyk[1].toFixed(1)),
                            y: parseFloat(cmykData.cmyk[2].toFixed(1)),
                            k: parseFloat(cmykData.cmyk[3].toFixed(1))
                        };
                    }
                    
                    // Use original hex if provided (user entered it), otherwise use API hex
                    let displayHex = originalHex ? originalHex.toUpperCase() : hexValue;
                    if (!displayHex.startsWith('#')) {
                        displayHex = '#' + displayHex;
                    }
                    
                    // Store all color values
                    colorModal.currentColor = {
                        lab: `${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}`,
                        hex: displayHex,
                        rgb: `${rgbValues.r}, ${rgbValues.g}, ${rgbValues.b}`,
                        cmyk: `${cmykValues.c}, ${cmykValues.m}, ${cmykValues.y}, ${cmykValues.k}`
                    };
                    
                    // NOW show the modal with all data ready - no flicker
                    colorModal.swatch.style.background = displayHex;
                    colorModal.name.textContent = displayName;
                    colorModal.lab.textContent = colorModal.currentColor.lab;
                    colorModal.hex.textContent = colorModal.currentColor.hex;
                    colorModal.rgb.textContent = colorModal.currentColor.rgb;
                    colorModal.cmyk.textContent = colorModal.currentColor.cmyk;
                    
                    // Handle purchase links
                    if (amazon_link || manufacturer_link) {
                        colorModal.purchaseLinks.style.display = 'flex';
                        
                        if (amazon_link) {
                            colorModal.amazonLink.href = amazon_link;
                            colorModal.amazonLink.style.display = 'inline-block';
                        } else {
                            colorModal.amazonLink.style.display = 'none';
                        }
                        
                        if (manufacturer_link) {
                            colorModal.manufacturerLink.href = manufacturer_link;
                            colorModal.manufacturerLink.style.display = 'inline-block';
                        } else {
                            colorModal.manufacturerLink.style.display = 'none';
                        }
                    } else {
                        colorModal.purchaseLinks.style.display = 'none';
                    }
                    
                    colorModal.overlay.classList.add('show');
                    document.body.style.overflow = 'hidden';
                    
                } catch (error) {
                    console.error('LittleCMS conversion failed:', error);
                    // Show modal with error state - no fallback to local JS conversion
                    colorModal.swatch.style.background = originalHex || '#f0f0f0';
                    colorModal.name.textContent = displayName;
                    colorModal.lab.textContent = `${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}`;
                    colorModal.hex.textContent = 'LittleCMS API Error';
                    colorModal.rgb.textContent = 'LittleCMS API Error';
                    colorModal.cmyk.textContent = 'LittleCMS API Error';
                    
                    colorModal.currentColor = {
                        lab: `${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}`,
                        hex: '',
                        rgb: '',
                        cmyk: ''
                    };
                    
                    // Hide purchase links on error
                    colorModal.purchaseLinks.style.display = 'none';
                    
                    colorModal.overlay.classList.add('show');
                    document.body.style.overflow = 'hidden';
                }
            }
            
            // Hide the color modal
            function hideColorModal() {
                colorModal.overlay.classList.remove('show');
                document.body.style.overflow = '';
            }
            
            // Copy value to clipboard
            function copyColorValue(type) {
                if (!colorModal.currentColor) return;
                
                let textToCopy = colorModal.currentColor[type];
                if (type === 'lab') textToCopy = `Lab(${textToCopy})`;
                if (type === 'rgb') textToCopy = `RGB(${textToCopy})`;
                if (type === 'cmyk') textToCopy = `CMYK(${textToCopy})`;
                
                navigator.clipboard.writeText(textToCopy).then(() => {
                    // Visual feedback
                    const row = document.querySelector(`.cmw-color-value-row[data-type="${type}"]`);
                    row.classList.add('cmw-color-copied');
                    setTimeout(() => row.classList.remove('cmw-color-copied'), 500);
                });
            }
            
            // Event listeners for modal
            colorModal.closeBtn.addEventListener('click', hideColorModal);
            colorModal.overlay.addEventListener('click', (e) => {
                if (e.target === colorModal.overlay) hideColorModal();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && colorModal.overlay.classList.contains('show')) {
                    hideColorModal();
                }
            });
            
            // Copy on click
            document.querySelectorAll('.cmw-color-value-row').forEach(row => {
                row.addEventListener('click', () => {
                    copyColorValue(row.dataset.type);
                });
            });
            
            // Modal Add to Library functionality
            const modalAddToggle = document.getElementById('cmw-modal-add-toggle');
            const modalAddContent = document.getElementById('cmw-modal-add-content');
            const modalLibrarySelect = document.getElementById('cmw-modal-library-select');
            const modalNewLibBtn = document.getElementById('cmw-modal-new-lib-btn');
            const modalNewLibRow = document.getElementById('cmw-modal-new-lib-row');
            const modalNewLibName = document.getElementById('cmw-modal-new-lib-name');
            const modalCreateLibBtn = document.getElementById('cmw-modal-create-lib-btn');
            const modalColorName = document.getElementById('cmw-modal-color-name');
            const modalAddBtn = document.getElementById('cmw-modal-add-btn');
            const modalAddStatus = document.getElementById('cmw-modal-add-status');
            
            // Toggle add to library section
            modalAddToggle.addEventListener('click', () => {
                const isHidden = modalAddContent.style.display === 'none';
                modalAddContent.style.display = isHidden ? 'flex' : 'none';
                modalAddToggle.querySelector('span').textContent = isHidden ? '− Add to Library' : '+ Add to Library';
                
                if (isHidden) {
                    // Populate library dropdown
                    updateModalLibraryDropdown();
                    // Pre-fill color name from modal title
                    const currentName = colorModal.name.textContent;
                    if (currentName && currentName !== 'Color' && currentName !== 'Current Color' && currentName !== 'Selected Color') {
                        modalColorName.value = currentName;
                    }
                }
            });
            
            // Update library dropdown in modal
            function updateModalLibraryDropdown() {
                modalLibrarySelect.innerHTML = '<option value="">-- Select Library --</option>';
                
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${lib.name} (${lib.colors?.length || 0})`;
                    modalLibrarySelect.appendChild(option);
                });
                
                // If there are no libraries, show the new library row
                if (Object.keys(customLibraries).length === 0) {
                    modalNewLibRow.style.display = 'flex';
                    modalNewLibBtn.style.display = 'none';
                }
            }
            
            // Toggle new library input
            modalNewLibBtn.addEventListener('click', () => {
                const isHidden = modalNewLibRow.style.display === 'none';
                modalNewLibRow.style.display = isHidden ? 'flex' : 'none';
                if (isHidden) {
                    modalNewLibName.focus();
                }
            });
            
            // Create new library from modal
            modalCreateLibBtn.addEventListener('click', () => {
                const name = modalNewLibName.value.trim();
                if (!name) {
                    showModalStatus('Please enter a library name', 'error');
                    return;
                }
                
                // Check for duplicate names
                const exists = Object.values(customLibraries).some(lib => 
                    lib.name.toLowerCase() === name.toLowerCase()
                );
                
                if (exists) {
                    showModalStatus('Library name already exists', 'error');
                    return;
                }
                
                // Create the library
                const id = generateLibraryId(name);
                customLibraries[id] = { name, colors: [] };
                saveCustomLibraries();
                
                // Update dropdowns
                updateModalLibraryDropdown();
                updateLibrarySelector();
                
                // Select the new library
                modalLibrarySelect.value = id;
                modalNewLibRow.style.display = 'none';
                modalNewLibName.value = '';
                modalNewLibBtn.style.display = 'block';
                
                showModalStatus(`Created "${name}"`, 'success');
            });
            
            // Enter key for new library name
            modalNewLibName.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    modalCreateLibBtn.click();
                }
            });
            
            // Add color to library from modal
            modalAddBtn.addEventListener('click', () => {
                const libraryId = modalLibrarySelect.value;
                if (!libraryId) {
                    showModalStatus('Please select a library', 'error');
                    return;
                }
                
                if (!colorModal.currentLabValues) {
                    showModalStatus('No color data available', 'error');
                    return;
                }
                
                const { L, a, b } = colorModal.currentLabValues;
                let colorName = modalColorName.value.trim();
                
                // Generate a default name if none provided
                if (!colorName) {
                    colorName = colorModal.currentColor.hex || `Color ${Date.now()}`;
                }
                
                // Add to library
                customLibraries[libraryId].colors.push({
                    name: colorName,
                    L: L,
                    a: a,
                    b: b
                });
                
                saveCustomLibraries();
                updateLibrarySelector();
                
                // If this library is currently selected in the main UI, refresh it
                if (currentCustomLibraryId === libraryId) {
                    renderCurrentLibraryColors();
                }
                
                const libName = customLibraries[libraryId].name;
                showModalStatus(`Added "${colorName}" to ${libName}`, 'success');
                
                // Clear the color name input for next add
                modalColorName.value = '';
            });
            
            // Show status message in modal
            function showModalStatus(message, type) {
                modalAddStatus.textContent = message;
                modalAddStatus.className = `cmw-modal-add-status ${type}`;
                setTimeout(() => {
                    modalAddStatus.className = 'cmw-modal-add-status';
                }, 3000);
            }
            
            // Delegate click events for all swatches (results table, custom library, etc.)
            document.addEventListener('click', (e) => {
                // Check for main color search preview swatch
                const mainPreview = e.target.closest('#cmw-color-preview');
                if (mainPreview) {
                    // Get Lab values from the preview's dataset or current color data
                    const L = parseFloat(mainPreview.dataset.selectedL);
                    const a = parseFloat(mainPreview.dataset.selectedA);
                    const b = parseFloat(mainPreview.dataset.selectedB);
                    const name = mainPreview.dataset.selectedName || 'Selected Color';
                    const libraryName = mainPreview.dataset.selectedLibrary || '';
                    
                    if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                        // Library color selected - pass all metadata including purchase links
                        showColorModal({ 
                            name, 
                            libraryName, 
                            L, 
                            a, 
                            b,
                            amazon_link: mainPreview.dataset.amazonLink,
                            manufacturer_link: mainPreview.dataset.manufacturerLink
                        });
                    } else if (currentColorData && currentColorData.L !== undefined) {
                        // User entered a value (hex, Lab, RGB, CMYK)
                        // Only pass originalHex if user typed a hex directly
                        const originalHexInput = mainPreview.dataset.originalHexInput;
                        
                        showColorModal({
                            name: 'Current Color',
                            L: currentColorData.L,
                            a: currentColorData.a,
                            b: currentColorData.b,
                            originalHex: originalHexInput || null // Only set if user typed hex
                        });
                    }
                    return;
                }
                
                // Check for result table rows - read data from row dataset
                const tableRow = e.target.closest('#cmw-out tbody tr');
                if (tableRow && tableRow.dataset.colorL) {
                    showColorModal({
                        name: tableRow.dataset.colorName,
                        L: parseFloat(tableRow.dataset.colorL),
                        a: parseFloat(tableRow.dataset.colorA),
                        b: parseFloat(tableRow.dataset.colorB),
                        libraryName: tableRow.dataset.libraryName,
                        amazon_link: tableRow.dataset.amazonLink,
                        manufacturer_link: tableRow.dataset.manufacturerLink,
                        originalHex: tableRow.dataset.hex,
                        manufacturer: tableRow.dataset.manufacturer,
                        filament_type: tableRow.dataset.filamentType
                    });
                    return;
                }
                
                // Check for consensus swatch
                const consensusSwatch = e.target.closest('#cmw-consensus-swatch');
                if (consensusSwatch) {
                    const labText = document.getElementById('cmw-consensus-lab').textContent;
                    const labMatch = labText.match(/Lab\(([\d.-]+)\s*,\s*([\d.-]+)\s*,\s*([\d.-]+)\)/);
                    if (labMatch) {
                        showColorModal({
                            name: 'Consensus Color',
                            L: parseFloat(labMatch[1]),
                            a: parseFloat(labMatch[2]),
                            b: parseFloat(labMatch[3])
                        });
                    }
                    return;
                }
                
                // Check for intent swatches
                const intentSwatch = e.target.closest('.cmw-intent-swatch');
                if (intentSwatch) {
                    const card = intentSwatch.closest('.cmw-intent-card');
                    if (card) {
                        const labEl = card.querySelector('.cmw-intent-lab');
                        const nameEl = card.querySelector('.cmw-intent-name');
                        // Get the LittleCMS hex stored when the swatch was displayed
                        const lcmsHex = intentSwatch.dataset.lcmsHex || null;
                        if (labEl && nameEl) {
                            const labText = labEl.textContent;
                            const labMatch = labText.match(/Lab\(([\d.-]+)\s*,\s*([\d.-]+)\s*,\s*([\d.-]+)\)/);
                            if (labMatch) {
                                showColorModal({
                                    name: nameEl.textContent,
                                    L: parseFloat(labMatch[1]),
                                    a: parseFloat(labMatch[2]),
                                    b: parseFloat(labMatch[3]),
                                    originalHex: lcmsHex // Use stored LittleCMS hex for consistency
                                });
                            }
                        }
                    }
                    return;
                }
                
                // Check for harmony swatches
                const harmonySwatch = e.target.closest('.cmw-harmony-swatch');
                if (harmonySwatch) {
                    const labL = parseFloat(harmonySwatch.dataset.labL);
                    const labA = parseFloat(harmonySwatch.dataset.labA);
                    const labB = parseFloat(harmonySwatch.dataset.labB);
                    const colorName = harmonySwatch.dataset.colorName || 'Harmony Color';
                    const libraryName = harmonySwatch.dataset.libraryName || '';
                    // Use the LittleCMS hex value stored when the harmony was displayed
                    const lcmsHex = harmonySwatch.dataset.lcmsHex || null;
                    
                    if (!isNaN(labL) && !isNaN(labA) && !isNaN(labB)) {
                        showColorModal({
                            name: colorName,
                            libraryName: libraryName,
                            L: labL,
                            a: labA,
                            b: labB,
                            originalHex: lcmsHex // Pass the LittleCMS hex to ensure consistency
                        });
                    }
                    return;
                }
                
                // Check for sample preview swatch (the input preview)
                const samplePreviewSwatch = e.target.closest('#cmw-sample-preview-swatch');
                if (samplePreviewSwatch) {
                    const format = document.getElementById('cmw-sample-format').value;
                    
                    // Use async IIFE to allow await for LittleCMS API calls
                    (async () => {
                        let L, a, b;
                        let originalHex = null;
                        
                        try {
                            if (format === 'hex') {
                                const hex = document.getElementById('cmw-sample-hex').value.trim();
                                if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                                    originalHex = '#' + hex.toUpperCase();
                                    const rgb = hex2rgb(hex);
                                    if (rgb) {
                                        // Use LittleCMS API for hex → Lab conversion
                                        const data = await convertColor({
                                            rgb: [rgb.r, rgb.g, rgb.b],
                                            profile: 'sRGB.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    }
                                }
                            } else if (format === 'lab') {
                                L = parseFloat(document.getElementById('cmw-sample-lab-l').value);
                                a = parseFloat(document.getElementById('cmw-sample-lab-a').value);
                                b = parseFloat(document.getElementById('cmw-sample-lab-b').value);
                            } else if (format === 'rgb') {
                                const r = parseInt(document.getElementById('cmw-sample-rgb-r').value);
                                const g = parseInt(document.getElementById('cmw-sample-rgb-g').value);
                                const bVal = parseInt(document.getElementById('cmw-sample-rgb-b').value);
                                if (!isNaN(r) && !isNaN(g) && !isNaN(bVal)) {
                                    // Use LittleCMS API for RGB → Lab conversion
                                    const data = await convertColor({
                                        rgb: [r, g, bVal],
                                        profile: 'sRGB.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            } else if (format === 'cmyk') {
                                const c = parseFloat(document.getElementById('cmw-sample-cmyk-c').value);
                                const m = parseFloat(document.getElementById('cmw-sample-cmyk-m').value);
                                const y = parseFloat(document.getElementById('cmw-sample-cmyk-y').value);
                                const k = parseFloat(document.getElementById('cmw-sample-cmyk-k').value);
                                if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                                    // Use LittleCMS API for CMYK → Lab conversion
                                    const data = await convertColor({
                                        cmyk: [c, m, y, k],
                                        profile: 'GRACoL2013.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            }
                            
                            if (L !== undefined && !isNaN(L)) {
                                const label = document.getElementById('cmw-sample-label').value.trim();
                                showColorModal({
                                    name: label || 'Preview Color',
                                    L: L,
                                    a: a,
                                    b: b,
                                    originalHex: originalHex
                                });
                            }
                        } catch (err) {
                            console.error('Failed to convert preview color for modal:', err);
                        }
                    })();
                    return;
                }
                
                // Check for custom library preview swatch
                const customPreviewSwatch = e.target.closest('#cmw-custom-preview-swatch');
                if (customPreviewSwatch) {
                    const format = document.getElementById('cmw-custom-format').value;
                    
                    // Use async IIFE to allow await for LittleCMS API calls
                    (async () => {
                        let L, a, b;
                        let originalHex = null;
                        
                        try {
                            if (format === 'hex') {
                                const hex = document.getElementById('cmw-custom-hex').value.trim();
                                if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                                    originalHex = '#' + hex.toUpperCase();
                                    const rgb = hex2rgb(hex);
                                    if (rgb) {
                                        // Use LittleCMS API for hex → Lab conversion
                                        const data = await convertColor({
                                            rgb: [rgb.r, rgb.g, rgb.b],
                                            profile: 'sRGB.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    }
                                }
                            } else if (format === 'lab') {
                                L = parseFloat(document.getElementById('cmw-custom-lab-l').value);
                                a = parseFloat(document.getElementById('cmw-custom-lab-a').value);
                                b = parseFloat(document.getElementById('cmw-custom-lab-b').value);
                            } else if (format === 'rgb') {
                                const r = parseInt(document.getElementById('cmw-custom-rgb-r').value);
                                const g = parseInt(document.getElementById('cmw-custom-rgb-g').value);
                                const bVal = parseInt(document.getElementById('cmw-custom-rgb-b').value);
                                if (!isNaN(r) && !isNaN(g) && !isNaN(bVal)) {
                                    // Use LittleCMS API for RGB → Lab conversion
                                    const data = await convertColor({
                                        rgb: [r, g, bVal],
                                        profile: 'sRGB.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            } else if (format === 'cmyk') {
                                const c = parseFloat(document.getElementById('cmw-custom-cmyk-c').value);
                                const m = parseFloat(document.getElementById('cmw-custom-cmyk-m').value);
                                const y = parseFloat(document.getElementById('cmw-custom-cmyk-y').value);
                                const k = parseFloat(document.getElementById('cmw-custom-cmyk-k').value);
                                if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                                    // Use LittleCMS API for CMYK → Lab conversion
                                    const data = await convertColor({
                                        cmyk: [c, m, y, k],
                                        profile: 'GRACoL2013.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            }
                            
                            if (L !== undefined && !isNaN(L)) {
                                const colorName = document.getElementById('cmw-custom-color-name').value.trim();
                                showColorModal({
                                    name: colorName || 'Preview Color',
                                    L: L,
                                    a: a,
                                    b: b,
                                    originalHex: originalHex
                                });
                            }
                        } catch (err) {
                            console.error('Failed to convert custom preview color for modal:', err);
                        }
                    })();
                    return;
                }
                
                // Check for sample swatches in consensus section
                const sampleSwatch = e.target.closest('.cmw-sample-swatch');
                if (sampleSwatch) {
                    const row = sampleSwatch.closest('.cmw-sample-row');
                    if (row) {
                        const sampleId = parseInt(row.dataset.sampleId);
                        const sample = consensusSamples.find(s => s.id === sampleId);
                        const sampleIndex = consensusSamples.findIndex(s => s.id === sampleId);
                        if (sample) {
                            // Use normalizedLab if available (from API after calculation)
                            // This ensures consistency with what's displayed
                            if (sample.normalizedLab && Array.isArray(sample.normalizedLab)) {
                                const originalHex = sample.format === 'hex' ? sample.value : null;
                                showColorModal({
                                    name: sample.label || `Sample ${sampleIndex + 1}`,
                                    L: sample.normalizedLab[0],
                                    a: sample.normalizedLab[1],
                                    b: sample.normalizedLab[2],
                                    originalHex: originalHex
                                });
                                return;
                            }
                            
                            // If no normalizedLab, use LittleCMS API for conversion
                            (async () => {
                                let L, a, b;
                                let originalHex = null;
                                
                                try {
                                    if (sample.format === 'lab') {
                                        // Lab is stored as array [L, a, b]
                                        L = sample.value[0];
                                        a = sample.value[1];
                                        b = sample.value[2];
                                    } else if (sample.format === 'hex') {
                                        // Use LittleCMS API for hex → Lab conversion
                                        originalHex = sample.value;
                                        const rgb = hex2rgb(sample.value);
                                        if (rgb) {
                                            const data = await convertColor({
                                                rgb: [rgb.r, rgb.g, rgb.b],
                                                profile: 'sRGB.icc'
                                            });
                                            L = data.lab[0];
                                            a = data.lab[1];
                                            b = data.lab[2];
                                        }
                                    } else if (sample.format === 'rgb') {
                                        // Use LittleCMS API for RGB → Lab conversion
                                        const data = await convertColor({
                                            rgb: sample.value,
                                            profile: 'sRGB.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    } else if (sample.format === 'cmyk') {
                                        // Use LittleCMS API for CMYK → Lab conversion
                                        const data = await convertColor({
                                            cmyk: sample.value,
                                            profile: 'GRACoL2013.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    }
                                    
                                    if (L !== undefined) {
                                        showColorModal({
                                            name: sample.label || `Sample ${sampleIndex + 1}`,
                                            L: L,
                                            a: a,
                                            b: b,
                                            originalHex: originalHex
                                        });
                                    }
                                } catch (err) {
                                    console.error('Failed to convert sample color for modal:', err);
                                }
                            })();
                        }
                    }
                    return;
                }
            });
        })();
    </script>
</body>
</html>
