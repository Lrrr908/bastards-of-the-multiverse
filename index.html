<!DOCTYPE html>
<!--
===============================================================================
                    COLOR MANAGEMENT SYSTEM - HARD RULES
===============================================================================

All color libraries are based on real, physical materials scanned with a
spectrophotometer. Those scans describe how a color looks in real life under
standard lighting (D50), not how it looks on a phone or monitor.

CANONICAL FORMAT: ICC PCS Lab (D50)
───────────────────────────────────
Lab(D50) in this system represents ICC Profile Connection Space (PCS) Lab,
not generic Lab. This is the industry standard used by:
  • ICC color profiles (v2 and v4)
  • Spectrophotometer manufacturers (X-Rite, Datacolor, etc.)
  • Print industry workflows (GRACoL, SWOP, Fogra)
  • Adobe applications (Photoshop, Illustrator)

Every color in the system must ultimately live in Lab(D50) / ICC PCS Lab.

HARD RULES (NEVER VIOLATE):
───────────────────────────
❌ NEVER compare Lab(D65) to Lab(D50) - illuminants must match for valid ΔE
❌ NEVER store RGB or HEX as truth - these are display approximations only  
❌ NEVER do ΔE calculations outside Lab(D50) - results will be wrong
✔  ALWAYS convert to Lab(D50) before any matching, ranking, averaging, or ΔE

PIPELINE:
─────────
• Spectro scans      → Spectral reflectance → XYZ(D50) → Lab(D50) [see below]
• User HEX/RGB input → sRGB(D65) → XYZ(D65) → CAT16 → XYZ(D50) → Lab(D50)
• Screen display     → Lab(D50) → XYZ(D50) → CAT16 → XYZ(D65) → sRGB (preview only)
• CMYK input/output  → LittleCMS + GRACoL2013.icc (ICC PCS Lab as connection space)
• All matching logic → Happens in Lab(D50)

SPECTRAL REFLECTANCE → Lab(D50) CONVERSION:
────────────────────────────────────────────
For colors with spectral data (400-700nm at 10nm intervals, 31 data points):

Step 1: Calculate XYZ tristimulus values
  X = Σ[R(λ) × D50(λ) × x̄(λ) × Δλ]
  Y = Σ[R(λ) × D50(λ) × ȳ(λ) × Δλ]
  Z = Σ[R(λ) × D50(λ) × z̄(λ) × Δλ]
  
  Where:
  • R(λ)   = Spectral reflectance (0-100%) at wavelength λ
  • D50(λ) = CIE D50 Standard Illuminant SPD
  • x̄(λ), ȳ(λ), z̄(λ) = CIE 1931 2° Standard Observer color matching functions
  • Δλ     = 10nm (wavelength interval)

Step 2: Normalize to Y=100 (standard white point)
  k = 100 / Yn  where  Yn = Σ[D50(λ) × ȳ(λ) × Δλ]
  X = X × k,  Y = Y × k,  Z = Z × k
  Xn = 96.422,  Yn = 100.0,  Zn = 82.521  (D50 white point)

Step 3: Convert XYZ to Lab
  f(t) = t^(1/3)                    if t > (6/29)³
       = t / (3×(6/29)²) + 4/29     otherwise
  
  L* = 116 × f(Y/Yn) - 16
  a* = 500 × [f(X/Xn) - f(Y/Yn)]
  b* = 200 × [f(Y/Yn) - f(Z/Zn)]

Step 4: Apply 3rd order polynomial correction to match X-Rite M1 measurements
  Features = [1, L, a, b, L², La, Lb, a², ab, b², L³, L²a, L²b, La², Lab, Lb², a³, a²b, ab², b³]
  
  L*_corrected = Σ(coef_L[i] × Features[i])  [20 coefficients]
  a*_corrected = Σ(coef_a[i] × Features[i])  [20 coefficients]
  b*_corrected = Σ(coef_b[i] × Features[i])  [20 coefficients]
  
  Trained on 1,755 Pantone C colors:
  • Average ΔE:  0.481  (professional-grade accuracy)
  • ΔE < 1.0:    88.8%  (imperceptible to human eye)
  • ΔE < 2.0:    99.4%  (excellent for print production)
  • Max ΔE:      2.310  (even worst case is acceptable)

Why polynomial correction?
  Raw XYZ→Lab calculation produces systematic errors that vary by:
  • Lightness (dark vs light colors have different error patterns)
  • Chroma (saturated colors need different corrections than muted)
  • Hue (blues behave differently than reds/greens)
  
  3rd order polynomial captures these non-linear relationships and
  cross-channel interactions (e.g., correction for a* depends on L* and b*)
  
  This achieves 4.4x better accuracy than simple linear regression,
  matching X-Rite's proprietary M1 measurement algorithm within 0.5 ΔE average.

CHROMATIC ADAPTATION:
─────────────────────
• RGB ↔ Lab: CAT16 (CIE 2016) - better for blues and extreme saturations
• CMYK ↔ Lab: LittleCMS with ICC profile internal adaptation (preserves PCS)

RENDERING INTENTS:
──────────────────
This system supports ICC rendering intents for Lab → CMYK conversions:
  • 0 = Perceptual      - Compresses gamut, preserves relationships (photos)
  • 1 = Relative        - Maps white point, clips out-of-gamut (default, logos)
  • 2 = Saturation      - Maximizes saturation (business graphics)
  • 3 = Absolute        - No white point mapping (proofing)

⚠️  ΔE values WILL CHANGE across rendering intents - this is expected behavior.
    Different intents map out-of-gamut colors differently, resulting in
    different Lab values after the Lab → CMYK → Lab roundtrip.

WHAT WE ARE NOT DOING:
──────────────────────
• We are NOT trying to make the screen match perfectly
• We are NOT trusting RGB as a measurement  
• We are NOT skipping white-point adaptation
• We are NOT mixing Lab(D65) and Lab(D50) in ΔE math

FUTURE CONSIDERATIONS (Optional):
─────────────────────────────────
• CAM02-UCS or CAM16-UCS could be explored for UI ranking experiments
  (perceptual uniformity improvements over CIEDE2000)
• These would be OPTIONAL and should NEVER replace Lab(D50) as storage
• Lab(D50) / ICC PCS Lab remains the canonical storage format

Think of it like this:
  Lab(D50) = real-world color truth (ICC PCS)
  RGB/HEX  = display approximation (best-effort preview only)
  CMYK     = device-dependent output (requires ICC profile)

===============================================================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Match Widget</title>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js" charset="utf-8"></script>
    <style>
        .cmw-wrap {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 600px;
            margin: 30px auto;
            padding: 0 20px;
            background: #ffffff;
        }

        .cmw-wrap h5 {
            font-size: 2.2rem;
            margin: 0 0 32px;
            font-weight: 800;
            color: #0065a3;
            text-align: center;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0, 101, 163, 0.1);
        }
        
        .cmw-search-icon {
            position: absolute;
            right: 10px;
            top: 10px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .cmw-search-icon svg {
            width: 100%;
            height: 100%;
            fill: none;
            stroke: #e2e8f0;
            stroke-width: 2.5;
            stroke-linecap: round;
            transition: stroke 0.3s ease;
        }
        
        .cmw-search-icon:hover svg,
        .cmw-search-icon.active svg {
            stroke: #0065a3;
        }
        
        /* Hamburger Menu Icon */
        .cmw-hamburger-icon {
            position: absolute;
            left: 10px;
            top: 10px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .cmw-hamburger-icon svg {
            width: 100%;
            height: 100%;
            fill: none;
            stroke: #e2e8f0;
            stroke-width: 2.5;
            stroke-linecap: round;
            transition: stroke 0.3s ease;
        }
        
        .cmw-hamburger-icon:hover svg,
        .cmw-hamburger-icon.active svg {
            stroke: #0065a3;
        }
        
        /* Hamburger Dropdown Menu */
        .cmw-hamburger-dropdown {
            position: absolute;
            left: 10px;
            top: 45px;
            width: 220px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .cmw-hamburger-dropdown.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .cmw-hamburger-menu-item {
            padding: 12px 16px;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .cmw-hamburger-menu-item:last-child {
            border-bottom: none;
        }
        
        .cmw-hamburger-menu-item:hover {
            background: #f9fafb;
            color: #0065a3;
        }
        
        .cmw-hamburger-menu-item.divider {
            height: 1px;
            background: #e2e8f0;
            padding: 0;
            margin: 4px 0;
            cursor: default;
        }
        
        .cmw-hamburger-menu-item.divider:hover {
            background: #e2e8f0;
        }
        
        .cmw-hamburger-menu-header {
            padding: 12px 16px;
            font-size: 12px;
            color: #9ca3af;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: #f9fafb;
            border-bottom: 1px solid #e2e8f0;
        }
        
        /* Toggle Switch */
        .cmw-switch input[type="checkbox"] {
            opacity: 0;
            width: 0;
            height: 0;
            position: absolute;
        }
        
        .cmw-switch input[type="checkbox"] + span {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #e2e8f0;
            transition: .3s;
            border-radius: 24px;
        }
        
        .cmw-switch input[type="checkbox"] + span:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        
        .cmw-switch input[type="checkbox"]:checked + span {
            background-color: #0065a3;
        }
        
        .cmw-switch input[type="checkbox"]:checked + span:before {
            transform: translateX(26px);
        }
        
        /* Preference Library Container (hidden) */
        #cmw-pref-libraries-container {
            display: none;
        }
        
        .cmw-search-input-container {
            position: absolute;
            right: 35px;
            top: 10px;
            width: 0;
            opacity: 0;
            overflow: hidden;
            transition: width 0.3s ease, opacity 0.3s ease;
            z-index: 10;
        }
        
        .cmw-search-input-container.active {
            width: 200px;
            opacity: 1;
        }
        
        .cmw-search-input-container .cmw-search-input {
            width: 100% !important;
            max-width: none !important;
            padding: 0px 5px !important;
            border-radius: 4px;
            font-size: 13px !important;
            line-height: 1.4;
            height: 18px;
            outline: none;
            background: white;
            color: #374151;
        }
        
        .cmw-search-input-container .cmw-search-input::placeholder {
            color: #9ca3af;
            font-size: 13px;
        }

        .cmw-section {
            margin-bottom: 24px;
            padding: 24px;
            border: 2px solid #e2e8f0;
            border-radius: 16px;
            background: #ffffff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .cmw-section:hover {
            border-color: #cbd5e1;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .cmw-section h6 {
            font-size: 1.1rem;
            margin: 0 0 20px;
            font-weight: 600;
            color: #374151;
            text-align: center;
        }

        /* New Search Form Layout */
        .cmw-search-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
        }

        .cmw-search-swatches {
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: flex-start;
        }

        .cmw-search-swatch-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .cmw-search-intent-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #e2e8f0;
            background: #f0f0f0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-search-intent-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-search-color-info {
            text-align: center;
            padding: 12px 16px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            min-width: 200px;
        }

        .cmw-search-info-title {
            font-size: 12px;
            color: #6b7280;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .cmw-search-info-value {
            font-size: 14px;
            color: #374151;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .cmw-search-name-input {
            width: 100%;
            max-width: 400px;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
        }

        .cmw-search-name-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        /* Legacy styles for compatibility */
        .cmw-input-group {
            display: flex;
            flex-direction: column;
            gap: 16px;
            align-items: center;
        }

        .cmw-values-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .cmw-value-type-selector {
            display: flex;
            justify-content: center;
            margin-bottom: 16px;
        }

        .cmw-value-type-select {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            color: #374151;
            cursor: pointer;
            min-width: 180px;
            text-align: center;
        }

        .cmw-value-type-select:focus {
            outline: none;
            border-color: #0065a3;
            box-shadow: 0 0 0 3px rgba(0, 101, 163, 0.1);
        }

        .cmw-color-preview-container {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            margin: 16px auto;
            flex-wrap: wrap;
            min-height: 80px;
            position: relative;
        }

        .cmw-color-preview {
            width: 80px;
            height: 80px;
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            background: #f8fafc;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
            position: relative;
            display: block;
            flex-shrink: 0;
            cursor: pointer;
        }

        .cmw-color-preview:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-color-preview::after {
            display: none;
        }

        .cmw-color-preview.valid::after {
            display: none;
        }

        .cmw-color-preview.selected {
            /* No blue border for main swatch */
            box-shadow: none;
        }

        .cmw-selected-color-info {
            display: none;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            min-width: 180px;
            max-width: 250px;
            flex-shrink: 0;
            position: relative;
        }

        .cmw-selected-color-info.show {
            display: flex;
        }

        .cmw-selected-color-library {
            font-size: 15px;
            color: #374151;
            text-align: center;
            font-weight: 600;
        }

        .cmw-selected-color-lab {
            font-size: 13px;
            color: #4b5563;
            text-align: center;
            font-family: 'Courier New', monospace;
            background: #ffffff;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
        }

        .cmw-converted-cmyk {
            font-size: 12px;
            color: #6b7280;
            text-align: center;
            font-family: 'Courier New', monospace;
            background: #f8fafc;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #e5e7eb;
            margin-top: 8px;
        }

        .cmw-value-inputs {
            display: none;
            justify-content: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .cmw-value-inputs.active {
            display: flex;
        }

        .cmw-wrap input {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            transition: all 0.2s;
            background: #ffffff;
            width: 100%;
            max-width: 653px;
        }

        .cmw-wrap input:focus {
            outline: none;
            border-color: #0065a3;
            box-shadow: 0 0 0 3px rgba(0, 101, 163, 0.1);
        }

        .cmw-wrap input[readonly] {
            background: #f8fafc;
            color: #6b7280;
            cursor: default;
        }

        /* Legacy styles removed - now using .cmw-sample-input-group and .cmw-sample-input-field */

        .cmw-wrap button {
            padding: 12px 32px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border: 2px solid #0065a3;
            background: #0065a3;
            color: white;
            border-radius: 8px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .cmw-wrap button:hover {
            background: #004d7a;
            border-color: #004d7a;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 101, 163, 0.3);
        }

        .cmw-wrap button:active {
            transform: translateY(0);
        }

        .cmw-wrap button:disabled {
            background: #9ca3af;
            border-color: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .cmw-library-toggles {
            margin-bottom: 24px;
            padding: 20px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .cmw-library-toggles h6 {
            font-size: 1.1rem;
            margin: 0 0 16px;
            font-weight: 600;
            color: #374151;
            text-align: center;
        }

        .cmw-toggle-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }
        
        .cmw-active-lib-chip {
            transition: all 0.2s ease;
        }
        
        .cmw-active-lib-chip:hover {
            background: #004d7a !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .cmw-toggle-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #f8fafc;
            border-radius: 8px;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .cmw-toggle-item:hover {
            background: #f1f5f9;
            border-color: #e2e8f0;
        }

        .cmw-toggle-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #0065a3;
        }

        .cmw-toggle-item label {
            cursor: pointer;
            font-size: 15px;
            color: #374151;
            user-select: none;
            font-weight: 500;
        }

        .cmw-library-count {
            font-size: 0.9em;
            color: #6b7280;
            margin-left: 4px;
        }

        .cmw-profile-selector {
            margin-top: 16px;
            text-align: center;
        }

        .cmw-profile-select {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            color: #374151;
            cursor: pointer;
            margin-left: 8px;
        }

        .cmw-loading {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin: 20px 0;
            color: #6b7280;
        }

        .cmw-loading.show {
            display: flex;
        }

        .cmw-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f4f6;
            border-top: 2px solid #0065a3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .cmw-status {
            margin: 16px 0;
            padding: 12px;
            border-radius: 8px;
            display: none;
            text-align: center;
            font-weight: 500;
        }

        .cmw-status.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #a7f3d0;
        }

        .cmw-status.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }

        .cmw-status.warning {
            background: #fef3c7;
            color: #92400e;
            border: 1px solid #fde68a;
        }

        .cmw-status.show {
            display: block;
        }

        .cmw-wrap table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 24px;
            background: #ffffff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .cmw-wrap th,
        .cmw-wrap td {
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            text-align: left;
        }

        .cmw-wrap th {
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
        }

        .cmw-wrap td {
            color: #1f2937;
        }

        .cmw-swatch {
            width: 60px;
            height: 30px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* Color Info Modal */
        .cmw-color-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .cmw-color-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .cmw-color-modal {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 380px;
            width: 90%;
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.2s ease;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .cmw-color-modal-overlay.show .cmw-color-modal {
            transform: scale(1);
        }

        .cmw-color-modal-swatch {
            height: 120px;
            width: 100%;
            position: relative;
        }

        .cmw-color-modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease;
            padding: 0;
        }

        .cmw-color-modal-close:hover {
            opacity: 0.7;
        }

        #cmw-modal-history-prev:hover,
        #cmw-modal-history-next:hover {
            background: #f0f4f8;
        }

        #cmw-modal-history-home:hover {
            background: #f0f4f8;
        }

        #cmw-modal-history-home:hover svg {
            fill: #004d7a;
        }

        .cmw-color-modal-menu-btn {
            width: 32px;
            height: 32px;
            border: none;
            background: transparent;
            font-size: 22px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease;
            padding: 0;
        }

        .cmw-color-modal-menu-btn:hover {
            opacity: 0.7;
        }

        .cmw-color-modal-dropdown {
            position: absolute;
            top: 48px;
            left: 10px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: fit-content;
            white-space: nowrap;
            z-index: 20;
        }

        .cmw-modal-menu-item {
            padding: 10px 14px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: background 0.15s ease;
            border-bottom: 1px solid #f3f4f6;
        }

        .cmw-modal-menu-item:last-child {
            border-bottom: none;
        }

        .cmw-modal-menu-item:hover {
            background: #f9fafb;
            color: #0065a3;
        }

        .cmw-color-modal-name {
            padding: 16px 20px 8px;
            font-size: 18px;
            font-weight: 700;
            color: #1f2937;
            text-align: center;
        }

        /* Modal Tabs */
        .cmw-modal-tabs {
            display: flex;
            gap: 4px;
            padding: 0 20px;
            margin: 16px 0 0 0;
            border-bottom: 2px solid #e2e8f0;
        }
        
        .cmw-modal-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.2s ease;
            position: relative;
            top: 2px;
        }
        
        .cmw-modal-tab:hover {
            color: #0065a3;
        }
        
        .cmw-modal-tab.active {
            color: #0065a3;
            border-bottom-color: #0065a3;
        }
        
        .cmw-modal-tab-content {
            display: none;
        }
        
        .cmw-modal-tab-content.active {
            display: block;
        }

        .cmw-color-modal-values {
            padding: 8px 20px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        /* Spectral Data Display */
        .cmw-spectral-container {
            padding: 20px;
        }
        
        .cmw-spectral-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f0f9ff;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 13px;
        }
        
        .cmw-spectral-info-label {
            color: #64748b;
            font-weight: 500;
        }
        
        .cmw-spectral-info-value {
            color: #0065a3;
            font-weight: 600;
        }
        
        .cmw-spectral-graph {
            width: 100%;
            height: 300px;
            background: white;
            border-radius: 8px;
        }

        .cmw-color-value-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: #f8fafc;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .cmw-color-value-row:hover {
            background: #e2e8f0;
        }

        .cmw-color-value-label {
            font-weight: 600;
            color: #6b7280;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .cmw-color-value-data {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 14px;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .cmw-color-copy-icon {
            opacity: 0.4;
            font-size: 12px;
            transition: opacity 0.15s ease;
        }

        .cmw-color-value-row:hover .cmw-color-copy-icon {
            opacity: 1;
        }

        .cmw-color-copied {
            background: #dcfce7 !important;
        }

        /* Modal Add to Library Section */
        .cmw-modal-purchase-links {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 20px;
            border-top: 1px solid #e2e8f0;
            margin-top: 8px;
        }

        .cmw-modal-purchase-btn {
            display: inline-block;
            padding: 12px 16px;
            background: linear-gradient(135deg, #FF9900 0%, #FF7700 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .cmw-modal-purchase-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            background: linear-gradient(135deg, #FFB84D 0%, #FF8833 100%);
        }

        .cmw-modal-manufacturer-btn {
            background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
        }

        .cmw-modal-manufacturer-btn:hover {
            background: linear-gradient(135deg, #0077c2 0%, #0065a3 100%);
        }


        .cmw-suggestions {
            margin-top: 12px;
            padding: 0;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            display: none;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            max-width: 350px;
            width: 100%;
            max-height: 300px;
            overflow-y: auto;
            position: relative;
            z-index: 100;
        }

        .cmw-suggestions.show {
            display: block;
        }

        .cmw-suggestions-header {
            position: sticky;
            top: 0;
            background: #f9fafb;
            padding: 12px;
            font-weight: 600;
            color: #374151;
            border-bottom: 1px solid #e5e7eb;
            z-index: 10;
        }

        .cmw-suggestions-content {
            padding: 8px;
        }

        .cmw-suggestion {
            cursor: pointer;
            padding: 10px 12px;
            margin: 2px 0;
            border-radius: 6px;
            transition: background 0.1s ease;
            color: #374151;
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cmw-suggestion:hover {
            background: #0065a3;
            color: white;
            border-color: #0065a3;
        }

        .cmw-suggestion:active {
            background: #004d7a;
            transform: none;
        }

        .cmw-suggestion-swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
            flex-shrink: 0;
        }

        .cmw-suggestion-info {
            flex: 1;
            min-width: 0;
        }

        .cmw-suggestion-name {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cmw-suggestion-library {
            font-size: 11px;
            color: #9ca3af;
        }

        .cmw-suggestion:hover .cmw-suggestion-library {
            color: #e0e7ff;
        }

        @media (max-width: 768px) {
            .cmw-suggestion {
                padding: 12px 14px;
                min-height: 48px;
            }
            
            .cmw-suggestion-swatch {
                width: 32px;
                height: 32px;
            }
           
            .cmw-suggestion:hover {
                background: #f8fafc;
                color: #374151;
                border-color: #e5e7eb;
            }
            
            .cmw-suggestion:hover .cmw-suggestion-library {
                color: #9ca3af;
            }
           
            .cmw-suggestion:active,
            .cmw-suggestion:focus {
                background: #0065a3;
                color: white;
                border-color: #0065a3;
            }
            
            .cmw-suggestion:active .cmw-suggestion-library,
            .cmw-suggestion:focus .cmw-suggestion-library {
                color: #e0e7ff;
            }
        }

        .cmw-brand-hint {
            color: #6b7280;
            font-size: 0.9em;
        }
        
        .cmw-suggestion:hover .cmw-brand-hint {
            color: #e0e7ff;
        }

        .cmw-disabled-library {
            opacity: 0.6;
        }

        .cmw-loading-more {
            display: none;
            text-align: center;
            padding: 12px;
            color: #6b7280;
            font-style: italic;
            border-top: 1px solid #e5e7eb;
        }

        .cmw-loading-more.show {
            display: block;
        }

        .cmw-no-more-results {
            display: none;
            text-align: center;
            padding: 12px;
            color: #9ca3af;
            font-style: italic;
            font-size: 0.9em;
            border-top: 1px solid #e5e7eb;
        }

        .cmw-no-more-results.show {
            display: block;
        }

        .cmw-api-status {
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            margin-left: 8px;
            display: inline-block;
        }

        .cmw-api-status.enhanced {
            background: #d1fae5;
            color: #065f46;
        }

        .cmw-api-status.fallback {
            background: #fef3c7;
            color: #92400e;
        }

        /* Collapsible Settings Styles - Blue Arrow Style */
        .cmw-settings-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 8px 0;
            color: #0065a3;
            font-weight: 500;
        }

        .cmw-settings-toggle:hover {
            color: #004d7a;
        }

        .cmw-settings-caret {
            transition: transform 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
        }
        
        .cmw-settings-caret svg {
            width: 14px;
            height: 14px;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }

        .cmw-settings-toggle.collapsed .cmw-settings-caret {
            transform: rotate(0deg);
        }

        .cmw-settings-toggle:not(.collapsed) .cmw-settings-caret {
            transform: rotate(90deg);
        }

        .cmw-settings-label {
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
        }

        .cmw-settings-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(to right, #e2e8f0, #e2e8f0 80%, transparent);
            margin-left: 8px;
        }

        .cmw-settings-content {
            max-height: 3000px;
            overflow: visible;
            transition: max-height 0.3s ease-out;
            padding-bottom: 10px;
        }

        .cmw-settings-content.collapsed {
            max-height: 0;
            overflow: hidden;
            padding-bottom: 0;
        }

        /* Gamut Warning Styles */
        .cmw-gamut-warning {
            display: none;
            margin: 8px 0;
            padding: 8px 12px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
            border-radius: 6px;
            font-size: 12px;
            text-align: center;
            font-weight: 500;
        }

        .cmw-gamut-warning.show {
            display: block;
        }

        .cmw-gamut-warning.out-of-gamut {
            background: #fee2e2;
            border-color: #ef4444;
            color: #991b1b;
        }

        .cmw-gamut-icon {
            margin-right: 4px;
        }

        /* Color Harmonies Styles */
        .cmw-harmony-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            justify-content: center;
            margin-top: 16px;
        }

        .cmw-harmony-color {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            min-width: 160px;
            transition: all 0.2s;
        }

        .cmw-harmony-color:hover {
            border-color: #0065a3;
            box-shadow: 0 4px 8px rgba(0, 101, 163, 0.1);
        }

        .cmw-harmony-swatch {
            width: 60px;
            height: 60px;
            cursor: pointer;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 12px;
            position: relative;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-harmony-swatch::after {
            display: none;
        }

        .cmw-harmony-swatch.in-gamut::after {
            display: none;
        }

        .cmw-harmony-swatch:hover {
            transform: scale(1.08);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-harmony-info {
            text-align: center;
            width: 100%;
        }

        .cmw-harmony-type {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .cmw-harmony-match {
            font-size: 13px;
            color: #374151;
            font-weight: 600;
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .cmw-harmony-brand {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 6px;
        }

        .cmw-harmony-delta {
            font-size: 11px;
            color: #4b5563;
            font-family: 'Courier New', monospace;
            background: #ffffff;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #d1d5db;
        }

        .cmw-harmony-lab {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
            margin-top: 4px;
        }

        .cmw-harmony-cmyk {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
            margin-top: 4px;
        }

        .cmw-harmony-hex {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
            margin-top: 4px;
        }

        /* Rendering Intent Comparison Styles */
        .cmw-intents-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 16px;
        }

        .cmw-intent-card {
            display: flex;
            flex-direction: column;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            transition: all 0.2s;
        }

        .cmw-intent-card:hover {
            border-color: #0065a3;
            box-shadow: 0 4px 8px rgba(0, 101, 163, 0.1);
        }

        .cmw-intent-card.current {
            border-color: #0065a3;
            background: #f0f8ff;
        }

        .cmw-intent-swatch {
            width: 100%;
            height: 60px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin-bottom: 12px;
            background: #f8fafc;
            position: relative;
            transition: all 0.2s;
            cursor: pointer;
        }

        .cmw-intent-swatch:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .cmw-intent-swatch::after {
            content: '⚠';
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 14px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #92400e;
        }

        .cmw-intent-swatch.in-gamut::after {
            content: '✓';
            background: #d1fae5;
            border-color: #10b981;
            color: #065f46;
            font-weight: bold;
            font-size: 12px;
        }

        .cmw-intent-swatch.no-gamut-indicator::after {
            display: none;
        }

        .cmw-intent-info {
            flex: 1;
        }

        .cmw-intent-name {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 4px;
        }

        .cmw-intent-delta {
            font-size: 12px;
            color: #4b5563;
            font-family: 'Courier New', monospace;
            margin-bottom: 6px;
        }

        .cmw-intent-desc {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .cmw-intent-lab {
            font-size: 10px;
            color: #6b7280;
            font-family: 'Courier New', monospace;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            .cmw-wrap {
                padding: 0 16px;
                max-width: 100%;
            }

            .cmw-wrap h5 {
                font-size: 1.5rem;
                margin-bottom: 24px;
            }
            
            .cmw-hamburger-icon {
                left: 8px;
                top: 8px;
                width: 18px;
                height: 18px;
            }
            
            .cmw-hamburger-dropdown {
                left: 8px;
                top: 35px;
                width: 200px;
            }
            
            .cmw-hamburger-menu-item {
                padding: 10px 12px;
                font-size: 13px;
            }
            
            .cmw-hamburger-menu-header {
                padding: 10px 12px;
                font-size: 11px;
            }
            
            .cmw-search-icon {
                right: 8px;
                top: 8px;
                width: 18px;
                height: 18px;
            }
            
            .cmw-search-input-container {
                right: 30px;
                top: 8px;
            }
            
            .cmw-search-input-container.active {
                width: 150px;
            }
            
            .cmw-search-input-container .cmw-search-input {
                padding: 0px 4px !important;
                font-size: 12px !important;
                height: 26px;
            }

            .cmw-section {
                padding: 20px;
                margin-bottom: 20px;
            }

            .cmw-color-preview-container {
                flex-direction: column;
                gap: 16px;
            }

            .cmw-selected-color-info {
                min-width: auto;
                max-width: 100%;
            }

            .cmw-toggle-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .cmw-wrap table {
                font-size: 13px;
                overflow-x: auto;
                display: block;
            }

            .cmw-wrap table thead,
            .cmw-wrap table tbody {
                display: table;
                width: 100%;
                table-layout: fixed;
            }

            .cmw-wrap th,
            .cmw-wrap td {
                padding: 8px 6px;
            }

            .cmw-swatch {
                width: 40px;
                height: 24px;
            }

            .cmw-harmony-colors {
                flex-direction: column;
                gap: 12px;
            }

            .cmw-harmony-color {
                flex-direction: column;
                text-align: center;
            }

            .cmw-intents-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
        }

        @media (max-width: 480px) {
            .cmw-wrap {
                padding: 0 12px;
            }

            .cmw-section {
                padding: 16px;
            }

        }

        /* Color Consensus Styles */
        .cmw-consensus-section {
            margin-top: 24px;
        }

        .cmw-consensus-samples {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        .cmw-sample-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            transition: all 0.2s;
        }

        .cmw-sample-row:hover {
            border-color: #cbd5e1;
        }

        .cmw-sample-row.excluded {
            opacity: 0.5;
            background: #fef2f2;
            border-color: #fecaca;
        }

        .cmw-sample-swatch {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
            flex-shrink: 0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-sample-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .cmw-sample-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .cmw-sample-label {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .cmw-sample-values {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #6b7280;
        }

        .cmw-sample-delta {
            font-size: 12px;
            color: #0065a3;
            font-weight: 500;
        }

        .cmw-sample-remove {
            width: 28px;
            height: 28px;
            border: none;
            background: #fee2e2;
            color: #dc2626;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cmw-sample-remove:hover {
            background: #fecaca;
        }

        .cmw-add-sample-row {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            align-items: center;
        }

        .cmw-sample-label-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
            width: 100%;
            max-width: 300px;
        }

        .cmw-sample-label-section label {
            font-weight: 500;
            color: #374151;
            font-size: 13px;
            text-align: center;
        }

        .cmw-sample-label-section input {
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            color: #374151;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
        }

        .cmw-sample-label-section input:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-sample-preview-swatch-large {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #e2e8f0;
            background: #f0f0f0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-sample-preview-swatch-large:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-search-color-info-box {
            text-align: center;
            padding: 12px 20px;
            background: #ffffff;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            min-width: 200px;
        }

        .cmw-sample-format-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .cmw-sample-format-select {
            padding: 10px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: #ffffff;
            color: #374151;
            font-size: 14px;
            cursor: pointer;
            min-width: 100px;
        }

        .cmw-sample-format-select:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-sample-inputs-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
            width: 100%;
        }

        .cmw-sample-value-inputs {
            display: none;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .cmw-sample-value-inputs.active {
            display: flex;
        }

        .cmw-sample-input-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .cmw-sample-input-label {
            font-weight: 600;
            color: #0065a3;
            font-size: 14px;
            min-width: 20px;
            text-align: right;
        }

        .cmw-sample-input-field {
            width: 70px;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .cmw-sample-input-field:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-sample-hex-input {
            width: 120px;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        .cmw-sample-hex-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-add-sample-btn {
            padding: 12px 24px;
            background: #0065a3;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            align-self: center;
            flex-shrink: 0;
        }

        .cmw-add-sample-btn:hover {
            background: #004d7a;
        }


        .cmw-consensus-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .cmw-consensus-btn {
            padding: 12px 28px;
            background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 101, 163, 0.3);
        }

        .cmw-consensus-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.4);
        }

        .cmw-consensus-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .cmw-clear-btn {
            padding: 12px 28px;
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-clear-btn:hover {
            background: #e5e7eb;
        }

        .cmw-consensus-result {
            display: none;
            margin-top: 24px;
            margin-bottom: 16px;
            padding: 24px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0065a3;
            border-radius: 16px;
        }

        .cmw-consensus-result.show {
            display: block;
        }

        .cmw-consensus-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .cmw-consensus-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #0065a3;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-consensus-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.25);
        }

        .cmw-consensus-info {
            flex: 1;
        }

        .cmw-consensus-title {
            font-size: 18px;
            font-weight: 700;
            color: #0065a3;
            margin-bottom: 8px;
        }

        .cmw-consensus-lab {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #374151;
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            display: inline-block;
        }

        .cmw-consensus-hex {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #6b7280;
            margin-left: 12px;
        }

        .cmw-consensus-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .cmw-stat-card {
            background: white;
            padding: 12px 16px;
            border-radius: 8px;
            text-align: center;
        }

        .cmw-stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #0065a3;
        }

        .cmw-stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        .cmw-consensus-warning {
            margin-top: 16px;
            padding: 12px 16px;
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            color: #92400e;
            font-size: 14px;
        }

        .cmw-pairwise-section {
            margin-top: 20px;
        }

        .cmw-pairwise-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 0;
            color: #0065a3;
            font-weight: 600;
            font-size: 14px;
        }

        .cmw-pairwise-toggle span:first-child {
            transition: transform 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .cmw-pairwise-toggle span:first-child svg {
            display: block;
        }
        
        .cmw-pairwise-toggle.expanded span:first-child {
            transform: rotate(90deg);
        }

        .cmw-pairwise-grid {
            display: none;
            margin-top: 12px;
            gap: 8px;
        }

        .cmw-pairwise-grid.show {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }

        .cmw-pairwise-item {
            background: white;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .cmw-pairwise-pair {
            color: #374151;
        }

        .cmw-pairwise-delta {
            font-weight: 600;
            color: #0065a3;
            font-family: 'Courier New', monospace;
        }

        .cmw-threshold-setting {
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .cmw-threshold-input {
            width: 80px;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            text-align: center;
        }

        .cmw-threshold-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        /* Custom Library Styles */
        .cmw-custom-library-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
            max-height: 300px;
            overflow-y: auto;
        }

        .cmw-custom-color-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .cmw-custom-color-item:hover {
            border-color: #cbd5e1;
        }

        .cmw-custom-color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: 2px solid #e2e8f0;
            flex-shrink: 0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .cmw-custom-color-swatch:hover {
            transform: scale(1.15);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .cmw-custom-color-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .cmw-custom-color-name {
            font-weight: 600;
            color: #374151;
            font-size: 14px;
        }

        .cmw-custom-color-values {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #6b7280;
        }

        .cmw-custom-color-remove {
            width: 24px;
            height: 24px;
            border: none;
            background: #fee2e2;
            color: #dc2626;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cmw-custom-color-remove:hover {
            background: #fecaca;
        }

        .cmw-custom-add-form {
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            margin-bottom: 16px;
            align-items: center;
        }

        .cmw-custom-library-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .cmw-custom-export-btn,
        .cmw-custom-import-btn {
            padding: 8px 16px;
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-custom-export-btn:hover,
        .cmw-custom-import-btn:hover {
            background: #e5e7eb;
        }

        .cmw-custom-clear-btn {
            padding: 8px 16px;
            background: #fee2e2;
            color: #dc2626;
            border: 2px solid #fecaca;
            border-radius: 8px;
            font-weight: 500;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-custom-clear-btn:hover {
            background: #fecaca;
        }

        .cmw-custom-empty {
            text-align: center;
            color: #9ca3af;
            font-size: 14px;
            padding: 20px;
            font-style: italic;
        }

        #cmw-custom-import-file {
            display: none;
        }

        /* Color Compare Styles */
        .cmw-compare-container {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .cmw-compare-colors {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }

        .cmw-compare-arrow-between {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #0065a3;
            font-weight: 700;
            padding: 0 8px;
            align-self: center;
            margin-top: 40px;
        }

        @media (max-width: 600px) {
            .cmw-compare-arrow-between {
                transform: rotate(90deg);
                margin: 8px 0;
            }
        }

        /* Responsive styles for Color Compare on small screens */
        @media (max-width: 480px) {
            .cmw-compare-colors {
                flex-direction: row !important;
                flex-wrap: nowrap !important;
                gap: 8px !important;
                justify-content: center;
            }

            .cmw-compare-color-box {
                width: calc(50% - 20px) !important;
                min-width: 0 !important;
                max-width: none !important;
                padding: 10px !important;
                gap: 8px !important;
                flex-shrink: 1 !important;
            }

            .cmw-compare-color-box h4 {
                font-size: 11px !important;
            }

            .cmw-compare-swatch {
                width: 50px !important;
                height: 50px !important;
                border-radius: 8px !important;
            }

            .cmw-compare-format-select {
                font-size: 11px !important;
                padding: 4px 6px !important;
            }

            .cmw-compare-inputs input {
                font-size: 11px !important;
                padding: 6px 8px !important;
            }

            .cmw-compare-color-values {
                font-size: 9px !important;
                padding: 4px !important;
            }

            .cmw-compare-arrow-between {
                font-size: 16px !important;
                margin: 0 4px !important;
                transform: none !important;
            }

            .cmw-compare-result {
                padding: 10px 16px !important;
            }

            .cmw-compare-delta-value {
                font-size: 22px !important;
            }

            .cmw-compare-delta-label {
                font-size: 11px !important;
            }

            .cmw-compare-delta-interpretation {
                font-size: 10px !important;
                padding: 3px 8px !important;
            }

            .cmw-compare-actions {
                flex-direction: column !important;
                gap: 8px !important;
            }

            .cmw-compare-btn,
            .cmw-compare-clear-btn {
                width: 100% !important;
                padding: 10px 16px !important;
                font-size: 13px !important;
            }
        }

        /* Even smaller screens */
        @media (max-width: 360px) {
            .cmw-compare-color-box {
                padding: 8px !important;
                gap: 6px !important;
            }

            .cmw-compare-swatch {
                width: 40px !important;
                height: 40px !important;
            }

            .cmw-compare-color-box h4 {
                font-size: 10px !important;
            }

            .cmw-compare-inputs input {
                font-size: 10px !important;
                padding: 5px 6px !important;
            }

            .cmw-compare-delta-value {
                font-size: 18px !important;
            }
        }

        .cmw-compare-color-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            width: 180px;
            max-width: 180px;
            flex-shrink: 0;
            transition: all 0.2s;
            box-sizing: border-box;
        }

        .cmw-compare-color-box:hover {
            border-color: #cbd5e1;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .cmw-compare-color-box h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .cmw-compare-swatch {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            border: 3px solid #e2e8f0;
            background: #f0f0f0;
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        .cmw-compare-swatch:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.25);
            border-color: #0065a3;
        }

        .cmw-compare-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .cmw-compare-format-row {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .cmw-compare-format-select {
            padding: 6px 10px;
            font-size: 13px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            background: #ffffff;
            color: #374151;
            cursor: pointer;
        }

        .cmw-compare-format-select:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-compare-value-inputs {
            display: none;
        }

        .cmw-compare-value-inputs.active {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .cmw-compare-input-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .cmw-compare-input-label {
            font-size: 12px;
            font-weight: 600;
            color: #6b7280;
            width: 24px;
            text-align: right;
        }

        .cmw-compare-input-field {
            flex: 1;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'SF Mono', Monaco, monospace;
            text-align: center;
        }

        .cmw-compare-input-field:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-compare-hex-input {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            text-align: center;
        }

        .cmw-compare-hex-input:focus {
            outline: none;
            border-color: #0065a3;
        }

        .cmw-compare-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .cmw-compare-suggestion-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .cmw-compare-suggestion-item:hover {
            background: #f0f9ff;
        }

        .cmw-compare-suggestion-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
            flex-shrink: 0;
        }

        .cmw-compare-suggestion-info {
            flex: 1;
            min-width: 0;
        }

        .cmw-compare-suggestion-name {
            font-size: 13px;
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cmw-compare-suggestion-library {
            font-size: 11px;
            color: #9ca3af;
        }

        .cmw-compare-input-wrapper {
            position: relative;
            width: 100%;
            max-width: 100%;
        }

        .cmw-compare-color-box input,
        .cmw-compare-color-box select {
            max-width: 100% !important;
            box-sizing: border-box;
        }

        .cmw-compare-color-values {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 11px;
            color: #6b7280;
            text-align: center;
            padding: 8px;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            width: 100%;
        }

        /* Delta E Result */
        .cmw-compare-result {
            display: none;
            padding: 10px 16px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #0065a3;
            border-radius: 10px;
            text-align: center;
            margin: 12px auto 0 auto;
            max-width: fit-content;
        }

        .cmw-compare-result.show {
            display: flex;
            justify-content: center;
        }

        .cmw-compare-delta-display {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .cmw-compare-delta-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .cmw-compare-delta-value {
            font-size: 28px;
            font-weight: 800;
            font-family: 'SF Mono', Monaco, monospace;
            transition: color 0.2s ease;
        }

        .cmw-compare-delta-value.good {
            color: #16a34a;
        }

        .cmw-compare-delta-value.moderate {
            color: #ca8a04;
        }

        .cmw-compare-delta-value.poor {
            color: #dc2626;
        }

        .cmw-compare-delta-interpretation {
            font-size: 12px;
            color: #6b7280;
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 6px;
        }

        .cmw-compare-btn {
            padding: 12px 32px;
            background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(0, 101, 163, 0.3);
        }

        .cmw-compare-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 101, 163, 0.4);
        }

        .cmw-compare-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .cmw-compare-actions {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 16px;
        }

        .cmw-compare-clear-btn {
            padding: 12px 24px;
            background: #f3f4f6;
            color: #374151;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cmw-compare-clear-btn:hover {
            background: #e5e7eb;
        }

        /* Color Harmony Card Styles */
        .cmw-harmony-card {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .cmw-harmony-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        /* Palette Cards Scrollbar */
        #cmw-palette-cards::-webkit-scrollbar {
            width: 8px;
        }
        
        #cmw-palette-cards::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }
        
        #cmw-palette-cards::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        
        #cmw-palette-cards::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        .cmw-harmony-card-swatch {
            width: 100%;
            height: 80px;
            border-radius: 6px;
            margin-bottom: 12px;
            border: 1px solid #e2e8f0;
            cursor: pointer;
        }
        
        .cmw-harmony-card-title {
            font-size: 15px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 4px;
        }
        
        .cmw-harmony-card-hex {
            font-size: 13px;
            color: #6b7280;
        }
        
        .cmw-harmony-card-lab {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 4px;
        }
        
        .cmw-harmony-card-matches {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e2e8f0;
        }
        
        .cmw-harmony-card-match {
            font-size: 12px;
            color: #374151;
            margin-top: 4px;
        }

        /* Results Table Styles */
        #cmw-out {
            line-height: 25px;
            -webkit-font-smoothing: antialiased;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            border-collapse: collapse;
            padding: 12px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
            text-align: left;
            background: #f9fafb;
            font-weight: 600;
            color: #374151;
            width: 100%;
            margin-top: 20px;
        }

        #cmw-out thead th {
            background: #f9fafb;
            color: #374151;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 1px solid #e5e7eb;
        }

        #cmw-out tbody tr {
            transition: background-color 0.2s, transform 0.1s;
        }

        #cmw-out tbody tr:hover {
            background-color: #f8fafc;
            transform: translateX(2px);
        }

        #cmw-out tbody td {
            padding: 10px 12px;
            border-bottom: 1px solid #e2e8f0;
        }
    </style>

           <!-- Section 2 HTML -->

</head>
<body>
    <!-- Color Info Modal -->
    <div id="cmw-color-modal-overlay" class="cmw-color-modal-overlay">
        <div class="cmw-color-modal">
            <div id="cmw-color-modal-swatch" class="cmw-color-modal-swatch">
                <button id="cmw-color-modal-menu" class="cmw-color-modal-menu-btn" style="position: absolute; top: 10px; left: 10px; z-index: 10;">☰</button>
                <button id="cmw-color-modal-close" class="cmw-color-modal-close" style="position: absolute; top: 10px; right: 10px; z-index: 10;">×</button>
                <div id="cmw-color-modal-dropdown" class="cmw-color-modal-dropdown" style="display: none;">
                    <div class="cmw-modal-menu-item" data-action="add-to-library">Add to Library</div>
                    <div class="cmw-modal-menu-item" data-action="add-to-search">Use in Search</div>
                    <div class="cmw-modal-menu-item" data-action="copy-all">Copy All Values</div>
                    <div style="height: 1px; background: #e2e8f0; margin: 4px 0;"></div>
                    <div class="cmw-modal-menu-item" data-action="preferences">User Preferences</div>
                </div>
            </div>
            <div id="cmw-color-modal-name" class="cmw-color-modal-name">Color Name</div>
            
            <!-- Modal Tabs -->
            <div id="cmw-modal-tabs" class="cmw-modal-tabs" style="display: none;">
                <button class="cmw-modal-tab active" data-tab="values">Color Values</button>
                <button class="cmw-modal-tab" data-tab="spectral">Spectral Data</button>
            </div>
            
            <!-- Tab Content: Color Values -->
            <div id="cmw-tab-values" class="cmw-modal-tab-content active">
                <div class="cmw-color-modal-values">
                    <div class="cmw-color-value-row" data-type="lab">
                        <span class="cmw-color-value-label">Lab</span>
                        <span class="cmw-color-value-data"><span id="cmw-modal-lab">--</span><span class="cmw-color-copy-icon">📋</span></span>
                    </div>
                    <div class="cmw-color-value-row" data-type="hex">
                        <span class="cmw-color-value-label">Hex</span>
                        <span class="cmw-color-value-data"><span id="cmw-modal-hex">--</span><span class="cmw-color-copy-icon">📋</span></span>
                    </div>
                    <div class="cmw-color-value-row" data-type="rgb">
                        <span class="cmw-color-value-label">RGB</span>
                        <span class="cmw-color-value-data"><span id="cmw-modal-rgb">--</span><span class="cmw-color-copy-icon">📋</span></span>
                    </div>
                    <div class="cmw-color-value-row" data-type="cmyk">
                        <span class="cmw-color-value-label">CMYK</span>
                        <span class="cmw-color-value-data"><span id="cmw-modal-cmyk">--</span><span class="cmw-color-copy-icon">📋</span></span>
                    </div>
                </div>
            </div>
            
            <!-- Tab Content: Spectral Data -->
            <div id="cmw-tab-spectral" class="cmw-modal-tab-content">
                <div class="cmw-spectral-container">
                    <div class="cmw-spectral-info">
                        <div>
                            <span class="cmw-spectral-info-label">Wavelength Range: </span>
                            <span class="cmw-spectral-info-value" id="cmw-spectral-range">--</span>
                        </div>
                        <div>
                            <span class="cmw-spectral-info-label">Data Points: </span>
                            <span class="cmw-spectral-info-value" id="cmw-spectral-points">--</span>
                        </div>
                    </div>
                    <div id="cmw-spectral-graph" class="cmw-spectral-graph"></div>
                </div>
            </div>
            
            <!-- Purchase Links Section -->
            <div id="cmw-modal-purchase-links" class="cmw-modal-purchase-links" style="display: none;">
                <a id="cmw-modal-amazon-link" href="#" target="_blank" rel="noopener noreferrer" class="cmw-modal-purchase-btn">
                    Buy on Amazon
                </a>
                <a id="cmw-modal-manufacturer-link" href="#" target="_blank" rel="noopener noreferrer" class="cmw-modal-purchase-btn cmw-modal-manufacturer-btn" style="display: none;">
                    Manufacturer Site
                </a>
            </div>
            
            <!-- Closest Library Colors Section (User Preference) -->
            <div id="cmw-modal-closest-colors" style="display: none; margin: 20px 4px 4px 4px; padding-top: 18px; border-top: 2px solid #e2e8f0;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 6px; margin-bottom: 14px;">
                    <button id="cmw-modal-history-prev" style="display: none; background: none; border: none; cursor: pointer; color: #0065a3; padding: 4px 8px; border-radius: 4px; transition: background 0.2s;" title="Previous Color">
                        <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
                            <polyline points="15 18 9 12 15 6"></polyline>
                        </svg>
                    </button>
                    <button id="cmw-modal-history-home" style="display: none; background: none; border: none; cursor: pointer; width: 28px; height: 28px; padding: 0; border-radius: 4px; transition: background 0.2s;" title="Back to Original Color">
                        <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: #0065a3;">
                            <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9z"></path>
                        </svg>
                    </button>
                    <button id="cmw-modal-history-next" style="display: none; background: none; border: none; cursor: pointer; color: #0065a3; padding: 4px 8px; border-radius: 4px; transition: background 0.2s;" title="Next Color">
                        <svg viewBox="0 0 24 24" style="width: 18px; height: 18px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
                            <polyline points="9 18 15 12 9 6"></polyline>
                        </svg>
                    </button>
                    <h4 style="font-size: 14px; color: #374151; margin: 0; font-weight: 600; text-align: center; text-transform: uppercase; letter-spacing: 0.5px; font-size: 12px;">Closest Match Per Library</h4>
                </div>
                <div id="cmw-modal-closest-colors-grid" style="display: grid; gap: 10px;">
                    <!-- Closest colors will be populated here - grid columns set dynamically -->
                </div>
            </div>
            
        </div>
    </div>

    <div class="cmw-wrap">
        <h5>+COLOR MATCH</h5>
       
        <!-- Change this to your actual API base URL -->
        <input type="hidden" id="cmw-api-url" value="https://botm-ucxq.onrender.com">
        <!-- ngrok tunnel allows mobile devices to access your localhost API -->
       
        <div class="cmw-library-toggles" style="position: relative;">
            <!-- Hamburger Icon (Left) -->
            <div class="cmw-hamburger-icon" id="cmw-hamburger-icon">
                <svg viewBox="0 0 24 24">
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </div>
            
            <!-- Hamburger Dropdown Menu -->
            <div class="cmw-hamburger-dropdown" id="cmw-hamburger-dropdown">
                <div class="cmw-hamburger-menu-header">Account</div>
                <div class="cmw-hamburger-menu-item" data-action="login">
                    Login / Sign Up
                </div>
                <div class="cmw-hamburger-menu-item" data-action="profile">
                    My Profile
                </div>
                <div class="cmw-hamburger-menu-item divider"></div>
                
                <div class="cmw-hamburger-menu-header">Tools</div>
                <div class="cmw-hamburger-menu-item" data-action="my-libraries">
                    My Libraries
                </div>
                <div class="cmw-hamburger-menu-item" data-action="saved-colors">
                    Saved Colors
                </div>
                <div class="cmw-hamburger-menu-item" data-action="color-history">
                    Search History
                </div>
                <div class="cmw-hamburger-menu-item divider"></div>
                
                <div class="cmw-hamburger-menu-header">More</div>
                <div class="cmw-hamburger-menu-item" data-action="help">
                    Help & Tutorials
                </div>
                <div class="cmw-hamburger-menu-item" data-action="preferences">
                    User Preferences
                </div>
                <div class="cmw-hamburger-menu-item" data-action="about">
                    About ColorMatch
                </div>
            </div>
            
            <!-- User Preferences Modal -->
            <div id="cmw-preferences-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
                <div style="background: white; border-radius: 12px; padding: 24px; max-width: 700px; width: 95%; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 24px rgba(0,0,0,0.2);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; font-size: 20px; color: #1f2937;">User Preferences</h3>
                        <button id="cmw-preferences-close" style="background: none; border: none; font-size: 28px; color: #6b7280; cursor: pointer; padding: 0; width: 32px; height: 32px; line-height: 1;">&times;</button>
                    </div>
                    
                    <!-- Show Closest Library Colors -->
                    <div style="padding: 16px; background: #f9fafb; border-radius: 8px; margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                            <div>
                                <h4 style="margin: 0 0 4px 0; font-size: 16px; color: #1f2937;">Show Closest Library Colors</h4>
                                <p style="margin: 0; font-size: 13px; color: #6b7280;">Display matching colors from selected libraries in color popups</p>
                            </div>
                            <label class="cmw-switch" style="position: relative; display: inline-block; width: 50px; height: 24px;">
                                <input type="checkbox" id="cmw-pref-show-closest">
                                <span></span>
                            </label>
                        </div>
                        
                        <!-- Library Selection (shown when toggle is on) -->
                        <div id="cmw-pref-library-selection" style="display: none; margin-top: 16px; padding-top: 16px; border-top: 1px solid #e2e8f0; width: 100%;">
                            <div style="display: flex; flex-direction: column; gap: 12px; width: 100%;">
                                <label for="cmw-pref-library-search" style="font-weight: 600; color: #374151; text-align: center;">Active Libraries:</label>
                                
                                <!-- Search Input Container (for positioning dropdown) -->
                                <div style="position: relative; width: 100%;">
                                    <input 
                                        type="text" 
                                        id="cmw-pref-library-search" 
                                        placeholder="Search libraries or press ↓" 
                                        size="1"
                                        style="width: 100% !important; min-width: 0; padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; text-align: center; box-sizing: border-box; display: block;"
                                        autocomplete="off"
                                    >
                                    
                                    <!-- Predictive Dropdown -->
                                    <div id="cmw-pref-library-suggestions" style="display: none; position: absolute; top: calc(100% - 2px); left: 0; width: 100%; background: white; border: 2px solid #e2e8f0; border-top: none; border-radius: 0 0 8px 8px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); max-height: 200px; overflow-y: auto; z-index: 1000; box-sizing: border-box;">
                                    </div>
                                </div>
                                
                                <!-- Active Libraries Display -->
                                <div id="cmw-pref-active-libraries" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; min-height: 32px; align-items: center;">
                                    <span style="color: #10b981; font-size: 13px; display: flex; align-items: center; gap: 4px;">
                                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                            <polyline points="20 6 9 17 4 12"></polyline>
                                        </svg>
                                        All libraries active
                                    </span>
                                </div>
                                
                                <!-- Hidden checkboxes container -->
                                <div id="cmw-pref-libraries-container" style="display: none;">
                                    <!-- Library checkboxes will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; justify-content: flex-end; gap: 12px;">
                        <button id="cmw-preferences-save" class="cmw-compare-btn" style="padding: 10px 24px;">
                            Save Preferences
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Search Input Container (slides out) -->
            <div class="cmw-search-input-container" id="cmw-header-search-container">
                <input type="text" class="cmw-search-input" id="cmw-header-search-input" placeholder="Search colors...">
            </div>
            
            <!-- Search Icon (Right) -->
            <div class="cmw-search-icon" id="cmw-header-search-icon">
                <svg viewBox="0 0 24 24">
                    <circle cx="10" cy="10" r="7"></circle>
                    <line x1="15" y1="15" x2="21" y2="21"></line>
                </svg>
            </div>
            <!-- ========================================
                 COLOR LIBRARY BETA (Hidden by default)
                 Legacy custom library management system
                 Toggle via console: colorLibrary()
                 ======================================== -->
            <!-- Custom Libraries Section -->
            <div id="cmw-color-library-section" style="margin-top: 20px; display: none;">
                <div id="cmw-custom-library-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Color Library</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-custom-library-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Browse all available color libraries or create custom ones. Select a library below to view all its colors. Custom libraries appear in the filter list above once they have colors.
                    </p>
                    
                    <!-- Library Selector -->
                    <div style="display: flex; align-items: center; gap: 12px; justify-content: center; margin-bottom: 16px; flex-wrap: wrap;">
                        <label style="font-weight: 600; color: #374151;">Library:</label>
                        <select id="cmw-custom-library-select" style="padding: 8px 14px; border: 2px solid #e2e8f0; border-radius: 8px; min-width: 150px; font-size: 14px;">
                            <option value="">-- Select or Create --</option>
                        </select>
                        <input type="text" id="cmw-new-library-name" class="cmw-custom-name-input" placeholder="New library name" style="width: 150px;">
                        <button id="cmw-create-library-btn" class="cmw-custom-add-btn" style="padding: 8px 16px;">+ Create</button>
                    </div>
                    
                    <!-- Current Library Info -->
                    <div id="cmw-current-library-info" style="display: none; margin-bottom: 16px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: #f0f9ff; border: 2px solid #0065a3; border-radius: 10px;">
                            <div>
                                <span style="font-weight: 600; color: #0065a3;" id="cmw-current-library-name">Library Name</span>
                                <span style="color: #6b7280; font-size: 13px; margin-left: 8px;" id="cmw-current-library-count">(0 colors)</span>
                            </div>
                            <button id="cmw-delete-library-btn" style="padding: 6px 12px; background: #fee2e2; color: #dc2626; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">Delete Library</button>
                        </div>
                    </div>
                    
                    <div id="cmw-custom-library-list" class="cmw-custom-library-list">
                        <div class="cmw-custom-empty">Select or create a library to add colors.</div>
                    </div>
                    
                    <div id="cmw-custom-add-form" class="cmw-custom-add-form" style="display: none;">
                        <!-- Swatch preview at top -->
                        <div id="cmw-custom-preview-swatch" class="cmw-sample-preview-swatch-large" title="Color preview"></div>
                        
                        <!-- Color name -->
                        <div class="cmw-sample-label-section">
                            <label>Color Name</label>
                            <input type="text" id="cmw-custom-color-name" placeholder="e.g., My Red, Brand Blue...">
                        </div>
                        
                        <!-- Format dropdown -->
                        <div class="cmw-sample-format-row">
                            <label style="font-weight: 500; color: #374151; font-size: 13px;">Format:</label>
                            <select id="cmw-custom-format" class="cmw-sample-format-select">
                                <option value="hex" selected>Hex</option>
                                <option value="lab">Lab</option>
                                <option value="rgb">RGB</option>
                                <option value="cmyk">CMYK</option>
                            </select>
                        </div>
                        
                        <!-- Color inputs -->
                        <div class="cmw-sample-inputs-container">
                            <!-- Hex Input -->
                            <div id="cmw-custom-hex-inputs" class="cmw-sample-value-inputs active">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">#</span>
                                    <input type="text" id="cmw-custom-hex" class="cmw-sample-hex-input" placeholder="FF5733" maxlength="6">
                                </div>
                            </div>
                            
                            <!-- Lab Inputs -->
                            <div id="cmw-custom-lab-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">L*</span>
                                    <input type="number" id="cmw-custom-lab-l" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">a*</span>
                                    <input type="number" id="cmw-custom-lab-a" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">b*</span>
                                    <input type="number" id="cmw-custom-lab-b" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                            </div>
                            
                            <!-- RGB Inputs -->
                            <div id="cmw-custom-rgb-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">R</span>
                                    <input type="number" id="cmw-custom-rgb-r" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">G</span>
                                    <input type="number" id="cmw-custom-rgb-g" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">B</span>
                                    <input type="number" id="cmw-custom-rgb-b" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                            </div>
                            
                            <!-- CMYK Inputs -->
                            <div id="cmw-custom-cmyk-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">C</span>
                                    <input type="number" id="cmw-custom-cmyk-c" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">M</span>
                                    <input type="number" id="cmw-custom-cmyk-m" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">Y</span>
                                    <input type="number" id="cmw-custom-cmyk-y" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">K</span>
                                    <input type="number" id="cmw-custom-cmyk-k" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Add button -->
                        <button id="cmw-custom-add-btn" class="cmw-add-sample-btn">+ Add Color</button>
                    </div>
                    
                    <div class="cmw-custom-library-actions" style="margin-top: 16px;">
                        <button id="cmw-custom-export-btn" class="cmw-custom-export-btn">Export Library</button>
                        <button id="cmw-custom-import-btn" class="cmw-custom-import-btn" title="Import from JSON, CXF, ASE, or CSV file">Import Library</button>
                        <input type="file" id="cmw-custom-import-file" accept=".json,.cxf,.csv,.ase">
                    </div>
                    
                    <div id="cmw-custom-status" class="cmw-status"></div>
                </div>
            </div>
            
            <!-- ========================================
                 COLOR LIBRARY ALPHA (Active/Main)
                 Unified visual library browser & manager
                 Hue spectrum display with sorting options
                 ======================================== -->
            <!-- Color Libraries Browser - Unified Visual Management -->
            <div style="margin-top: 20px;">
                <div id="cmw-libraries-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Color Library</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-libraries-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Browse and manage color libraries visually arranged by hue spectrum
                    </p>
                    
                    <!-- Library Selector and Controls -->
                    <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                        <label style="font-weight: 600; color: #374151;">Select Library:</label>
                        <select id="cmw-libraries-selector" style="padding: 8px 16px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; min-width: 200px;">
                            <option value="">-- Choose a Library --</option>
                        </select>
                        <button id="cmw-libraries-create-btn" class="cmw-compare-btn" style="padding: 8px 16px; background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%); color: white; border: none; border-radius: 6px; font-weight: 600; font-size: 14px; cursor: pointer; transition: all 0.2s; white-space: nowrap;" title="Create a new custom library">
                            + Create Library
                        </button>
                    </div>
                    
                    <!-- Sort Options -->
                    <div id="cmw-libraries-sort-container" style="display: none; align-items: center; justify-content: center; gap: 8px; margin-bottom: 20px;">
                        <label style="font-weight: 600; color: #374151; font-size: 13px;">Sort By:</label>
                        <select id="cmw-libraries-sort" style="padding: 6px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 13px; background: white;">
                            <option value="hue-lightness" selected>Hue → Lightness</option>
                            <option value="hue-saturation">Hue → Saturation</option>
                            <option value="lightness">Lightness (Light to Dark)</option>
                            <option value="saturation">Saturation (Low to High)</option>
                            <option value="hex">Hex Value (#000000 → #FFFFFF)</option>
                            <option value="name">Name (A-Z)</option>
                            <option value="chroma-hue">Chroma → Hue</option>
                        </select>
                    </div>
                    
                    <!-- Library Display Area -->
                    <div id="cmw-libraries-display" style="display: none;">
                        <div style="margin-bottom: 20px;">
                            <!-- Add Color Form (Compact - Custom Libraries Only) -->
                            <div id="cmw-libraries-add-form" style="display: none; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                                <!-- Top Row: Swatch + Inputs Grid -->
                                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <!-- Swatch Preview -->
                                    <div id="cmw-libraries-preview-swatch" style="width: 80px; height: 80px; border-radius: 6px; border: 2px solid #e2e8f0; background: #cbd5e1; flex-shrink: 0;"></div>
                                    
                                    <!-- Color Inputs -->
                                    <div style="flex: 1; display: flex; align-items: center;">
                                        <!-- Hex Input -->
                                        <div id="cmw-libraries-hex-inputs" class="cmw-sample-value-inputs" style="display: none; gap: 6px; align-items: center; width: 100%;">
                                            <input type="text" id="cmw-libraries-hex" placeholder="#FFFFFF" maxlength="7" style="width: 85px; padding: 8px 10px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 13px; font-family: monospace;">
                                        </div>
                                        
                                        <!-- Lab Inputs (Horizontal Row) -->
                                        <div id="cmw-libraries-lab-inputs" class="cmw-sample-value-inputs active" style="display: flex; width: 100%; gap: 6px;">
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">L*</span>
                                                <input type="number" id="cmw-libraries-lab-l" placeholder="100" min="0" max="100" step="0.1" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">a*</span>
                                                <input type="number" id="cmw-libraries-lab-a" placeholder="-128" min="-128" max="127" step="0.1" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">b*</span>
                                                <input type="number" id="cmw-libraries-lab-b" placeholder="-128" min="-128" max="127" step="0.1" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                        </div>
                                        
                                        <!-- RGB Inputs (Horizontal Row) -->
                                        <div id="cmw-libraries-rgb-inputs" class="cmw-sample-value-inputs" style="display: none; width: 100%; gap: 6px;">
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">R</span>
                                                <input type="number" id="cmw-libraries-rgb-r" placeholder="255" min="0" max="255" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">G</span>
                                                <input type="number" id="cmw-libraries-rgb-g" placeholder="255" min="0" max="255" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">B</span>
                                                <input type="number" id="cmw-libraries-rgb-b" placeholder="255" min="0" max="255" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                        </div>
                                        
                                        <!-- CMYK Inputs (Horizontal Row) -->
                                        <div id="cmw-libraries-cmyk-inputs" class="cmw-sample-value-inputs" style="display: none; width: 100%; gap: 6px;">
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">C</span>
                                                <input type="number" id="cmw-libraries-cmyk-c" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">M</span>
                                                <input type="number" id="cmw-libraries-cmyk-m" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">Y</span>
                                                <input type="number" id="cmw-libraries-cmyk-y" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                            <div style="display: flex; gap: 4px; align-items: center;">
                                                <span style="font-size: 11px; font-weight: 600; color: #374151;">K</span>
                                                <input type="number" id="cmw-libraries-cmyk-k" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Bottom Row: Color Name + Format + Add Button -->
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="cmw-libraries-color-name" placeholder="Color Name" style="flex: 1; padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 13px;">
                                    <select id="cmw-libraries-format" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 13px; flex-shrink: 0;">
                                        <option value="hex">Hex</option>
                                        <option value="lab" selected>Lab</option>
                                        <option value="rgb">RGB</option>
                                        <option value="cmyk">CMYK</option>
                                    </select>
                                    <button id="cmw-libraries-add-btn" style="padding: 8px 16px; background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%); color: white; border: none; border-radius: 6px; font-weight: 600; font-size: 13px; cursor: pointer; transition: all 0.2s; white-space: nowrap; flex-shrink: 0;">+ Add</button>
                                </div>
                                
                                <div id="cmw-libraries-add-status" class="cmw-status" style="margin-top: 8px;"></div>
                            </div>
                            
                            <h3 id="cmw-libraries-title" style="text-align: center; color: #1f2937; font-size: 18px; margin-bottom: 16px;"></h3>
                            
                            <!-- Spectrum Canvas -->
                            <div style="background: #f9fafb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                                <canvas id="cmw-libraries-canvas" width="1100" height="50" style="width: 100%; height: 50px; border-radius: 4px; cursor: pointer;"></canvas>
                            </div>
                            
                            <!-- Navigation and Action Buttons -->
                            <div style="display: flex; justify-content: space-between; margin-bottom: 20px; gap: 12px; flex-wrap: wrap;">
                                <div style="display: flex; gap: 12px; flex: 1;">
                                    <button id="cmw-libraries-prev" class="cmw-compare-btn" style="flex: 1; padding: 10px 20px;">
                                        ← Previous
                                    </button>
                                    <button id="cmw-libraries-next" class="cmw-compare-btn" style="flex: 1; padding: 10px 20px;">
                                        Next →
                                    </button>
                                </div>
                                <div style="display: flex; gap: 12px;">
                                    <button id="cmw-libraries-edit-mode" class="cmw-compare-btn" style="padding: 10px 20px; display: none; min-width: 110px;" title="Toggle edit mode to edit or delete colors">
                                        <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; display: inline-block; vertical-align: middle; margin-right: 4px;">
                                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                                        </svg>
                                        Edit
                                    </button>
                                    <button id="cmw-libraries-export" class="cmw-compare-btn" style="padding: 10px 20px; display: none;" title="Export library to file">
                                        <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; display: inline-block; vertical-align: middle; margin-right: 4px;">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                            <polyline points="7 10 12 15 17 10"></polyline>
                                            <line x1="12" y1="15" x2="12" y2="3"></line>
                                        </svg>
                                        Export
                                    </button>
                                    <button id="cmw-libraries-import" class="cmw-compare-btn" style="padding: 10px 20px; display: none;" title="Import colors to this library">
                                        <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; display: inline-block; vertical-align: middle; margin-right: 4px;">
                                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                            <polyline points="17 8 12 3 7 8"></polyline>
                                            <line x1="12" y1="3" x2="12" y2="15"></line>
                                        </svg>
                                        Import
                                    </button>
                                    <button id="cmw-libraries-delete-btn" class="cmw-compare-btn" style="padding: 10px 20px; display: none; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white;" title="Delete this library">
                                        <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; display: inline-block; vertical-align: middle; margin-right: 4px;">
                                            <polyline points="3 6 5 6 21 6"></polyline>
                                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                        </svg>
                                        Delete Library
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Color Grid -->
                        <div id="cmw-libraries-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 12px; margin-top: 20px;">
                            <!-- Color tiles will be populated here -->
                        </div>
                        
                        <div id="cmw-libraries-status" style="text-align: center; color: #6b7280; margin-top: 16px;"></div>
                        
                        <!-- Bottom Navigation Buttons -->
                        <div style="display: flex; justify-content: center; margin-top: 20px; gap: 12px;">
                            <button id="cmw-libraries-prev-bottom" class="cmw-compare-btn" style="padding: 10px 20px; min-width: 140px;">
                                ← Previous
                            </button>
                            <button id="cmw-libraries-next-bottom" class="cmw-compare-btn" style="padding: 10px 20px; min-width: 140px;">
                                Next →
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Color Consensus Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-consensus-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Color Consensus</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-consensus-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Compare multiple color samples and find the perceptual average with outlier detection (ΔE2000)
                    </p>
                    
                    <div class="cmw-threshold-setting">
                        <label for="cmw-outlier-threshold" style="font-weight: 500; color: #374151;">Outlier Threshold (ΔE2000):</label>
                        <input type="number" id="cmw-outlier-threshold" class="cmw-threshold-input" value="3.0" min="0.5" max="10" step="0.5">
                    </div>
                    
                    <div id="cmw-consensus-samples" class="cmw-consensus-samples">
                        <!-- Sample rows will be added here dynamically -->
                    </div>
                    
                    <div class="cmw-add-sample-row">
                        <!-- Swatch preview at top -->
                        <div id="cmw-sample-preview-swatch" class="cmw-sample-preview-swatch-large" title="Color preview"></div>
                        
                        <!-- Label -->
                        <div class="cmw-sample-label-section">
                            <label>Label (optional)</label>
                            <input type="text" id="cmw-sample-label" placeholder="e.g., Sample A, Brand Color...">
                        </div>
                        
                        <!-- Format dropdown -->
                        <div class="cmw-sample-format-row">
                            <label style="font-weight: 500; color: #374151; font-size: 13px;">Format:</label>
                            <select id="cmw-sample-format" class="cmw-sample-format-select">
                                <option value="hex" selected>Hex</option>
                                <option value="lab">Lab</option>
                                <option value="rgb">RGB</option>
                                <option value="cmyk">CMYK</option>
                            </select>
                        </div>
                        
                        <!-- Color inputs -->
                        <div class="cmw-sample-inputs-container">
                            <!-- Hex Input -->
                            <div id="cmw-sample-hex-inputs" class="cmw-sample-value-inputs active">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">#</span>
                                    <input type="text" id="cmw-sample-hex" class="cmw-sample-hex-input" placeholder="FF5733" maxlength="6">
                                </div>
                            </div>
                            
                            <!-- Lab Inputs -->
                            <div id="cmw-sample-lab-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">L*</span>
                                    <input type="number" id="cmw-sample-lab-l" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">a*</span>
                                    <input type="number" id="cmw-sample-lab-a" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">b*</span>
                                    <input type="number" id="cmw-sample-lab-b" class="cmw-sample-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                </div>
                            </div>
                            
                            <!-- RGB Inputs -->
                            <div id="cmw-sample-rgb-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">R</span>
                                    <input type="number" id="cmw-sample-rgb-r" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">G</span>
                                    <input type="number" id="cmw-sample-rgb-g" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">B</span>
                                    <input type="number" id="cmw-sample-rgb-b" class="cmw-sample-input-field" placeholder="0-255" min="0" max="255">
                                </div>
                            </div>
                            
                            <!-- CMYK Inputs -->
                            <div id="cmw-sample-cmyk-inputs" class="cmw-sample-value-inputs">
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">C</span>
                                    <input type="number" id="cmw-sample-cmyk-c" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">M</span>
                                    <input type="number" id="cmw-sample-cmyk-m" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">Y</span>
                                    <input type="number" id="cmw-sample-cmyk-y" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                                <div class="cmw-sample-input-group">
                                    <span class="cmw-sample-input-label">K</span>
                                    <input type="number" id="cmw-sample-cmyk-k" class="cmw-sample-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                </div>
                            </div>
                        </div>
                        
                        <!-- Add button -->
                        <button id="cmw-add-sample-btn" class="cmw-add-sample-btn">+ Add Sample</button>
                    </div>
                
                    <div class="cmw-consensus-actions">
                        <button id="cmw-calculate-consensus-btn" class="cmw-consensus-btn" disabled>Calculate Consensus</button>
                        <button id="cmw-clear-samples-btn" class="cmw-clear-btn">Clear All</button>
                    </div>
                    
                    <div id="cmw-consensus-loading" class="cmw-loading" style="display: none;">
                        <div class="cmw-spinner"></div>
                        <span>Calculating color consensus...</span>
                    </div>
                    
                    <div id="cmw-consensus-result" class="cmw-consensus-result">
                        <div class="cmw-consensus-header">
                            <div id="cmw-consensus-swatch" class="cmw-consensus-swatch"></div>
                            <div class="cmw-consensus-info">
                                <div class="cmw-consensus-title">Consensus Color</div>
                                <div>
                                    <span id="cmw-consensus-lab" class="cmw-consensus-lab">Lab(50.00, 0.00, 0.00)</span>
                                    <span id="cmw-consensus-hex" class="cmw-consensus-hex">#808080</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="cmw-consensus-stats">
                            <div class="cmw-stat-card">
                                <div id="cmw-stat-included" class="cmw-stat-value">0</div>
                                <div class="cmw-stat-label">Samples Included</div>
                            </div>
                            <div class="cmw-stat-card">
                                <div id="cmw-stat-excluded" class="cmw-stat-value">0</div>
                                <div class="cmw-stat-label">Outliers Excluded</div>
                            </div>
                            <div class="cmw-stat-card">
                                <div id="cmw-stat-max-delta" class="cmw-stat-value">0.00</div>
                                <div class="cmw-stat-label">Max ΔE2000</div>
                            </div>
                        </div>
                        
                        <div id="cmw-consensus-warning" class="cmw-consensus-warning" style="display: none;"></div>
                        
                        <div class="cmw-pairwise-section">
                            <div id="cmw-pairwise-toggle" class="cmw-pairwise-toggle">
                                <span><svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                                <span>Show Pairwise Comparisons</span>
                            </div>
                            <div id="cmw-pairwise-grid" class="cmw-pairwise-grid"></div>
                        </div>
                    </div>
                    
                    <div id="cmw-consensus-status" class="cmw-status"></div>
                </div>
            </div>
            
            <!-- Color Compare Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-compare-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Color Compare</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-compare-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Compare two colors and calculate their perceptual difference using ΔE2000
                    </p>
                    
                    <div class="cmw-compare-container">
                        <div class="cmw-compare-colors">
                            <!-- Color 1 -->
                            <div class="cmw-compare-color-box">
                                <h4>Color 1</h4>
                                <div id="cmw-compare-swatch-1" class="cmw-compare-swatch" title="Click for color info"></div>
                                
                                <div class="cmw-compare-inputs">
                                    <div class="cmw-compare-format-row">
                                        <label style="font-size: 12px; color: #6b7280;">Format:</label>
                                        <select id="cmw-compare-format-1" class="cmw-compare-format-select">
                                            <option value="hex" selected>Hex/Name</option>
                                            <option value="lab">Lab</option>
                                            <option value="rgb">RGB</option>
                                            <option value="cmyk">CMYK</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Hex/Name Input -->
                                    <div id="cmw-compare-hex-inputs-1" class="cmw-compare-value-inputs active">
                                        <div class="cmw-compare-input-wrapper">
                                            <input type="text" id="cmw-compare-hex-1" class="cmw-compare-hex-input" placeholder="Hex/Name">
                                            <div id="cmw-compare-suggestions-1" class="cmw-compare-suggestions" style="display: none;"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Lab Inputs -->
                                    <div id="cmw-compare-lab-inputs-1" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">L*</span>
                                            <input type="number" id="cmw-compare-lab-l-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">a*</span>
                                            <input type="number" id="cmw-compare-lab-a-1" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">b*</span>
                                            <input type="number" id="cmw-compare-lab-b-1" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                    </div>
                                    
                                    <!-- RGB Inputs -->
                                    <div id="cmw-compare-rgb-inputs-1" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">R</span>
                                            <input type="number" id="cmw-compare-rgb-r-1" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">G</span>
                                            <input type="number" id="cmw-compare-rgb-g-1" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">B</span>
                                            <input type="number" id="cmw-compare-rgb-b-1" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                    </div>
                                    
                                    <!-- CMYK Inputs -->
                                    <div id="cmw-compare-cmyk-inputs-1" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">C</span>
                                            <input type="number" id="cmw-compare-cmyk-c-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">M</span>
                                            <input type="number" id="cmw-compare-cmyk-m-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">Y</span>
                                            <input type="number" id="cmw-compare-cmyk-y-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">K</span>
                                            <input type="number" id="cmw-compare-cmyk-k-1" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <div id="cmw-compare-values-1" class="cmw-compare-color-values">
                                    Lab: — | Hex: —
                                </div>
                            </div>
                            
                            <!-- Arrow between colors -->
                            <div class="cmw-compare-arrow-between">↔</div>
                            
                            <!-- Color 2 -->
                            <div class="cmw-compare-color-box">
                                <h4>Color 2</h4>
                                <div id="cmw-compare-swatch-2" class="cmw-compare-swatch" title="Click for color info"></div>
                                
                                <div class="cmw-compare-inputs">
                                    <div class="cmw-compare-format-row">
                                        <label style="font-size: 12px; color: #6b7280;">Format:</label>
                                        <select id="cmw-compare-format-2" class="cmw-compare-format-select">
                                            <option value="hex" selected>Hex/Name</option>
                                            <option value="lab">Lab</option>
                                            <option value="rgb">RGB</option>
                                            <option value="cmyk">CMYK</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Hex/Name Input -->
                                    <div id="cmw-compare-hex-inputs-2" class="cmw-compare-value-inputs active">
                                        <div class="cmw-compare-input-wrapper">
                                            <input type="text" id="cmw-compare-hex-2" class="cmw-compare-hex-input" placeholder="Hex/Name">
                                            <div id="cmw-compare-suggestions-2" class="cmw-compare-suggestions" style="display: none;"></div>
                                        </div>
                                    </div>
                                    
                                    <!-- Lab Inputs -->
                                    <div id="cmw-compare-lab-inputs-2" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">L*</span>
                                            <input type="number" id="cmw-compare-lab-l-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">a*</span>
                                            <input type="number" id="cmw-compare-lab-a-2" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">b*</span>
                                            <input type="number" id="cmw-compare-lab-b-2" class="cmw-compare-input-field" placeholder="-128" min="-128" max="127" step="0.1">
                                        </div>
                                    </div>
                                    
                                    <!-- RGB Inputs -->
                                    <div id="cmw-compare-rgb-inputs-2" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">R</span>
                                            <input type="number" id="cmw-compare-rgb-r-2" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">G</span>
                                            <input type="number" id="cmw-compare-rgb-g-2" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">B</span>
                                            <input type="number" id="cmw-compare-rgb-b-2" class="cmw-compare-input-field" placeholder="0-255" min="0" max="255">
                                        </div>
                                    </div>
                                    
                                    <!-- CMYK Inputs -->
                                    <div id="cmw-compare-cmyk-inputs-2" class="cmw-compare-value-inputs">
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">C</span>
                                            <input type="number" id="cmw-compare-cmyk-c-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">M</span>
                                            <input type="number" id="cmw-compare-cmyk-m-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">Y</span>
                                            <input type="number" id="cmw-compare-cmyk-y-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                        <div class="cmw-compare-input-group">
                                            <span class="cmw-compare-input-label">K</span>
                                            <input type="number" id="cmw-compare-cmyk-k-2" class="cmw-compare-input-field" placeholder="0-100" min="0" max="100" step="0.1">
                                        </div>
                                    </div>
                                </div>
                                
                                <div id="cmw-compare-values-2" class="cmw-compare-color-values">
                                    Lab: — | Hex: —
                                </div>
                            </div>
                        </div>
                        
                        <!-- Delta E Result (displayed between color boxes and actions) -->
                        <div id="cmw-compare-result" class="cmw-compare-result">
                            <div class="cmw-compare-delta-display">
                                <span id="cmw-compare-delta-value" class="cmw-compare-delta-value">0.00</span>
                                <span class="cmw-compare-delta-label">ΔE</span>
                                <span id="cmw-compare-delta-interpretation" class="cmw-compare-delta-interpretation">Colors are identical</span>
                            </div>
                        </div>
                        
                        <div class="cmw-compare-actions">
                            <button id="cmw-compare-btn" class="cmw-compare-btn">Compare Colors</button>
                            <button id="cmw-compare-clear-btn" class="cmw-compare-clear-btn">Clear</button>
                        </div>
                    </div>
                    
                    <div id="cmw-compare-status" class="cmw-status"></div>
                </div>
            </div>
            
            <!-- Color Spectrum Browser Section - DEPRECATED: Merged into Color Libraries -->
            <div style="margin-top: 20px; display: none;">
                <div id="cmw-spectrum-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Color Spectrum Browser (Old)</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-spectrum-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Browse all colors from a library arranged by hue spectrum
                    </p>
                    
                    <!-- Library Selector -->
                    <div style="text-align: center; margin-bottom: 24px;">
                        <label style="font-weight: 600; color: #374151; margin-right: 12px;">Select Library:</label>
                        <select id="cmw-spectrum-library" style="padding: 8px 16px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; min-width: 200px;">
                            <option value="">-- Choose a Library --</option>
                        </select>
                    </div>
                    
                    <!-- Spectrum Canvas -->
                    <div id="cmw-spectrum-display" style="display: none;">
                        <div style="margin-bottom: 20px;">
                            <h3 id="cmw-spectrum-title" style="text-align: center; color: #1f2937; font-size: 18px; margin-bottom: 16px;"></h3>
                            <div style="background: #f9fafb; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                                <canvas id="cmw-spectrum-canvas" width="1100" height="50" style="width: 100%; height: 50px; border-radius: 4px; cursor: pointer;"></canvas>
                            </div>
                            
                            <!-- Navigation Buttons -->
                            <div style="display: flex; justify-content: space-between; margin-bottom: 20px; gap: 12px;">
                                <button id="cmw-spectrum-prev" class="cmw-compare-btn" style="flex: 1; padding: 10px 20px;">
                                    ← Previous Colors
                                </button>
                                <button id="cmw-spectrum-next" class="cmw-compare-btn" style="flex: 1; padding: 10px 20px;">
                                    Next Colors →
                                </button>
                            </div>
                        </div>
                        
                        <!-- Color Grid -->
                        <div id="cmw-spectrum-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; margin-top: 20px;">
                            <!-- Color tiles will be populated here -->
                        </div>
                        
                        <div id="cmw-spectrum-status" style="text-align: center; color: #6b7280; margin-top: 16px;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Color Harmony Section (New - Independent from Color Search) -->
            <div style="margin-top: 20px;">
                <div id="cmw-harmony-new-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Color Harmony</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-harmony-new-content" class="cmw-settings-content collapsed">
                    <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 16px 0 20px 0;">
                        Generate color harmonies and palette variations from a base color
                    </p>
                    
                    <div class="cmw-compare-container">
                        <!-- Harmony Options -->
                        <div style="max-width: 600px; margin: 0 auto 24px; padding: 20px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                                <!-- Harmony Type -->
                                <div>
                                    <label style="display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 8px;">Harmony Type:</label>
                                    <select id="cmw-harmony-new-type" style="width: 100%; padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                                        <option value="complementary" selected>Complementary</option>
                                        <option value="triadic">Triadic</option>
                                        <option value="tetradic">Tetradic</option>
                                        <option value="analogous">Analogous</option>
                                        <option value="splitComplementary">Split Complementary</option>
                                        <option value="monochromatic">Monochromatic</option>
                                    </select>
                                </div>
                                
                                <!-- Mode Selection -->
                                <div>
                                    <label style="display: block; font-size: 13px; font-weight: 600; color: #374151; margin-bottom: 8px;">Output Mode:</label>
                                    <select id="cmw-harmony-mode" style="width: 100%; padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                                        <option value="library" selected>Library Colors (Print)</option>
                                        <option value="hex">Hex Values (Screen)</option>
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Library Selection (only shown in library mode) -->
                            <div id="cmw-harmony-library-selector" style="display: block;">
                                <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 16px; margin-bottom: 20px;">
                                    <div style="display: flex; flex-direction: column; gap: 8px; position: relative;">
                                        <label for="cmw-harmony-library-search" style="font-weight: 600; color: #374151; text-align: center;">Active Libraries:</label>
                                        <input 
                                            type="text" 
                                            id="cmw-harmony-library-search" 
                                            placeholder="Type Library Name or ↑↓ to navigate the library list. " 
                                            style="width: 100%; max-width: 500px; margin: 0 auto; padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; text-align: center;"
                                            autocomplete="off"
                                        >
                                        
                                        <!-- Predictive Dropdown -->
                                        <div id="cmw-harmony-library-suggestions" style="display: none; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); width: 100%; max-width: 500px; background: white; border: 2px solid #e2e8f0; border-top: none; border-radius: 0 0 8px 8px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); max-height: 200px; overflow-y: auto; z-index: 1000; margin-top: -8px;">
                                        </div>
                                        
                                        <div style="text-align: center; color: #6b7280; font-size: 12px;">
                                           
                                        </div>
                                    </div>
                                    
                                    <!-- Active Libraries Display -->
                                    <div id="cmw-harmony-active-libraries" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; min-height: 32px; align-items: center;">
                                        <span style="color: #10b981; font-size: 13px; display: flex; align-items: center; gap: 4px;">
                                            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                                <polyline points="20 6 9 17 4 12"></polyline>
                                            </svg>
                                            All libraries active
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Base Color Input Box - Horizontal Layout -->
                        <div style="max-width: 600px; margin: 0 auto 24px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px; padding: 12px;">
                            <!-- Top Row: Swatch + Inputs -->
                            <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                                <!-- Swatch Preview -->
                                <div id="cmw-harmony-swatch" title="Click for color info" style="width: 80px; height: 80px; border-radius: 6px; border: 2px solid #e2e8f0; background: #cbd5e1; flex-shrink: 0; cursor: pointer;"></div>
                                
                                <!-- Color Inputs -->
                                <div style="flex: 1; display: flex; align-items: center;">
                                    <!-- Hex Input -->
                                    <div id="cmw-harmony-hex-inputs" class="cmw-sample-value-inputs active" style="display: flex; gap: 6px; align-items: center; width: 100%; position: relative;">
                                        <input type="text" id="cmw-harmony-hex" placeholder="Enter Hex or Color Name" style="flex: 1; padding: 8px 10px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 13px; font-family: monospace;">
                                        <div id="cmw-harmony-suggestions" class="cmw-compare-suggestions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; z-index: 100;"></div>
                                    </div>
                                    
                                    <!-- Lab Inputs (Horizontal Row) -->
                                    <div id="cmw-harmony-lab-inputs" class="cmw-sample-value-inputs" style="display: none; width: 100%; gap: 6px;">
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">L*</span>
                                            <input type="number" id="cmw-harmony-lab-l" placeholder="100" min="0" max="100" step="0.1" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">a*</span>
                                            <input type="number" id="cmw-harmony-lab-a" placeholder="-128" min="-128" max="127" step="0.1" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">b*</span>
                                            <input type="number" id="cmw-harmony-lab-b" placeholder="-128" min="-128" max="127" step="0.1" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                    </div>
                                    
                                    <!-- RGB Inputs (Horizontal Row) -->
                                    <div id="cmw-harmony-rgb-inputs" class="cmw-sample-value-inputs" style="display: none; width: 100%; gap: 6px;">
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">R</span>
                                            <input type="number" id="cmw-harmony-rgb-r" placeholder="255" min="0" max="255" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">G</span>
                                            <input type="number" id="cmw-harmony-rgb-g" placeholder="255" min="0" max="255" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">B</span>
                                            <input type="number" id="cmw-harmony-rgb-b" placeholder="255" min="0" max="255" style="width: 55px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                    </div>
                                    
                                    <!-- CMYK Inputs (Horizontal Row) -->
                                    <div id="cmw-harmony-cmyk-inputs" class="cmw-sample-value-inputs" style="display: none; width: 100%; gap: 6px;">
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">C</span>
                                            <input type="number" id="cmw-harmony-cmyk-c" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">M</span>
                                            <input type="number" id="cmw-harmony-cmyk-m" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">Y</span>
                                            <input type="number" id="cmw-harmony-cmyk-y" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                        <div style="display: flex; gap: 4px; align-items: center;">
                                            <span style="font-size: 11px; font-weight: 600; color: #374151;">K</span>
                                            <input type="number" id="cmw-harmony-cmyk-k" placeholder="100" min="0" max="100" step="0.1" style="width: 50px; padding: 6px 8px; border: 2px solid #e2e8f0; border-radius: 4px; font-size: 12px; font-family: monospace;">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Bottom Row: Format Dropdown -->
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <select id="cmw-harmony-format" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 13px; flex-shrink: 0; background: white; cursor: pointer;">
                                    <option value="hex" selected>Hex</option>
                                    <option value="lab">Lab</option>
                                    <option value="rgb">RGB</option>
                                    <option value="cmyk">CMYK</option>
                                </select>
                            </div>
                            
                            <div id="cmw-harmony-values" class="cmw-status" style="margin-top: 8px;"></div>
                        </div>
                        
                        <!-- Calculate Button -->
                        <div style="text-align: center; margin-bottom: 24px;">
                            <button id="cmw-harmony-calculate-btn" class="cmw-compare-btn" style="padding: 12px 32px;">
                                Generate Harmonies
                            </button>
                        </div>
                        
                        <!-- Loading State -->
                        <div id="cmw-harmony-loading" class="cmw-loading" style="display: none;">
                            <div class="cmw-spinner"></div>
                            <span>Calculating color harmonies...</span>
                        </div>
                        
                        <!-- Results Display -->
                        <div id="cmw-harmony-colors" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px; margin-top: 16px;">
                            <!-- Harmony colors will be populated here -->
                        </div>
                        
                        <div id="cmw-harmony-status" class="cmw-status"></div>
                        
                        <!-- Palette Variations Section -->
                        <div id="cmw-palette-container" style="display: none; max-width: 900px; margin: 32px auto 0; padding-top: 32px; border-top: 2px solid #e2e8f0;">
                            <h3 style="text-align: center; font-size: 18px; font-weight: 700; color: #1f2937; margin-bottom: 16px;">Palette Variations</h3>
                            <div id="cmw-palette-cards" style="max-height: 600px; overflow-y: auto; padding-right: 8px;">
                                <!-- Multiple palettes will be generated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Color Search Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-color-search-toggle" class="cmw-settings-toggle">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Color Search</span>
                    <div class="cmw-settings-line"></div>
                </div>
                
                <div id="cmw-color-search-content" class="cmw-settings-content">
            
            <!-- Library Search Input -->
            <div style="display: flex; flex-direction: column; gap: 12px; margin-top: 16px; margin-bottom: 20px;">
                <div style="display: flex; flex-direction: column; gap: 8px; position: relative;">
                    <label for="cmw-library-search" style="font-weight: 600; color: #374151; text-align: center;">Active Libraries:</label>
                    <input 
                        type="text" 
                        id="cmw-library-search" 
                        placeholder="Type Library Name or ↑↓ to navigate the library list. " 
                        style="width: 100%; max-width: 500px; margin: 0 auto; padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; text-align: center;"
                        autocomplete="off"
                    >
                    
                    <!-- Predictive Dropdown -->
                    <div id="cmw-library-suggestions" style="display: none; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); width: 100%; max-width: 500px; background: white; border: 2px solid #e2e8f0; border-top: none; border-radius: 0 0 8px 8px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); max-height: 200px; overflow-y: auto; z-index: 1000; margin-top: -8px;">
                    </div>
                    
                    <div style="text-align: center; color: #6b7280; font-size: 12px;">
                       
                    </div>
                </div>
                
                <!-- Active Libraries Display -->
                <div id="cmw-active-libraries-display" style="display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; min-height: 32px; align-items: center;">
                    <span style="color: #10b981; font-size: 13px; display: flex; align-items: center; gap: 4px;">
                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                        All libraries active
                    </span>
                </div>
            </div>
            
            <!-- Hidden checkboxes container for compatibility -->
            <div style="display: none;" id="cmw-public-libraries-container">
                <!-- Public libraries loaded dynamically from libraries.json -->
            </div>
            
            <div style="display: flex; justify-content: center; align-items: center; gap: 24px; margin-top: 16px; margin-bottom: 20px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <label for="cmw-results-count" style="font-weight: 600; color: #374151; white-space: nowrap;">Results per library:</label>
                    <select id="cmw-results-count" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                        <option value="1" selected>1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="5">5</option>
                        <option value="10">10</option>
                    </select>
                </div>
            </div>
            
            <!-- Collapsible Settings Section -->
            <div style="margin-top: 20px;">
                <div id="cmw-settings-toggle" class="cmw-settings-toggle collapsed">
                    <span class="cmw-settings-caret"><svg viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg></span>
                    <span class="cmw-settings-label">Settings</span>
                    <div class="cmw-settings-line"></div>
                </div>
               
                <div id="cmw-settings-content" class="cmw-settings-content collapsed">
                    <div style="height: 1px; background: linear-gradient(to right, transparent, #e2e8f0 20%, #e2e8f0 80%, transparent); margin: 20px 0;"></div>
                   
                    <div style="display: flex; justify-content: center; align-items: center; gap: 24px; margin-top: 16px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="cmw-default-intent" style="font-weight: 600; color: #374151; white-space: nowrap;">Rendering Intent:</label>
                            <select id="cmw-default-intent" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                                <option value="none">None</option>
                                <option value="0">Perceptual</option>
                                <option value="1" selected>Relative Colorimetric</option>
                                <option value="2">Saturation</option>
                                <option value="3">Absolute Colorimetric</option>
                            </select>
                        </div>
                       
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px;">
                            <input type="checkbox" id="cmw-intents-toggle" style="width: 18px; height: 18px; cursor: pointer; accent-color: #0065a3;">
                            <label for="cmw-intents-toggle" style="cursor: pointer; font-size: 15px; color: #374151; font-weight: 500; user-select: none; white-space: nowrap;">Rendering Comparison</label>
                        </div>
                    </div>
                   
                    <div style="height: 1px; background: linear-gradient(to right, transparent, #e2e8f0 20%, #e2e8f0 80%, transparent); margin: 20px 0;"></div>
                   
                    <div style="display: flex; justify-content: center; align-items: center; gap: 24px; margin-top: 16px; flex-wrap: wrap;">
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px;">
                            <input type="checkbox" id="cmw-harmony-toggle" style="width: 18px; height: 18px; cursor: pointer; accent-color: #0065a3;">
                            <label for="cmw-harmony-toggle" style="cursor: pointer; font-size: 15px; color: #374151; font-weight: 500; user-select: none; white-space: nowrap;">Color Harmonies</label>
                        </div>
                       
                        <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px;">
                            <input type="checkbox" id="cmw-gamut-toggle" style="width: 18px; height: 18px; cursor: pointer; accent-color: #0065a3;">
                            <label for="cmw-gamut-toggle" style="cursor: pointer; font-size: 15px; color: #374151; font-weight: 500; user-select: none; white-space: nowrap;">Gamut Indicator</label>
                        </div>
                    </div>
                   
                    <div id="cmw-profile-selector" class="cmw-profile-selector" style="display: none;">
                        <label for="cmw-profile-select" style="font-weight: 600; color: #374151; margin-right: 8px;">ICC Profile for CMYK:</label>
                        <select id="cmw-profile-select" class="cmw-profile-select">
                            <option value="GRACoL2013.icc" selected>GRACoL2013.icc</option>
                            <option value="SWOP2006_Coated3.icc">SWOP2006_Coated3.icc</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="cmw-add-sample-row">
                <!-- Swatch preview at top -->
                <div id="cmw-color-preview" class="cmw-sample-preview-swatch-large"></div>
                
                <!-- Converted color info under swatch -->
                <div id="cmw-converted-color-info" class="cmw-search-color-info-box">
                    <div style="font-size: 12px; color: #6b7280; font-weight: 600;">Converted Lab Values</div>
                    <div id="cmw-converted-color-lab" style="font-size: 14px; color: #374151; font-family: 'SF Mono', Monaco, monospace;"></div>
                    <div id="cmw-converted-cmyk" style="font-size: 14px; color: #374151; font-family: 'SF Mono', Monaco, monospace;"></div>
                </div>
                
                <div id="cmw-selected-color-info" class="cmw-search-color-info-box" style="display: none;">
                    <div id="cmw-selected-color-library" style="font-size: 12px; color: #6b7280; font-weight: 600;"></div>
                    <div id="cmw-selected-color-lab" style="font-size: 14px; color: #374151; font-family: 'SF Mono', Monaco, monospace;"></div>
                </div>

                <!-- Gamut warning -->
                <div id="cmw-gamut-warning" class="cmw-gamut-warning" style="display: none;">
                    <span class="cmw-gamut-icon">⚠️</span>
                    <span id="cmw-gamut-message">Checking gamut...</span>
                </div>

                <!-- Format dropdown -->
                <div class="cmw-sample-format-row">
                    <label style="font-weight: 500; color: #374151; font-size: 13px;">Format:</label>
                    <select id="cmw-search-type-select" class="cmw-sample-format-select">
                        <option value="name" selected>Hex/Name</option>
                        <option value="lab">Lab Values</option>
                        <option value="cmyk">CMYK Values</option>
                        <option value="rgb">RGB Values</option>
                    </select>
                </div>

                <!-- Color inputs -->
                <div class="cmw-sample-inputs-container">
                    <!-- Hex/Name input -->
                    <div id="cmw-name-inputs" class="cmw-sample-value-inputs active">
                        <input id="cmw-name-input" style="width: 100%; max-width: 350px; padding: 12px 16px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 14px; text-align: center;" placeholder="Hex/Name">
                    </div>
                    
                    <!-- Lab inputs -->
                    <div id="cmw-lab-inputs" class="cmw-sample-value-inputs">
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">L*</span>
                            <input id="cmw-lab-l" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">a*</span>
                            <input id="cmw-lab-a" class="cmw-sample-input-field" type="number" placeholder="-128" min="-128" max="127" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">b*</span>
                            <input id="cmw-lab-b" class="cmw-sample-input-field" type="number" placeholder="-128" min="-128" max="127" step="0.1">
                        </div>
                    </div>

                    <!-- CMYK inputs -->
                    <div id="cmw-cmyk-inputs" class="cmw-sample-value-inputs">
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">C</span>
                            <input id="cmw-cmyk-c" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">M</span>
                            <input id="cmw-cmyk-m" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">Y</span>
                            <input id="cmw-cmyk-y" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">K</span>
                            <input id="cmw-cmyk-k" class="cmw-sample-input-field" type="number" placeholder="0-100" min="0" max="100" step="0.1">
                        </div>
                    </div>

                    <!-- RGB inputs -->
                    <div id="cmw-rgb-inputs" class="cmw-sample-value-inputs">
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">R</span>
                            <input id="cmw-rgb-r" class="cmw-sample-input-field" type="number" placeholder="0-255" min="0" max="255">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">G</span>
                            <input id="cmw-rgb-g" class="cmw-sample-input-field" type="number" placeholder="0-255" min="0" max="255">
                        </div>
                        <div class="cmw-sample-input-group">
                            <span class="cmw-sample-input-label">B</span>
                            <input id="cmw-rgb-b" class="cmw-sample-input-field" type="number" placeholder="0-255" min="0" max="255">
                        </div>
                    </div>
                </div>
                
                <!-- Suggestions dropdown -->
                <div id="cmw-name-suggestions" class="cmw-suggestions">
                    <div class="cmw-suggestions-header">Suggestions:</div>
                    <div class="cmw-suggestions-content"></div>
                    <div id="cmw-loading-more" class="cmw-loading-more">Loading more results...</div>
                    <div id="cmw-no-more-results" class="cmw-no-more-results">No more results available</div>
                </div>

                <!-- Search button -->
                <button id="cmw-search-btn" class="cmw-add-sample-btn">Search</button>
            </div>
                </div>
            </div>
        </div>

        <div id="cmw-loading" class="cmw-loading">
            <div class="cmw-spinner"></div>
            <span>Loading color libraries...</span>
        </div>

        <div id="cmw-status" class="cmw-status"></div>

        <!-- Color Harmonies Section -->
        <div id="cmw-harmonies-section" class="cmw-section" style="display: none;">
            <h6>Color Harmonies</h6>
            
            <!-- Tab Navigation -->
            <div style="display: flex; justify-content: center; margin-bottom: 20px; border-bottom: 2px solid #e2e8f0;">
                <button id="cmw-harmonies-tab-harmonies" class="cmw-harmonies-tab active" style="padding: 12px 24px; background: none; border: none; border-bottom: 3px solid #0065a3; color: #0065a3; font-weight: 600; cursor: pointer; font-size: 14px; transition: all 0.2s;">
                    Harmonies
                </button>
                <button id="cmw-harmonies-tab-palette" class="cmw-harmonies-tab" style="padding: 12px 24px; background: none; border: none; border-bottom: 3px solid transparent; color: #6b7280; font-weight: 600; cursor: pointer; font-size: 14px; transition: all 0.2s;">
                    Palette Generator
                </button>
            </div>
            
            <!-- Tab 1: Harmonies (existing) -->
            <div id="cmw-harmonies-tab-content-harmonies" class="cmw-harmonies-tab-content">
                <div style="display: flex; justify-content: center; margin-bottom: 20px;">
                    <select id="cmw-harmony-type" style="padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; background: #ffffff; color: #374151; cursor: pointer;">
                        <option value="complementary" selected>Complementary</option>
                        <option value="triadic">Triadic</option>
                        <option value="tetradic">Tetradic</option>
                        <option value="analogous">Analogous</option>
                        <option value="splitComplementary">Split Complementary</option>
                        <option value="monochromatic">Monochromatic</option>
                    </select>
                </div>
               
                <div id="cmw-harmony-loading" class="cmw-loading">
                    <div class="cmw-spinner"></div>
                    <span>Calculating color harmonies...</span>
                </div>
               
                <div id="cmw-harmony-colors" class="cmw-harmony-colors">
                    <!-- Harmony colors will be populated here -->
                </div>
               
                <div id="cmw-harmony-status" class="cmw-status"></div>
            </div>
            
            <!-- Tab 2: Palette Generator (new) -->
            <div id="cmw-harmonies-tab-content-palette" class="cmw-harmonies-tab-content" style="display: none;">
                <p style="text-align: center; color: #6b7280; font-size: 14px; margin-bottom: 20px;">
                    Create structured UI palettes using Lab(D50) color science and harmony principles
                </p>
                
                <!-- Controls Grid -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px;">
                    <!-- Harmony Mode -->
                    <div>
                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 6px; font-size: 13px;">Harmony Mode</label>
                        <select id="cmw-palette-harmony-mode" style="width: 100%; padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                            <option value="monochromatic">Monochromatic</option>
                            <option value="analogous">Analogous</option>
                            <option value="complementary" selected>Complementary</option>
                            <option value="splitComplementary">Split Complementary</option>
                            <option value="triadic">Triadic</option>
                            <option value="tetradic">Tetradic</option>
                        </select>
                    </div>
                    
                    <!-- Theme -->
                    <div>
                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 6px; font-size: 13px;">Theme</label>
                        <select id="cmw-palette-theme" style="width: 100%; padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                            <option value="light" selected>Light</option>
                            <option value="dark">Dark</option>
                        </select>
                    </div>
                    
                    <!-- Intensity -->
                    <div>
                        <label style="display: block; font-weight: 600; color: #374151; margin-bottom: 6px; font-size: 13px;">Intensity</label>
                        <select id="cmw-palette-intensity" style="width: 100%; padding: 8px 12px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                            <option value="muted">Muted</option>
                            <option value="balanced" selected>Balanced</option>
                            <option value="vivid">Vivid</option>
                        </select>
                    </div>
                </div>
                
                <!-- Generate Button -->
                <div style="text-align: center; margin-bottom: 24px;">
                    <button id="cmw-palette-generate" style="padding: 12px 32px; background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%); color: white; border: none; border-radius: 8px; font-weight: 600; font-size: 14px; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        Generate Palette
                    </button>
                </div>
                
                <!-- Palette Display -->
                <div id="cmw-palette-display" style="display: none;">
                    <!-- Role Swatches -->
                    <div id="cmw-palette-swatches" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 24px;">
                        <!-- Swatches will be generated here -->
                    </div>
                    
                    <!-- Export Buttons -->
                    <div style="display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; margin-top: 24px;">
                        <button id="cmw-palette-copy-json" style="padding: 10px 20px; background: #f3f4f6; border: 2px solid #e2e8f0; border-radius: 6px; color: #374151; font-weight: 600; font-size: 13px; cursor: pointer; transition: all 0.2s;">
                            📋 Copy JSON
                        </button>
                        <button id="cmw-palette-copy-css" style="padding: 10px 20px; background: #f3f4f6; border: 2px solid #e2e8f0; border-radius: 6px; color: #374151; font-weight: 600; font-size: 13px; cursor: pointer; transition: all 0.2s;">
                            📋 Copy CSS Variables
                        </button>
                    </div>
                </div>
                
                <div id="cmw-palette-status" class="cmw-status"></div>
            </div>
        </div>

        <!-- Rendering Intent Comparison Section -->
        <div id="cmw-intents-section" class="cmw-section" style="display: none;">
            <h6>Rendering Comparison</h6>
            <div id="cmw-intents-loading" class="cmw-loading">
                <div class="cmw-spinner"></div>
                <span>Comparing rendering intents...</span>
            </div>
           
            <div id="cmw-intents-grid" class="cmw-intents-grid">
                <div class="cmw-intent-card" id="cmw-intent-perceptual">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Perceptual</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Smooth compression, good for photos</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
               
                <div class="cmw-intent-card" id="cmw-intent-relative">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Relative Colorimetric</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Exact colors where possible</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
               
                <div class="cmw-intent-card" id="cmw-intent-saturation">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Saturation</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Vivid colors for graphics</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
               
                <div class="cmw-intent-card" id="cmw-intent-absolute">
                    <div class="cmw-intent-swatch"></div>
                    <div class="cmw-intent-info">
                        <div class="cmw-intent-name">Absolute Colorimetric</div>
                        <div class="cmw-intent-delta">ΔE: --</div>
                        <div class="cmw-intent-desc">Exact simulation for proofing</div>
                        <div class="cmw-intent-lab">Lab: --</div>
                    </div>
                </div>
            </div>
           
            <div id="cmw-intents-status" class="cmw-status"></div>
        </div>

        <!-- Filter Controls -->
        <div id="cmw-filter-controls" style="display: none; margin: 16px 0; padding: 12px; background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%); border-radius: 8px; border: 1px solid #e2e8f0;">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; font-size: 14px; font-weight: 500; color: #334155;">
                <input type="checkbox" id="cmw-filter-amazon" style="
                    width: 18px;
                    height: 18px;
                    cursor: pointer;
                    accent-color: #FF9900;
                ">
                <span>
                    <img src="https://www.amazon.com/favicon.ico" style="width: 18px; height: 18px; vertical-align: middle; margin-right: 4px;" title="Amazon">
                    Show only colors with Amazon links
                </span>
                <span id="cmw-filter-count" style="margin-left: auto; padding: 4px 10px; background: #FF9900; color: white; border-radius: 12px; font-size: 12px; font-weight: 600;"></span>
            </label>
        </div>

        <table id="cmw-out" hidden>
            <thead>
                <tr>
                    <th>Swatch</th>
                    <th>Name</th>
                    <th>Library</th>
                    <th>ΔE</th>
                    <th>Lab</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <script>
        /* ─────────────────────
           Section 3 Java Part 1
           ───────────────────── */

        /* 1. API Configuration - Update this to match your server */
        function getApiBaseUrl() {
            return document.getElementById('cmw-api-url').value || 'http://localhost:3000';
        }

        /* 2. Global variables */
        let currentAnalysisData = null;
        let currentHarmonyType = 'complementary';
        let libsLoaded = false;
        let currentSearchResults = []; // Store current search results for 3D visualization

        /* 3. Enhanced ΔE 2000 calculation (CIEDE2000)
         * ⚠️  HARD RULE: All Lab values MUST be in Lab(D50) illuminant!
         * ❌ NEVER pass Lab(D65) values here - results will be WRONG
         * ✔  All colors must be converted to Lab(D50) before calling this function
         */
        function dE(L1, a1, b1, L2, a2, b2) {
            const C1 = Math.hypot(a1, b1), C2 = Math.hypot(a2, b2), C̅ = (C1 + C2) / 2,
                G = .5 * (1 - Math.sqrt((C̅ ** 7) / ((C̅ ** 7) + (25 ** 7)))),
                a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.hypot(a1p, b1), C2p = Math.hypot(a2p, b2),
                h1p = Math.atan2(b1, a1p), h2p = Math.atan2(b2, a2p),
                ΔLp = L2 - L1, ΔCp = C2p - C1p;
            let Δhp = h2p - h1p; if (Δhp > Math.PI) Δhp -= 2 * Math.PI; if (Δhp < -Math.PI) Δhp += 2 * Math.PI;
            const ΔHp = 2 * Math.sqrt(C1p * C2p) * Math.sin(Δhp / 2),
                L̅ = (L1 + L2) / 2, C̅p = (C1p + C2p) / 2;
            let h̅p = (h1p + h2p) / 2; if (Math.abs(h1p - h2p) > Math.PI) h̅p += Math.PI;
            const T = 1 - .17 * Math.cos(h̅p - Math.PI / 6) + .24 * Math.cos(2 * h̅p) + .32 * Math.cos(3 * h̅p + Math.PI / 30) - .20 * Math.cos(4 * h̅p - 1.0996),
                ΔRo = .5236 * Math.exp(-(((h̅p * 57.2958 - 275) / 25) ** 2)),
                R_C = 2 * Math.sqrt((C̅p ** 7) / ((C̅p ** 7) + (25 ** 7))),
                S_L = 1 + .015 * ((L̅ - 50) ** 2) / Math.sqrt(20 + (L̅ - 50) ** 2),
                S_C = 1 + .045 * C̅p,
                S_H = 1 + .015 * C̅p * T,
                R_T = -Math.sin(2 * ΔRo) * R_C;
            return Math.sqrt((ΔLp / S_L) ** 2 + (ΔCp / S_C) ** 2 + (ΔHp / S_H) ** 2 + R_T * (ΔCp / S_C) * (ΔHp / S_H));
        }

        /* 4. Lab to RGB conversion - VISUAL PREVIEW ONLY
         * This function is used ONLY for immediate visual feedback in swatches.
         * All actual color data (Lab values, hex, RGB, CMYK) comes from LittleCMS API.
         * This is acceptable because:
         * - The Lab values are already accurate (from library or LittleCMS)
         * - This just provides a quick visual approximation for the swatch background
         * - The actual displayed values are always from LittleCMS
         * - Uses Lab(D50) → XYZ(D50) → CAT16 → XYZ(D65) → sRGB to match backend
         */
        function lab2rgb(L, a, b) {
            // Step 1: Lab(D50) → XYZ(D50)
            // D50 white point (spectrophotometer standard)
            const Xn = 0.96422, Yn = 1.00000, Zn = 0.82521;
            
            const fy = (L + 16) / 116;
            const fx = a / 500 + fy;
            const fz = fy - b / 200;
            
            const delta = 6 / 29;
            const f_inv = t => t > delta ? t ** 3 : 3 * delta * delta * (t - 4 / 29);
            
            const X_d50 = Xn * f_inv(fx);
            const Y_d50 = Yn * f_inv(fy);
            const Z_d50 = Zn * f_inv(fz);
            
            // Step 2: CAT16 chromatic adaptation D50 → D65 (CIE 2016)
            // ⚠️  GUARDRAIL - DO NOT MODIFY WITHOUT UNDERSTANDING:
            // CAT16 is used ONLY for display-referred RGB interpretation.
            // ICC profile transforms (LittleCMS API) must NEVER be overridden.
            // This is NOT a full CAM16 appearance model - just chromatic adaptation.
            // If CAM16-UCS is added later: derived, non-authoritative, UI-only.
            const M_CAT16 = [
                [ 0.401288,  0.650173, -0.051461],
                [-0.250268,  1.204414,  0.045854],
                [-0.002079,  0.048952,  0.953127]
            ];
            const M_CAT16_INV = [
                [ 1.8620678, -1.0112547,  0.1491868],
                [ 0.3875265,  0.6214474, -0.0089739],
                [-0.0158415, -0.0344317,  1.0502732]
            ];
            const D65_WHITE = [95.047, 100.0, 108.883];
            const D50_WHITE = [96.422, 100.0, 82.521];
            
            const matMul = (m, v) => [
                m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
                m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
                m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
            ];
            
            const xyz_d50_100 = [X_d50 * 100, Y_d50 * 100, Z_d50 * 100];
            const RGB_D65 = matMul(M_CAT16, D65_WHITE);
            const RGB_D50 = matMul(M_CAT16, D50_WHITE);
            const scale = [RGB_D65[0]/RGB_D50[0], RGB_D65[1]/RGB_D50[1], RGB_D65[2]/RGB_D50[2]];
            const rgb = matMul(M_CAT16, xyz_d50_100);
            const rgb_adapted = [rgb[0] * scale[0], rgb[1] * scale[1], rgb[2] * scale[2]];
            const xyz_d65_100 = matMul(M_CAT16_INV, rgb_adapted);
            
            const X_d65 = xyz_d65_100[0] / 100;
            const Y_d65 = xyz_d65_100[1] / 100;
            const Z_d65 = xyz_d65_100[2] / 100;
            
            // Step 3: XYZ(D65) → Linear RGB → sRGB
            let r_lin =  3.2404542 * X_d65 - 1.5371385 * Y_d65 - 0.4985314 * Z_d65;
            let g_lin = -0.9692660 * X_d65 + 1.8760108 * Y_d65 + 0.0415560 * Z_d65;
            let b_lin =  0.0556434 * X_d65 - 0.2040259 * Y_d65 + 1.0572252 * Z_d65;
            
            // Gamma correction
            const gamma = c => c <= 0.0031308 ? 12.92 * c : 1.055 * Math.pow(c, 1/2.4) - 0.055;
            
            const r = Math.max(0, Math.min(255, Math.round(gamma(r_lin) * 255)));
            const g = Math.max(0, Math.min(255, Math.round(gamma(g_lin) * 255)));
            const b_ = Math.max(0, Math.min(255, Math.round(gamma(b_lin) * 255)));
            
            return `rgb(${r},${g},${b_})`;
        }

        /* 5. Color conversion utilities */
        function hex2rgb(hex) {
            hex = hex.replace('#', '');
            if (hex.length !== 6) {
                throw new Error('Invalid hex color format');
            }
           
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
           
            return { r, g, b };
        }

        // DEPRECATED: DO NOT USE for Lab calculations - use convertColor() API instead
        // This function is kept only for reference but should never be called
        // All Lab conversions MUST go through LittleCMS API for accuracy
        function rgb2lab(r, g, b) {
            // Mathematical inverse of lab2rgb - includes CAT16 D65→D50 adaptation
            // Step 1: sRGB → Linear RGB (inverse gamma)
            r /= 255;
            g /= 255;
            b /= 255;
           
            const invGamma = c => c > 0.04045 ? Math.pow((c + 0.055) / 1.055, 2.4) : c / 12.92;
            const r_lin = invGamma(r);
            const g_lin = invGamma(g);
            const b_lin = invGamma(b);
           
            // Step 2: Linear RGB → XYZ(D65) (inverse sRGB matrix)
            const X_d65 = r_lin * 0.4124564 + g_lin * 0.3575761 + b_lin * 0.1804375;
            const Y_d65 = r_lin * 0.2126729 + g_lin * 0.7151522 + b_lin * 0.0721750;
            const Z_d65 = r_lin * 0.0193339 + g_lin * 0.1191920 + b_lin * 0.9503041;
           
            // Step 3: CAT16 chromatic adaptation D65 → D50 (inverse of lab2rgb)
            const M_CAT16 = [
                [ 0.401288,  0.650173, -0.051461],
                [-0.250268,  1.204414,  0.045854],
                [-0.002079,  0.048952,  0.953127]
            ];
            const M_CAT16_INV = [
                [ 1.8620678, -1.0112547,  0.1491868],
                [ 0.3875265,  0.6214474, -0.0089739],
                [-0.0158415, -0.0344317,  1.0502732]
            ];
            const D65_WHITE = [95.047, 100.0, 108.883];
            const D50_WHITE = [96.422, 100.0, 82.521];
            
            const matMul = (m, v) => [
                m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2],
                m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2],
                m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2]
            ];
            
            const xyz_d65_100 = [X_d65 * 100, Y_d65 * 100, Z_d65 * 100];
            const RGB_D65 = matMul(M_CAT16, D65_WHITE);
            const RGB_D50 = matMul(M_CAT16, D50_WHITE);
            const scale = [RGB_D50[0]/RGB_D65[0], RGB_D50[1]/RGB_D65[1], RGB_D50[2]/RGB_D65[2]]; // Inverse scale
            const rgb_cone = matMul(M_CAT16, xyz_d65_100);
            const rgb_adapted = [rgb_cone[0] * scale[0], rgb_cone[1] * scale[1], rgb_cone[2] * scale[2]];
            const xyz_d50_100 = matMul(M_CAT16_INV, rgb_adapted);
            
            const X_d50 = xyz_d50_100[0] / 100;
            const Y_d50 = xyz_d50_100[1] / 100;
            const Z_d50 = xyz_d50_100[2] / 100;
           
            // Step 4: XYZ(D50) → Lab(D50)
            const Xn = 0.96422, Yn = 1.00000, Zn = 0.82521; // D50 white point
            
            const f = t => t > Math.pow(6/29, 3) ? Math.pow(t, 1/3) : (Math.pow(29/6, 2) * t / 3) + 4/29;
            
            const fx = f(X_d50 / Xn);
            const fy = f(Y_d50 / Yn);
            const fz = f(Z_d50 / Zn);
           
            const L = 116 * fy - 16;
            const a = 500 * (fx - fy);
            const b_lab = 200 * (fy - fz);
           
            return { L, a, b: b_lab };
        }

        // Note: For user-entered colors, prefer LittleCMS API for accuracy
        function hex2lab(hex) {
            const rgb = hex2rgb(hex);
            return rgb2lab(rgb.r, rgb.g, rgb.b);
        }

        function isValidHex(hex) {
            const original = hex.trim();
           
            if (original.includes(' ')) {
                return false;
            }
           
            const cleanHex = original.replace('#', '');
           
            if (cleanHex.length === 6 && /^[0-9A-Fa-f]+$/.test(cleanHex)) {
                return true;
            }
           
            return false;
        }

        // Note: For user-entered colors, prefer LittleCMS API for accuracy
        function lab2hex(L, a, b) {
            // Use existing lab2rgb function and extract RGB values
            const rgbString = lab2rgb(L, a, b);
            const rgbMatch = rgbString.match(/rgb\((\d+),(\d+),(\d+)\)/);
           
            if (rgbMatch) {
                const r = parseInt(rgbMatch[1]);
                const g = parseInt(rgbMatch[2]);
                const b_val = parseInt(rgbMatch[3]);
               
                // Convert to hex
                const toHex = (num) => {
                    const hex = num.toString(16).padStart(2, '0');
                    return hex.toUpperCase();
                };
               
                return `#${toHex(r)}${toHex(g)}${toHex(b_val)}`;
            }
           
            return '#000000'; // fallback
        }

        /* 6. API Integration Functions */
       
        // Universal color conversion using the new API with rendering intent
        // Rendering intent only applies to OUTPUT conversions (Lab → RGB/CMYK), not INPUT conversions (RGB/CMYK → Lab)
        async function convertColor(inputData) {
            const apiUrl = `${getApiBaseUrl()}/convert`;
           
            const enhancedInputData = { ...inputData };
           
            // Determine if this is an OUTPUT conversion (Lab → RGB/CMYK) where rendering intent applies
            // INPUT conversions (RGB/Hex/CMYK → Lab) should NOT have rendering intent applied
            const isOutputConversion = inputData.lab !== undefined;
            
            // Only add rendering intent for output conversions (Lab → device color space)
            if (isOutputConversion) {
                const currentIntent = document.getElementById('cmw-default-intent').value;
                if (currentIntent !== 'none') {
                    enhancedInputData.renderingIntent = parseInt(currentIntent);
                }
            }
           
            try {
                console.log('API call to:', apiUrl, isOutputConversion ? '(output conversion with intent)' : '(input conversion, no intent)');
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(enhancedInputData)
                });
               
                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    throw new Error(errorData?.error || `HTTP ${response.status}`);
                }
               
                const data = await response.json();
                console.log('API conversion response:', data);
                return data;
               
            } catch (error) {
                console.error('API conversion failed:', error);
                console.error('API URL attempted:', apiUrl);
                console.error('Check if API server is running and accessible from this device');
                throw error;
            }
        }

        // Color harmony calculation with fallback to local libraries
        async function calculateHarmonies(lab, harmonyType = 'complementary') {
            // First try API if available
            const apiUrl = `${getApiBaseUrl()}/harmony`;
            const activeLibs = getActiveLibraries();
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lab: [lab.L, lab.a, lab.b],
                        harmonyType: harmonyType,
                        libraries: activeLibs,
                        profile: 'GRACoL2013.icc'
                    })
                });
               
                if (response.ok) {
                    const data = await response.json();
                    return data;
                }
               
                throw new Error(`API returned ${response.status}`);
               
            } catch (error) {
                console.warn('API harmony calculation failed, using local fallback:', error);
               
                // Fallback to local harmony calculation with your libraries
                return calculateLocalHarmoniesWithLibraryMatching(lab, harmonyType);
            }
        }

        // Enhanced local harmony calculation with library matching
        function calculateLocalHarmoniesWithLibraryMatching(lab, harmonyType) {
            const harmonies = [];
            const usedColorNames = new Set(); // Track used color names to avoid duplicates
           
            // First, add the ORIGINAL color as the first harmony
            // Don't exclude self-match for the original color - we want the actual library match
            const originalMatches = findClosestInAllLibraries(lab, 1, false);
            if (originalMatches.length > 0) {
                usedColorNames.add(originalMatches[0].name.toLowerCase());
            }
            harmonies.push({
                lab: [lab.L, lab.a, lab.b],
                gamut: { inGamut: true },
                libraryMatches: groupMatchesByLibrary(originalMatches),
                isOriginal: true
            });
           
            // Then calculate harmony colors
            const baseHue = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
            const baseChroma = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
           
            let hueOffsets = [];
            switch (harmonyType) {
                case 'complementary':
                    hueOffsets = [180]; // Only complementary, original is already added
                    break;
                case 'triadic':
                    hueOffsets = [120, 240]; // Two additional colors
                    break;
                case 'tetradic':
                    hueOffsets = [90, 180, 270]; // Three additional colors
                    break;
                case 'analogous':
                    hueOffsets = [30, -30]; // Two additional colors
                    break;
                case 'splitComplementary':
                    hueOffsets = [150, 210]; // Two additional colors
                    break;
                case 'monochromatic':
                    hueOffsets = [0, 0, 0, 0]; // Four variations of the same hue
                    break;
                default:
                    hueOffsets = [180];
            }
           
            hueOffsets.forEach((offset, index) => {
                let newLab;
                if (harmonyType === 'monochromatic') {
                    // Create more dramatic lightness variations for monochromatic
                    const lightnessMods = [-35, -20, +20, +35];
                    const lightnessMod = lightnessMods[index] || 0;
                    newLab = {
                        L: Math.max(10, Math.min(90, lab.L + lightnessMod)),
                        a: lab.a * 0.8, // Slightly reduce saturation for variety
                        b: lab.b * 0.8
                    };
                } else {
                    const newHue = (baseHue + offset) * Math.PI / 180;
                    // Vary the chroma slightly to get more diverse matches
                    const chromaVariation = 0.8 + (index * 0.1); // 0.8, 0.9, 1.0, 1.1
                    const adjustedChroma = baseChroma * chromaVariation;
                    newLab = {
                        L: lab.L + (index % 2 === 0 ? -5 : 5), // Slight lightness variation
                        a: adjustedChroma * Math.cos(newHue),
                        b: adjustedChroma * Math.sin(newHue)
                    };
                }
               
                // Find matches but exclude already used colors
                const libraryMatches = findUniqueLibraryMatches(newLab, usedColorNames, 3);
               
                // Add the best match to used names
                if (libraryMatches.length > 0) {
                    usedColorNames.add(libraryMatches[0].name.toLowerCase());
                }
               
                harmonies.push({
                    lab: [newLab.L, newLab.a, newLab.b],
                    gamut: { inGamut: true },
                    libraryMatches: groupMatchesByLibrary(libraryMatches),
                    isOriginal: false
                });
            });
           
            return { colors: harmonies };
        }

        // Find library matches while excluding already used color names
        function findUniqueLibraryMatches(targetLab, usedNames, maxResults = 5) {
            const activeLibs = getActiveLibraries();
            const allMatches = [];
            const seenLabValues = new Set(); // Track Lab values to prevent duplicates
           
            for (const libId of activeLibs) {
                const lib = libs[libId];
                if (!lib || lib.length === 0) continue;
               
                for (const color of lib) {
                    // Skip if we've already used this color name
                    if (usedNames.has(color.name.toLowerCase())) {
                        continue;
                    }
                    
                    // Create a key from Lab values (rounded to 1 decimal for matching)
                    const labKey = `${color.L.toFixed(1)}_${color.a.toFixed(1)}_${color.b.toFixed(1)}`;
                    
                    // Skip if we've already seen this Lab value (same color in different library)
                    if (seenLabValues.has(labKey)) {
                        continue;
                    }
                    seenLabValues.add(labKey);
                   
                    const deltaE = dE(targetLab.L, targetLab.a, targetLab.b, color.L, color.a, color.b);
                    allMatches.push({
                        name: color.name,
                        library: color.libraryName || libNames[libId],
                        deltaE: deltaE,
                        lab: [color.L, color.a, color.b],
                        colorData: color
                    });
                }
            }
           
            // Sort by deltaE and return top matches
            allMatches.sort((a, b) => a.deltaE - b.deltaE);
            return allMatches.slice(0, maxResults);
        }

        // Find closest colors across all active libraries
        function findClosestInAllLibraries(targetLab, maxResults = 5, excludeSelfMatch = true) {
            const activeLibs = getActiveLibraries();
            const allMatches = [];
            const seenLabValues = new Set(); // Track Lab values to prevent duplicates
           
            for (const libId of activeLibs) {
                const lib = libs[libId];
                if (!lib || lib.length === 0) continue;
               
                for (const color of lib) {
                    const deltaE = dE(targetLab.L, targetLab.a, targetLab.b, color.L, color.a, color.b);
                    
                    // ALWAYS exclude perfect self-matches (deltaE < 0.01)
                    if (excludeSelfMatch && deltaE < 0.01) {
                        console.log('🚫 Excluding self-match in findClosestInAllLibraries:', color.name, 'deltaE:', deltaE);
                        continue;
                    }
                    
                    // Create a key from Lab values (rounded to 1 decimal for matching)
                    const labKey = `${color.L.toFixed(1)}_${color.a.toFixed(1)}_${color.b.toFixed(1)}`;
                    
                    // Skip if we've already seen this Lab value (same color in different library)
                    if (seenLabValues.has(labKey)) {
                        continue;
                    }
                    seenLabValues.add(labKey);
                    
                    allMatches.push({
                        name: color.name,
                        library: color.libraryName || libNames[libId],
                        deltaE: deltaE,
                        lab: [color.L, color.a, color.b],
                        colorData: color // Keep full color data
                    });
                }
            }
           
            // Sort by deltaE and return top matches
            allMatches.sort((a, b) => a.deltaE - b.deltaE);
            return allMatches.slice(0, maxResults);
        }

        // Group matches by library for display
        function groupMatchesByLibrary(matches) {
            const grouped = {};
           
            matches.forEach(match => {
                const libKey = match.library.toLowerCase().replace(/\s+/g, '');
                if (!grouped[libKey]) {
                    grouped[libKey] = [];
                }
                grouped[libKey].push(match);
            });
           
            return grouped;
        }

        // Rendering intent comparison - Lab-based approach for consistency, keeping originalData for context
        // For CMYK and Library colors: now uses Lab values instead of original CMYK for consistent behavior
        // For RGB, Hex, Lab: maintains existing working behavior
        async function compareRenderingIntents(lab, originalData = null) {
            const apiUrl = `${getApiBaseUrl()}/rendering-intents`;
           
            try {
                console.log('Making rendering intent API call to:', apiUrl);
               
                // Always use Lab values for the actual API call to ensure consistency
                // This makes CMYK and Library colors work the same as RGB/Hex/Lab
                const requestData = {
                    lab: [lab.L, lab.a, lab.b],
                    targetProfile: 'GRACoL2013.icc'
                };
                console.log('Lab rendering intent request:', requestData);
               
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
               
                if (!response.ok) {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    console.error('Rendering intent API error:', response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
               
                const data = await response.json();
                console.log('Rendering intent API response:', data);
                return data;
               
            } catch (error) {
                console.error('Rendering intent comparison failed:', error);
                console.error('API URL attempted:', apiUrl);
                console.error('Lab values sent:', lab);
                console.error('Original data sent:', originalData);
               
                // Try alternative API endpoint naming
                try {
                    console.log('Trying alternative API endpoint...');
                    const altApiUrl = `${getApiBaseUrl()}/compare-rendering-intents`;
                   
                    // Always use Lab values for alternative endpoint too
                    const altRequestData = {
                        lab: [lab.L, lab.a, lab.b],
                        profile: 'GRACoL2013.icc'
                    };
                   
                    const altResponse = await fetch(altApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(altRequestData)
                    });
                   
                    if (altResponse.ok) {
                        const altData = await altResponse.json();
                        console.log('Alternative API successful:', altData);
                        return altData;
                    }
                } catch (altError) {
                    console.warn('Alternative API also failed:', altError);
                }
               
                throw error;
            }
        }

        // Gamut checking
        async function checkGamut(lab, profile = 'GRACoL2013.icc') {
            const apiUrl = `${getApiBaseUrl()}/gamut-check`;
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lab: [lab.L, lab.a, lab.b],
                        profile: profile
                    })
                });
               
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const data = await response.json();
                return data.gamut;
               
            } catch (error) {
                console.error('Gamut check failed:', error);
                return null;
            }
        }

        // Combined analysis for efficiency
        async function analyzeColor(lab, options = {}) {
            const apiUrl = `${getApiBaseUrl()}/analyze-color`;
            const activeLibs = getActiveLibraries();
           
            const requestData = {
                lab: [lab.L, lab.a, lab.b],
                profile: 'GRACoL2013.icc',
                includeHarmony: options.includeHarmony || false,
                harmonyType: options.harmonyType || 'complementary',
                libraries: activeLibs,
                includeRenderingIntents: options.includeRenderingIntents || false,
                includeGamutBoundary: false  // We don't need 3D data for this UI
            };
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
               
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const data = await response.json();
                return data;
               
            } catch (error) {
                console.error('Color analysis failed:', error);
                throw error;
            }
        }

        /* 7. Dynamic Library Loading System */
        // Always use GitHub for production (use index-local.html for local testing)
        const BASE_URL = 'https://raw.githubusercontent.com/Lrrr908/bastards-of-the-multiverse/main/files/theme/';
        const libs = {};
        const libNames = {};
        let libraryManifest = [];

        // Default library configuration (fallback if manifest doesn't exist yet)
        const defaultLibraries = [
            { id: "pantone", name: "PMS", file: "pantone.json", enabled: true },
            { id: "behr", name: "Behr", file: "behr.json", enabled: true },
            { id: "sherwin", name: "Sherwin Williams", file: "sherwin.json", enabled: true },
            { id: "bm", name: "Benjamin Moore", file: "benjaminmoore.json", enabled: true }
        ];

        // Load the library manifest and initialize all libraries
        async function initializeLibraries() {
            try {
                const manifestUrl = BASE_URL + 'libraries.json';
                console.log('=== INITIALIZING LIBRARIES ===');
                console.log('Manifest URL:', manifestUrl);
                
                let manifestData;
                try {
                    const manifestRes = await fetch(manifestUrl);
                    console.log('Manifest fetch response:', manifestRes.status, manifestRes.statusText);
                    
                    if (manifestRes.ok) {
                        manifestData = await manifestRes.json();
                        console.log('✔ Manifest loaded from server');
                    } else {
                        throw new Error(`HTTP ${manifestRes.status}`);
                    }
                } catch (manifestError) {
                    console.warn('⚠ Manifest not found, using default libraries:', manifestError.message);
                    manifestData = { libraries: defaultLibraries };
                }
                
                console.log('Manifest data:', manifestData);
                
                if (!manifestData.libraries || !Array.isArray(manifestData.libraries)) {
                    throw new Error('Invalid manifest format: missing libraries array');
                }
                
                libraryManifest = manifestData.libraries.filter(lib => lib.enabled);
                
                console.log(`✔ ${libraryManifest.length} libraries enabled`);
                
                // Create checkboxes for each library
                const container = document.getElementById('cmw-public-libraries-container');
                if (!container) {
                    throw new Error('Library container not found in DOM');
                }
                
                libraryManifest.forEach(lib => {
                    libNames[lib.id] = lib.name;
                    
                    const toggleItem = document.createElement('div');
                    toggleItem.className = 'cmw-toggle-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `toggle-${lib.id}`;
                    checkbox.value = lib.id;
                    checkbox.checked = true; // Start with all libraries active
                    
                    const label = document.createElement('label');
                    label.htmlFor = `toggle-${lib.id}`;
                    
                    const labelText = document.createTextNode(lib.name + ' ');
                    const countSpan = document.createElement('span');
                    countSpan.className = 'cmw-library-count';
                    countSpan.id = `count-${lib.id}`;
                    countSpan.textContent = '(0)';
                    
                    label.appendChild(labelText);
                    label.appendChild(countSpan);
                    toggleItem.appendChild(checkbox);
                    toggleItem.appendChild(label);
                    container.appendChild(toggleItem);
                    
                    console.log(`Created checkbox for library: ${lib.name}`);
                });
                
                // Add custom libraries container inside the grid (uses display:contents to flow)
                const customContainer = document.createElement('div');
                customContainer.id = 'cmw-custom-libraries-container';
                customContainer.style.display = 'contents';
                container.appendChild(customContainer);
                
                console.log('Custom libraries container added to grid');
                
                // Load all library data files (use allSettled to continue even if some fail)
                const loadPromises = libraryManifest.map(lib => {
                    // Determine URL - use lib.url if specified, otherwise construct from BASE_URL + file
                    const url = lib.url || (lib.source === 'url' ? lib.url : BASE_URL + lib.file);
                    const format = lib.format || 'json';
                    return loadLibrary(lib.id, url, lib.name, format);
                });
                const results = await Promise.allSettled(loadPromises);
                
                const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
                console.log(`✔ Libraries initialized: ${successCount}/${libraryManifest.length} loaded successfully`);
            } catch (e) {
                console.error('✖ Failed to initialize libraries:', e);
                // Continue even if manifest fails - show empty state
            }
        }

        async function loadLibrary(id, url, name, format = 'json') {
            try {
                console.log(`Loading ${name} from ${url} (format: ${format})...`);
                const res = await fetch(url);
                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }
                
                let colors;
                
                // Handle different formats
                if (format === 'filamentcolors') {
                    // Filament Colors format - may have RGB that needs conversion
                    const data = await res.json();
                    colors = await parseFilamentColorsData(data, name);
                } else if (format === 'cxf') {
                    // CXF format - needs API endpoint
                    const blob = await res.blob();
                    colors = await parseCxfData(blob, name);
                } else if (format === 'csv') {
                    // CSV format - needs API endpoint
                    const text = await res.text();
                    colors = await parseCsvData(text, name);
                } else if (format === 'nested') {
                    // Nested format with rgb/lab/cmyk objects
                    const data = await res.json();
                    colors = parseNestedFormat(data, name);
                } else {
                    // Default JSON format - auto-detect if nested
                    const data = await res.json();
                    
                    // Check if it's nested format by looking at first item
                    if (Array.isArray(data) && data.length > 0 && data[0]) {
                        const first = data[0];
                        const hasNestedStructure = (
                            (first.rgb && typeof first.rgb === 'object' && 'r' in first.rgb) ||
                            (first.lab && typeof first.lab === 'object' && 'l' in first.lab) ||
                            (first.cmyk && typeof first.cmyk === 'object' && 'c' in first.cmyk)
                        );
                        
                        if (hasNestedStructure) {
                            console.log(`✓ Auto-detected nested format for ${name}`);
                            colors = parseNestedFormat(data, name);
                        } else {
                            colors = data;
                        }
                    } else {
                        colors = data;
                    }
                }
                
                // Validate it's an array
                if (!Array.isArray(colors)) {
                    throw new Error('Library data must be an array');
                }
                
                // Map colors and ensure required fields exist
                libs[id] = colors.map((color, index) => {
                    // Debug: Check what data we have
                    if (index === 0) {
                        console.log(`  ${name} Color 0 input:`, { 
                            hasL: 'L' in color, 
                            LType: typeof color.L,
                            LValue: color.L,
                            hasSpectral: !!color.spectral 
                        });
                    }
                    
                    // AUTO-FIX: Calculate Lab from spectral data if Lab is missing but spectral exists
                    if ((typeof color.L !== 'number') && color.spectral && color.spectral.reflectance && color.spectral.wavelengths) {
                        try {
                            const labFromSpectral = calculateLabFromSpectral(color.spectral);
                            color.L = labFromSpectral.L;
                            color.a = labFromSpectral.a;
                            color.b = labFromSpectral.b;
                            color.lab_calculated = true;  // Flag that Lab was calculated, not measured
                            if (index < 2) {
                                console.log(`  ${name} Color ${index}: Lab AUTO-CALCULATED from spectral: L=${color.L.toFixed(2)}, a=${color.a.toFixed(2)}, b=${color.b.toFixed(2)}`);
                            }
                        } catch (err) {
                            console.warn(`  ${name} Color ${index}: Failed to calculate Lab from spectral:`, err.message);
                        }
                    }
                    
                    // Validate required fields
                    if (typeof color.L !== 'number' || typeof color.a !== 'number' || typeof color.b !== 'number') {
                        console.warn(`${name}: Color at index ${index} missing Lab values and no spectral data to calculate from, skipping`);
                        return null;
                    }
                    
                    return {
                        name: color.name || `Unnamed ${index + 1}`,
                        L: color.L,
                        a: color.a,
                        b: color.b,
                        hex: color.hex || '#808080',
                        library: id,
                        libraryName: name,
                        // Preserve ALL original fields from the color object
                        ...color,
                        // But ensure these core fields are correct
                        library: id,
                        libraryName: name
                    };
                }).filter(Boolean); // Remove any null entries
               
                const countEl = document.getElementById(`count-${id}`);
                if (countEl) {
                    countEl.textContent = `(${libs[id].length})`;
                }
               
                console.log(`✔ ${name} loaded successfully (${libs[id].length} colors)`);
                return true;
            } catch (e) {
                console.error(`✖ ${name} failed to load:`, e.message, `(${url})`);
                libs[id] = [];
                
                // Update count to show 0
                const countEl = document.getElementById(`count-${id}`);
                if (countEl) {
                    countEl.textContent = '(0)';
                }
                return false;
            }
        }
        
        // Calculate Lab values from spectral reflectance data
        function calculateLabFromSpectral(spectral) {
            // CIE 1931 2° Standard Observer color matching functions (official CIE tables at 10nm intervals, 400-700nm)
            const cmf_x = [
                0.014310, 0.043510, 0.134380, 0.283900, 0.348280, 0.336200, 0.290800, 0.195360,
                0.095640, 0.032010, 0.004900, 0.009300, 0.063270, 0.165500, 0.290400, 0.433450,
                0.594500, 0.762100, 0.916300, 1.026300, 1.062200, 1.002600, 0.854450, 0.642400,
                0.447900, 0.283500, 0.164900, 0.087400, 0.046770, 0.022700, 0.011359
            ];
            
            const cmf_y = [
                0.000396, 0.001210, 0.004000, 0.011600, 0.023000, 0.038000, 0.060000, 0.090980,
                0.139020, 0.208020, 0.323000, 0.503000, 0.710000, 0.862000, 0.954000, 0.994950,
                0.995000, 0.952000, 0.870000, 0.757000, 0.631000, 0.503000, 0.381000, 0.265000,
                0.175000, 0.107000, 0.061000, 0.032000, 0.017000, 0.008210, 0.004102
            ];
            
            const cmf_z = [
                0.067850, 0.207400, 0.645600, 1.385600, 1.747060, 1.772110, 1.669200, 1.287640,
                0.812950, 0.465180, 0.272000, 0.158200, 0.078250, 0.042160, 0.020300, 0.008750,
                0.003900, 0.002100, 0.001650, 0.001100, 0.000800, 0.000340, 0.000190, 0.000050,
                0.000020, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
            ];
            
            // CIE D50 Standard Illuminant (official CIE tables at 10nm intervals, 400-700nm)
            const d50 = [
                24.492, 27.180, 29.870, 39.589, 44.905, 52.311, 57.292, 59.947, 58.866, 57.441,
                74.349, 87.140, 90.057, 89.802, 87.699, 83.288, 80.026, 73.067, 75.535, 68.290,
                63.059, 65.744, 61.604, 57.876, 66.325, 71.315, 77.431, 65.382, 71.146, 75.087, 63.592
            ];
            
            const reflectances = spectral.reflectance;
            
            // Calculate XYZ tristimulus values
            let X = 0, Y = 0, Z = 0;
            for (let i = 0; i < 31; i++) {
                X += reflectances[i] * d50[i] * cmf_x[i];
                Y += reflectances[i] * d50[i] * cmf_y[i];
                Z += reflectances[i] * d50[i] * cmf_z[i];
            }
            
            // Normalize by D50 white point (sum of illuminant * CMF)
            let Xn = 0, Yn = 0, Zn = 0;
            for (let i = 0; i < 31; i++) {
                Xn += d50[i] * cmf_x[i];
                Yn += d50[i] * cmf_y[i];
                Zn += d50[i] * cmf_z[i];
            }
            
            // Normalize to Y=100 (standard practice)
            const k = 100 / Yn;
            X = X * k;
            Y = Y * k;
            Z = Z * k;
            Xn = Xn * k;
            Yn = 100.0;  // By definition after normalization
            Zn = Zn * k;
            
            // Convert XYZ to Lab
            const f = (t) => {
                const delta = 6/29;
                const delta3 = delta * delta * delta;
                return t > delta3 ? Math.pow(t, 1/3) : (t / (3 * delta * delta)) + (4/29);
            };
            
            const fx = f(X / Xn);
            const fy = f(Y / Yn);
            const fz = f(Z / Zn);
            
            const L = 116 * fy - 16;
            const a = 500 * (fx - fy);
            const b = 200 * (fy - fz);
            
            // Apply 3rd order polynomial correction to match X-Rite M1 measurements
            // Trained on ALL 1,755 Pantone C colors: avg ΔE 0.481, 88.8% < 1.0 ΔE, 99.4% < 2.0 ΔE
            
            // Polynomial coefficients (order: 1, L, a, b, L², La, Lb, a², ab, b², L³, L²a, L²b, La², Lab, Lb², a³, a²b, ab², b³)
            const poly_coef_l = [
                -0.0341064917, 1.0037413903, 0.0281938218, 0.0027561138, -0.0000875119, 0.0000518683,
                -0.0000815053, 0.0000782886, 0.0000797039, -0.0000005876, 0.0000005556, -0.0000004623,
                0.0000009161, -0.0000000833, -0.0000004122, -0.0000006336, -0.0000001742, -0.0000000740,
                -0.0000002125, 0.0000002969
            ];
            
            const poly_coef_a = [
                0.0850179516, -0.0127555749, 0.9340907286, -0.0877492777, 0.0003934306, 0.0004386812,
                0.0014711737, 0.0000874518, 0.0008269526, 0.0001659179, -0.0000030099, -0.0000024633,
                -0.0000120200, -0.0000057308, -0.0000101630, 0.0000047637, -0.0000002976, -0.0000024370,
                -0.0000024493, -0.0000031540
            ];
            
            const poly_coef_b = [
                -0.2221444574, 0.0211069153, 0.0306527329, 1.0101868457, -0.0003315634, 0.0003302456,
                0.0002979834, 0.0002496199, -0.0000441800, 0.0001264384, 0.0000017392, -0.0000028147,
                -0.0000024009, -0.0000016096, 0.0000003167, -0.0000005321, -0.0000008889, -0.0000002982,
                -0.0000026356, 0.0000010643
            ];
            
            // Generate polynomial features: [1, L, a, b, L², La, Lb, a², ab, b², L³, L²a, L²b, La², Lab, Lb², a³, a²b, ab², b³]
            const features = [
                1,
                L, a, b,
                L*L, L*a, L*b, a*a, a*b, b*b,
                L*L*L, L*L*a, L*L*b, L*a*a, L*a*b, L*b*b, a*a*a, a*a*b, a*b*b, b*b*b
            ];
            
            // Apply polynomial correction
            let L_corrected = 0, a_corrected = 0, b_corrected = 0;
            for (let i = 0; i < 20; i++) {
                L_corrected += poly_coef_l[i] * features[i];
                a_corrected += poly_coef_a[i] * features[i];
                b_corrected += poly_coef_b[i] * features[i];
            }
            
            return { L: L_corrected, a: a_corrected, b: b_corrected };
        }
        
        // Parse nested format (with rgb/lab/cmyk objects)
        function parseNestedFormat(data, libraryName) {
            console.log(`Parsing nested format data for ${libraryName}...`);
            
            if (!Array.isArray(data)) {
                console.error('Nested format must be an array');
                return [];
            }
            
            const colors = [];
            for (let i = 0; i < data.length; i++) {
                const item = data[i];
                if (!item || typeof item !== 'object') continue;
                
                // Start with all original data
                const color = { ...item };
                
                // Ensure name is set
                if (!color.name) {
                    color.name = `Color ${i+1}`;
                }
                
                // Flatten nested rgb object if present
                if (item.rgb && typeof item.rgb === 'object') {
                    color.rgb_r = item.rgb.r;
                    color.rgb_g = item.rgb.g;
                    color.rgb_b = item.rgb.b;
                }
                
                // Flatten nested lab object if present (REQUIRED for color matching)
                if (item.lab && typeof item.lab === 'object') {
                    color.L = item.lab.l;
                    color.a = item.lab.a;
                    color.b = item.lab.b;
                    
                    // Log first few for debugging
                    if (i < 2) {
                        console.log(`  Color ${i}: Lab from nested: L=${color.L}, a=${color.a}, b=${color.b}`);
                    }
                }
                
                // AUTO-FIX: Calculate Lab from spectral data if Lab is missing but spectral exists
                if ((!color.L && color.L !== 0) && item.spectral && item.spectral.reflectance && item.spectral.wavelengths) {
                    try {
                        const labFromSpectral = calculateLabFromSpectral(item.spectral);
                        color.L = labFromSpectral.L;
                        color.a = labFromSpectral.a;
                        color.b = labFromSpectral.b;
                        color.lab_calculated = true;  // Flag that Lab was calculated, not measured
                        if (i < 2) {
                            console.log(`  Color ${i}: Lab AUTO-CALCULATED from spectral: L=${color.L.toFixed(2)}, a=${color.a.toFixed(2)}, b=${color.b.toFixed(2)}`);
                        }
                    } catch (err) {
                        console.warn(`  Color ${i}: Failed to calculate Lab from spectral:`, err.message);
                    }
                }
                
                // Flatten nested cmyk object if present
                if (item.cmyk && typeof item.cmyk === 'object') {
                    color.cmyk_c = item.cmyk.c;
                    color.cmyk_m = item.cmyk.m;
                    color.cmyk_y = item.cmyk.y;
                    color.cmyk_k = item.cmyk.k;
                }
                
                // Ensure hex is present
                if (!color.hex && item.hex) {
                    color.hex = item.hex;
                }
                
                colors.push(color);
            }
            
            console.log(`✔ Parsed ${colors.length} colors from nested format`);
            return colors;
        }
        
        // Parse Filament Colors format (handles RGB -> Lab conversion)
        async function parseFilamentColorsData(data, libraryName) {
            console.log(`Parsing Filament Colors data for ${libraryName}...`);
            console.log('Data structure:', Array.isArray(data) ? 'Array' : 'Object', 'Length/Keys:', Array.isArray(data) ? data.length : Object.keys(data).length);
            
            // Handle different data structures
            let colorArray = [];
            if (Array.isArray(data)) {
                colorArray = data;
            } else if (data.swatches && Array.isArray(data.swatches)) {
                // FilamentColors.xyz format
                colorArray = data.swatches;
                console.log(`FilamentColors format detected. Total: ${data.metadata?.total_swatches || colorArray.length}`);
            } else if (data.colors && Array.isArray(data.colors)) {
                colorArray = data.colors;
            } else if (typeof data === 'object') {
                // Maybe it's an object with color keys
                colorArray = Object.values(data).filter(v => typeof v === 'object');
            }
            
            console.log(`Found ${colorArray.length} color entries to process`);
            
            // Log first item structure for debugging
            if (colorArray.length > 0) {
                console.log('First swatch structure:', colorArray[0]);
            }
            
            const API_URL = document.getElementById('cmw-api-url')?.value || 'http://localhost:8000';
            const colors = [];
            const failedConversions = [];
            
            // Process colors with better error handling
            for (let i = 0; i < colorArray.length; i++) {
                const item = colorArray[i];
                if (!item || typeof item !== 'object') continue;
                
                // Debug first few items
                if (i < 3) {
                    console.log(`Processing item ${i}:`, item);
                }
                
                // Normalize field names from FilamentColors format
                let color = { ...item };
                
                // Map FilamentColors field names to standard names
                if (item.color_name && !color.name) color.name = item.color_name;
                if (item.hex_color && !color.hex) color.hex = item.hex_color;
                if (item.lab_l !== null && item.lab_l !== undefined && !color.L) color.L = item.lab_l;
                if (item.lab_a !== null && item.lab_a !== undefined && !color.a) color.a = item.lab_a;
                if (item.lab_b !== null && item.lab_b !== undefined && !color.b) color.b = item.lab_b;
                // Use amazon_link to match what display code expects
                if (item.amazon_purchase_link && !color.amazon_link) color.amazon_link = item.amazon_purchase_link;
                if (item.manufacturer_purchase_link && !color.manufacturer_link) color.manufacturer_link = item.manufacturer_purchase_link;
                
                const colorId = color.name || color.id || `Color ${i+1}`;
                
                try {
                    // If has Lab values, use them directly
                    if (typeof color.L === 'number' && typeof color.a === 'number' && typeof color.b === 'number') {
                        colors.push(color);
                        continue;
                    }
                    
                    // Try client-side RGB to Lab conversion (fast, no API needed)
                    let rgb = null;
                    if (color.rgb && typeof color.rgb === 'object') {
                        rgb = color.rgb;
                    } else if (typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number') {
                        rgb = { r: color.r, g: color.g, b: color.b };
                    } else if (typeof item.rgb_r === 'number' && typeof item.rgb_g === 'number' && typeof item.rgb_b === 'number') {
                        // FilamentColors RGB format
                        rgb = { r: item.rgb_r, g: item.rgb_g, b: item.rgb_b };
                    }
                    
                    if (rgb) {
                        // Use LittleCMS API for accurate sRGB→Lab(D50) with proper chromatic adaptation
                        try {
                            const response = await fetch(`${API_URL}/rgb-to-lab`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ r: rgb.r, g: rgb.g, b: rgb.b })
                            });
                            
                            if (response.ok) {
                                const labData = await response.json();
                                color.L = labData.lab[0];
                                color.a = labData.lab[1];
                                color.b = labData.lab[2];
                                
                                if (!color.hex) {
                                    // Generate hex from RGB
                                    color.hex = '#' + [rgb.r, rgb.g, rgb.b].map(x => {
                                        const hex = Math.round(x).toString(16);
                                        return hex.length === 1 ? '0' + hex : hex;
                                    }).join('');
                                }
                                
                                colors.push(color);
                            } else {
                                console.warn(`API conversion failed for ${colorId}, skipping`);
                                failedConversions.push(colorId);
                            }
                        } catch (e) {
                            console.warn(`API error for ${colorId}:`, e.message);
                            failedConversions.push(colorId);
                        }
                        continue;
                    }
                    
                    // If has hex, convert via API
                    if (color.hex) {
                        try {
                            const response = await fetch(`${API_URL}/hex-to-lab/${encodeURIComponent(color.hex)}`);
                            if (response.ok) {
                                const labData = await response.json();
                                color.L = labData.lab[0];
                                color.a = labData.lab[1];
                                color.b = labData.lab[2];
                                colors.push(color);
                            } else {
                                console.warn(`API hex conversion failed for ${colorId}, skipping`);
                                failedConversions.push(colorId);
                            }
                        } catch (e) {
                            console.warn(`API hex error for ${colorId}:`, e.message);
                            failedConversions.push(colorId);
                        }
                        continue;
                    }
                    
                    // If we got here, couldn't convert - skip this color
                    failedConversions.push(colorId);
                    
                } catch (e) {
                    console.warn(`Error processing color ${colorId}:`, e.message);
                    failedConversions.push(colorId);
                }
            }
            
            if (failedConversions.length > 0) {
                console.warn(`${failedConversions.length} colors could not be converted:`, failedConversions.slice(0, 5));
            }
            
            console.log(`✔ Parsed ${colors.length} colors from ${libraryName} (${failedConversions.length} failed)`);
            return colors;
        }
        
        // Parse CXF format via API
        async function parseCxfData(blob, libraryName) {
            const API_URL = document.getElementById('cmw-api-url')?.value || 'http://127.0.0.1:8000';
            
            const formData = new FormData();
            formData.append('file', blob, 'library.cxf');
            
            const response = await fetch(`${API_URL}/import-cxf`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error('CXF parsing failed');
            }
            
            const data = await response.json();
            return data.colors || [];
        }
        
        // Parse CSV format via API
        async function parseCsvData(text, libraryName) {
            const API_URL = document.getElementById('cmw-api-url')?.value || 'http://127.0.0.1:8000';
            
            const blob = new Blob([text], { type: 'text/csv' });
            const formData = new FormData();
            formData.append('file', blob, 'library.csv');
            
            const response = await fetch(`${API_URL}/import-csv`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error('CSV parsing failed');
            }
            
            const data = await response.json();
            return data.colors || [];
        }

        /* 8. Library management functions */
        function getActiveLibraries() {
            const activeLibs = [];
            // Check all public libraries
            document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]').forEach(checkbox => {
                if (checkbox.checked && checkbox.value) {
                    activeLibs.push(checkbox.value);
                }
            });
            // Check custom libraries
            document.querySelectorAll('#cmw-custom-libraries-container input[type="checkbox"]').forEach(checkbox => {
                if (checkbox.checked && checkbox.value) {
                    activeLibs.push(checkbox.value);
                }
            });
            return activeLibs;
        }

        function initializeLibraryCounts() {
            // Update counts for all libraries (both public and custom)
            Object.keys(libs).forEach(libId => {
                const countEl = document.getElementById(`count-${libId}`);
                if (countEl && libs[libId]) {
                    countEl.textContent = `(${libs[libId].length})`;
                }
            });
        }

        function nearest(L, a, b, maxPerLibrary = 1, excludeExactMatch = null) {
            const activeLibs = getActiveLibraries();
            console.log('=== Color Search nearest() ===');
            console.log('Input Lab:', `Lab(${L}, ${a}, ${b})`);
            console.log('Active libraries:', activeLibs);
            const allMatches = [];
           
            for (const libId of activeLibs) {
                const lib = libs[libId];
                if (!lib || lib.length === 0) continue;
               
                const libMatches = [];
                for (const c of lib) {
                    const deltaE = dE(L, a, b, c.L, c.a, c.b);
                    
                    // Log first few matches for debugging
                    if (libMatches.length < 3) {
                        console.log(`  ${c.name}: Lab(${c.L}, ${c.a}, ${c.b}) -> ΔE=${deltaE.toFixed(4)}`);
                    }
                   
                    // More robust exclusion logic - ALWAYS exclude self-matches
                    let shouldExclude = false;
                   
                    // ALWAYS exclude if deltaE is extremely small (perfect or near-perfect match)
                    // This prevents showing the same color as its own closest match
                    if (deltaE < 0.01) {
                        shouldExclude = true;
                        console.log('🚫 Excluding self-match (deltaE < 0.01):', c.name, 'deltaE:', deltaE);
                    }
                   
                    if (excludeExactMatch && !shouldExclude) {
                        // Exclude by name (case-insensitive)
                        if (c.name.toLowerCase() === excludeExactMatch.toLowerCase()) {
                            shouldExclude = true;
                            console.log('🚫 Excluding exact name match:', c.name);
                        }
                       
                        // Exclude if deltaE is very small (likely the same color)
                        if (deltaE < 1.0) {
                            shouldExclude = true;
                            console.log('🚫 Excluding small deltaE match:', c.name, 'deltaE:', deltaE);
                        }
                       
                        // Exclude if Lab values are very close
                        if (Math.abs(c.L - L) < 0.5 && Math.abs(c.a - a) < 0.5 && Math.abs(c.b - b) < 0.5) {
                            shouldExclude = true;
                            console.log('🚫 Excluding close Lab values match:', c.name);
                        }
                    }
                   
                    if (!shouldExclude) {
                        libMatches.push({ c, d: deltaE });
                    }
                }
               
                console.log(`Library ${libId}: ${libMatches.length} matches (before limiting to ${maxPerLibrary})`);
                libMatches.sort((x, y) => x.d - y.d);
               
                // If we have matches but need to skip duplicates, get more results
                if (excludeExactMatch && libMatches.length > 0) {
                    // Filter out any remaining duplicates by name and get extra results
                    const filteredMatches = [];
                    const usedNames = new Set();
                   
                    for (const match of libMatches) {
                        const normalizedName = match.c.name.toLowerCase().trim();
                        if (!usedNames.has(normalizedName)) {
                            usedNames.add(normalizedName);
                            filteredMatches.push(match);
                           
                            // Stop when we have enough unique results
                            if (filteredMatches.length >= maxPerLibrary) {
                                break;
                            }
                        }
                    }
                   
                    console.log(`Library ${libId}: ${filteredMatches.length} unique matches after filtering`);
                    allMatches.push(...filteredMatches);
                } else {
                    // No exclusion needed, just take the top results
                    console.log(`Library ${libId}: taking top ${maxPerLibrary} matches`);
                    allMatches.push(...libMatches.slice(0, maxPerLibrary));
                }
            }
           
            // Final deduplication across all libraries
            const finalMatches = [];
            const globalUsedNames = new Set();
            const globalUsedLabValues = new Set();
           
            const sortedMatches = allMatches.sort((x, y) => x.d - y.d);
            console.log('All matches before final deduplication:', sortedMatches.length);
           
            for (const match of sortedMatches) {
                const normalizedName = match.c.name.toLowerCase().trim();
                const labKey = `${match.c.L.toFixed(1)}_${match.c.a.toFixed(1)}_${match.c.b.toFixed(1)}`;
               
                // Check for duplicate names or very similar Lab values
                if (!globalUsedNames.has(normalizedName) && !globalUsedLabValues.has(labKey)) {
                    globalUsedNames.add(normalizedName);
                    globalUsedLabValues.add(labKey);
                    finalMatches.push(match);
                } else {
                    console.log('Global duplicate filtered:', match.c.name, 'deltaE:', match.d.toFixed(2));
                }
            }
           
            console.log('Final unique matches:', finalMatches.length);
            return finalMatches;
        }

        /* 9. UI Helper Functions */
       
        function showStatus(message, type = 'success', persistent = false) {
            const status = document.getElementById('cmw-status');
            status.textContent = message;
            status.className = `cmw-status ${type} show`;
           
            if (!persistent) {
                setTimeout(() => status.classList.remove('show'), 5000);
            }
        }

        function showLoading(show = true) {
            const loading = document.getElementById('cmw-loading');
            loading.classList.toggle('show', show);
        }

        function getResultsCount() {
            const resultsSelect = document.getElementById('cmw-results-count');
            return parseInt(resultsSelect ? resultsSelect.value : '1');
        }

        /* 10. Color Preview Functions */
       
        // Helper function - kept for compatibility but no longer shows separate swatch
        async function updateIntentSwatch(lab) {
            // Rendering intent is now applied directly through convertColor() API
            // No separate intent swatch needed
        }
       
        function updateColorPreview() {
            const preview = document.getElementById('cmw-color-preview');
            const selectedType = document.getElementById('cmw-search-type-select').value;
           
            if (preview.dataset.isHovering === 'true') {
                return;
            }
           
            if (preview.classList.contains('selected') && selectedType === 'name') {
                const nameInput = document.getElementById('cmw-name-input');
                const currentValue = nameInput.value.trim();
               
                if (currentValue && preview.dataset.selectedColor) {
                    preview.style.backgroundColor = preview.dataset.selectedColor;
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    preview.classList.add('valid', 'selected');
                   
                    if (preview.dataset.selectedName) {
                        updateSelectedColorInfo({
                            name: preview.dataset.selectedName,
                            libraryName: preview.dataset.selectedLibrary,
                            L: parseFloat(preview.dataset.selectedL),
                            a: parseFloat(preview.dataset.selectedA),
                            b: parseFloat(preview.dataset.selectedB)
                        });
                    }
                    return;
                }
               
                if (!currentValue || currentValue.length < 3) {
                    preview.classList.remove('selected');
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    delete preview.dataset.originalHexInput;
                    delete preview.dataset.hex;
                    delete preview.dataset.rgbR;
                    delete preview.dataset.rgbG;
                    delete preview.dataset.rgbB;
                    delete preview.dataset.cmykC;
                    delete preview.dataset.cmykM;
                    delete preview.dataset.cmykY;
                    delete preview.dataset.cmykK;
                    delete preview.dataset.amazonLink;
                    delete preview.dataset.manufacturerLink;
                    updateSelectedColorInfo(null);
                }
            }
           
            let color = null;
            let isValid = false;
           
            // Clear converted color info when switching to name mode or clearing inputs
            if (selectedType === 'name') {
                updateConvertedColorInfo(null);
                const query = document.getElementById('cmw-name-input').value.trim();
                if (isValidHex(query)) {
                    const normalizedHex = query.startsWith('#') ? query : '#' + query;
                    color = normalizedHex;
                    isValid = true;
                    
                    // Set immediate preview with the hex color (before API call)
                    preview.style.backgroundColor = normalizedHex;
                    preview.style.borderColor = '#e2e8f0';
                    preview.classList.add('valid');
                    
                    // Store the original hex input for the color modal
                    preview.dataset.originalHexInput = normalizedHex.toUpperCase();
                   
                    // Show converted Lab values for hex input
                    if (query.length >= 6) {
                        const rgb = hex2rgb(normalizedHex);
                        console.log(`[Color Search] Converting hex ${normalizedHex} -> RGB(${rgb.r}, ${rgb.g}, ${rgb.b})`);
                        convertColor({
                            rgb: [rgb.r, rgb.g, rgb.b],
                            profile: 'sRGB.icc'
                        }).then(data => {
                            console.log(`[Color Search] Hex ${normalizedHex} -> Lab(${data.lab[0]}, ${data.lab[1]}, ${data.lab[2]})`);
                            
                            // Set preview color with LittleCMS accurate hex
                            let accurateHex = data.hex;
                            if (!accurateHex.startsWith('#')) {
                                accurateHex = '#' + accurateHex;
                            }
                            preview.style.backgroundColor = accurateHex;
                            preview.style.borderColor = '#e2e8f0';
                            preview.classList.add('valid');
                            
                            const gamutToggle = document.getElementById('cmw-gamut-toggle');
                            const showGamut = gamutToggle && gamutToggle.checked;
                           
                            const labValues = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                            currentColorData = labValues; // Set for intent updates
                           
                            // Clear original input data for hex input
                            currentOriginalInputData = null;
                           
                            if (showGamut && data.gamut) {
                                updateConvertedColorInfo(
                                    labValues,
                                    'api',
                                    'sRGB → GRACoL gamut',
                                    data.gamut.inGamut
                                );
                            } else {
                                updateConvertedColorInfo(
                                    labValues,
                                    'api',
                                    'sRGB.icc'
                                );
                            }
                           
                            // Update intent swatch for hex input
                            updateIntentSwatch(labValues);
                           
                            // Update rendering comparison if enabled
                            const intentsToggle = document.getElementById('cmw-intents-toggle');
                            if (intentsToggle && intentsToggle.checked) {
                                console.log('Updating rendering intents for hex input:', labValues);
                                updateRenderingIntents(labValues, null); // No original data for hex input
                            }
                        }).catch(error => {
                            console.error('LittleCMS API conversion failed:', error);
                            // Show error state - no fallback to local JS conversion
                            preview.style.backgroundColor = '#f0f0f0';
                            preview.classList.remove('valid');
                            currentColorData = null;
                            currentOriginalInputData = null;
                            updateConvertedColorInfo(null);
                            
                            // Show error message to user
                            const infoEl = document.getElementById('cmw-converted-color-info');
                            if (infoEl) {
                                infoEl.innerHTML = '<span style="color: #dc2626;">LittleCMS API unavailable</span>';
                            }
                        });
                    }
                } else {
                    // Clear for invalid hex or when clearing
                    currentColorData = null;
                }
            } else if (selectedType === 'lab') {
                const L = parseFloat(document.getElementById('cmw-lab-l').value);
                const a = parseFloat(document.getElementById('cmw-lab-a').value);
                const b = parseFloat(document.getElementById('cmw-lab-b').value);
               
                if (!isNaN(L) && !isNaN(a) && !isNaN(b) &&
                    L >= 0 && L <= 100 && a >= -128 && a <= 127 && b >= -128 && b <= 127) {
                    color = lab2rgb(L, a, b); // Quick preview with local conversion
                    isValid = true;
                    const labValues = { L: L, a: a, b: b };
                    currentColorData = labValues; // Set for intent updates
                   
                    // Clear original input data for Lab input
                    currentOriginalInputData = null;
                   
                    // Use LittleCMS for accurate preview color (Lab → RGB uses sRGB)
                    convertColor({
                        lab: [L, a, b],
                        profile: 'sRGB.icc'
                    }).then(data => {
                        if (data.hex) {
                            let hexColor = data.hex;
                            if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                            preview.style.backgroundColor = hexColor;
                        }
                    }).catch(() => {
                        // Keep local conversion on error
                    });
                   
                    const gamutToggle = document.getElementById('cmw-gamut-toggle');
                    const showGamutColors = gamutToggle && gamutToggle.checked;
                   
                    // Always update converted color info for Lab input
                    if (showGamutColors) {
                        checkGamut(labValues, 'GRACoL2013.icc')
                            .then(gamutData => {
                                updateConvertedColorInfo(
                                    labValues,
                                    'direct',
                                    'Lab → GRACoL2013.icc',
                                    gamutData ? gamutData.inGamut : null
                                );
                                updateGamutWarning(gamutData, 'GRACoL2013.icc');
                            })
                            .catch(() => {
                                updateConvertedColorInfo(labValues, 'direct', 'Lab values');
                            });
                    } else {
                        updateConvertedColorInfo(labValues, 'direct', 'Lab values');
                    }
                   
                    // Update intent swatch for Lab input
                    updateIntentSwatch(labValues);
                   
                    // Update rendering comparison if enabled
                    const intentsToggle = document.getElementById('cmw-intents-toggle');
                    if (intentsToggle && intentsToggle.checked) {
                        console.log('Updating rendering intents for Lab input:', labValues);
                        updateRenderingIntents(labValues, null); // No original data for Lab input
                    }
                } else {
                    currentColorData = null;
                    // Only clear if invalid values
                    updateConvertedColorInfo(null);
                }
            } else if (selectedType === 'cmyk') {
                const c = parseFloat(document.getElementById('cmw-cmyk-c').value);
                const m = parseFloat(document.getElementById('cmw-cmyk-m').value);
                const y = parseFloat(document.getElementById('cmw-cmyk-y').value);
                const k = parseFloat(document.getElementById('cmw-cmyk-k').value);
               
                if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k) &&
                    c >= 0 && c <= 100 && m >= 0 && m <= 100 && y >= 0 && y <= 100 && k >= 0 && k <= 100) {
                   
                    isValid = true;
                   
                    // Use API conversion for accurate preview
                    const profile = document.getElementById('cmw-profile-select').value;
                    convertColor({
                        cmyk: [c, m, y, k],
                        profile: profile
                    }).then(data => {
                        // Use LittleCMS hex for accurate color display - no fallback
                        if (!data.hex) {
                            throw new Error('LittleCMS did not return hex value');
                        }
                        let accurateColor = data.hex;
                        if (!accurateColor.startsWith('#')) {
                            accurateColor = '#' + accurateColor;
                        }
                        preview.style.backgroundColor = accurateColor;
                        preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                        preview.classList.add('valid');
                       
                        const labValues = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                        currentColorData = labValues; // Set for intent updates
                       
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        const showGamutColors = gamutToggle && gamutToggle.checked;
                        const currentIntent = document.getElementById('cmw-default-intent').value;
                       
                        // Update converted color info
                        if (showGamutColors) {
                            const gamutData = data.gamut || null;
                            updateConvertedColorInfo(
                                labValues,
                                'api',
                                profile,
                                gamutData ? gamutData.inGamut : null
                            );
                            updateGamutWarning(data.gamut, profile);
                           
                            // If rendering intent is "none" but we don't have gamut data, make explicit call
                            if (currentIntent === 'none' && !gamutData) {
                                checkGamut(labValues, profile)
                                    .then(explicitGamutData => {
                                        updateConvertedColorInfo(
                                            labValues,
                                            'api',
                                            profile,
                                            explicitGamutData ? explicitGamutData.inGamut : null
                                        );
                                        updateGamutWarning(explicitGamutData, profile);
                                    })
                                    .catch(() => {
                                        updateConvertedColorInfo(labValues, 'api', profile);
                                    });
                            }
                        } else {
                            updateConvertedColorInfo(labValues, 'api', profile);
                        }
                       
                        // Store original CMYK data for rendering intent comparison (Lab-based but with context)
                        currentOriginalInputData = {
                            type: 'cmyk',
                            values: [c, m, y, k],
                            profile: profile
                        };
                       
                        // Update intent swatch for CMYK input
                        updateIntentSwatch(labValues);
                       
                        // Update rendering comparison if enabled - ensure CMYK works like other input types
                        const intentsToggle = document.getElementById('cmw-intents-toggle');
                        if (intentsToggle && intentsToggle.checked) {
                            console.log('Updating rendering intents for CMYK input:', labValues);
                            // For CMYK, clear the original data to ensure consistent Lab-based processing
                            updateRenderingIntents(labValues, null);
                        }
                    }).catch(error => {
                        console.error('LittleCMS API CMYK conversion failed:', error);
                        // Show error state - no fallback to local JS conversion
                        preview.style.backgroundColor = '#f0f0f0';
                        preview.classList.remove('valid');
                        currentColorData = null;
                        currentOriginalInputData = null;
                        updateConvertedColorInfo(null);
                        
                        // Show error message to user
                        const infoEl = document.getElementById('cmw-converted-color-info');
                        if (infoEl) {
                            infoEl.innerHTML = '<span style="color: #dc2626;">LittleCMS API unavailable</span>';
                        }
                    });
                   
                    return; // Don't set color here since we're handling it asynchronously
                } else {
                    currentColorData = null;
                }
            } else if (selectedType === 'rgb') {
                const r = parseFloat(document.getElementById('cmw-rgb-r').value);
                const g = parseFloat(document.getElementById('cmw-rgb-g').value);
                const b = parseFloat(document.getElementById('cmw-rgb-b').value);
               
                if (!isNaN(r) && !isNaN(g) && !isNaN(b) &&
                    r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                    color = `rgb(${r}, ${g}, ${b})`; // Quick preview
                    isValid = true;
                   
                    // Show converted Lab values for RGB input
                    convertColor({
                        rgb: [r, g, b],
                        profile: 'sRGB.icc'
                    }).then(data => {
                        // Use LittleCMS hex for accurate preview color
                        if (data.hex) {
                            let hexColor = data.hex;
                            if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                            preview.style.backgroundColor = hexColor;
                        }
                        
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        const showGamut = gamutToggle && gamutToggle.checked;
                       
                        const labValues = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                        currentColorData = labValues; // Set for intent updates
                       
                        // Clear original input data for RGB input
                        currentOriginalInputData = null;
                       
                        if (showGamut && data.gamut) {
                            updateConvertedColorInfo(
                                labValues,
                                'api',
                                'sRGB → GRACoL gamut',
                                data.gamut.inGamut
                            );
                        } else {
                            updateConvertedColorInfo(
                                labValues,
                                'api',
                                'sRGB.icc'
                            );
                        }
                       
                        // Update intent swatch for RGB input
                        updateIntentSwatch(labValues);
                       
                        // Update rendering comparison if enabled
                        const intentsToggle = document.getElementById('cmw-intents-toggle');
                        if (intentsToggle && intentsToggle.checked) {
                            console.log('Updating rendering intents for RGB input:', labValues);
                            updateRenderingIntents(labValues, null); // No original data for RGB input
                        }
                    }).catch(error => {
                        console.error('LittleCMS API RGB conversion failed:', error);
                        // Show error state - no fallback to local JS conversion
                        preview.style.backgroundColor = '#f0f0f0';
                        preview.classList.remove('valid');
                        currentColorData = null;
                        currentOriginalInputData = null;
                        updateConvertedColorInfo(null);
                        
                        // Show error message to user
                        const infoEl = document.getElementById('cmw-converted-color-info');
                        if (infoEl) {
                            infoEl.innerHTML = '<span style="color: #dc2626;">LittleCMS API unavailable</span>';
                        }
                    });
                } else {
                    currentColorData = null;
                }
            }
           
            if (isValid && color) {
                preview.style.backgroundColor = color;
                preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                preview.classList.add('valid');
                if (selectedType !== 'name') {
                    preview.classList.remove('selected');
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    delete preview.dataset.originalHexInput;
                    delete preview.dataset.hex;
                    delete preview.dataset.rgbR;
                    delete preview.dataset.rgbG;
                    delete preview.dataset.rgbB;
                    delete preview.dataset.cmykC;
                    delete preview.dataset.cmykM;
                    delete preview.dataset.cmykY;
                    delete preview.dataset.cmykK;
                    delete preview.dataset.amazonLink;
                    delete preview.dataset.manufacturerLink;
                    updateSelectedColorInfo(null);
                }
            } else {
                preview.style.backgroundColor = '#f8fafc';
                preview.style.borderColor = '#e2e8f0';
                preview.classList.remove('valid');
               
                if (!isValid) {
                    preview.classList.remove('selected');
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    delete preview.dataset.originalHexInput;
                    delete preview.dataset.hex;
                    delete preview.dataset.rgbR;
                    delete preview.dataset.rgbG;
                    delete preview.dataset.rgbB;
                    delete preview.dataset.cmykC;
                    delete preview.dataset.cmykM;
                    delete preview.dataset.cmykY;
                    delete preview.dataset.cmykK;
                    delete preview.dataset.amazonLink;
                    delete preview.dataset.manufacturerLink;
                    if (selectedType !== 'name' || !preview.classList.contains('selected')) {
                        updateSelectedColorInfo(null);
                    }
                    if (selectedType !== 'lab') {
                        updateConvertedColorInfo(null);
                    }
                    updateGamutWarning(null);
                   
                    // Reset when no valid color
                    currentColorData = null;
                }
            }
        }

        // DEPRECATED: DO NOT USE for CMYK conversions - use convertColor() API instead
        // This function is kept only for reference but should never be called
        // All CMYK conversions MUST go through LittleCMS API with GRACoL2013.icc for accuracy
        function cmyk2rgb(c, m, y, k) {
            console.error('WARNING: cmyk2rgb() called - this should use LittleCMS API instead!');
            // Convert percentages to decimals
            c = c / 100;
            m = m / 100;
            y = y / 100;
            k = k / 100;
           
            // Standard CMYK to RGB conversion formula
            const r = Math.round(255 * (1 - c) * (1 - k));
            const g = Math.round(255 * (1 - m) * (1 - k));
            const b = Math.round(255 * (1 - y) * (1 - k));
           
            return {
                r: Math.max(0, Math.min(255, r)),
                g: Math.max(0, Math.min(255, g)),
                b: Math.max(0, Math.min(255, b))
            };
        }

        async function updateSelectedColorInfo(colorData = null) {
            const colorInfoEl = document.getElementById('cmw-selected-color-info');
            const colorLibraryEl = document.getElementById('cmw-selected-color-library');
            const colorLabEl = document.getElementById('cmw-selected-color-lab');
            const mainSwatch = document.getElementById('cmw-color-preview');
           
            if (colorData) {
                colorLibraryEl.textContent = colorData.libraryName || 'Unknown';
               
                // Get current rendering intent
                const currentIntent = document.getElementById('cmw-default-intent').value;
                const intentNames = {
                    'none': 'None',
                    '0': 'Perceptual',
                    '1': 'Relative Colorimetric',
                    '2': 'Saturation',
                    '3': 'Absolute Colorimetric'
                };
               
                // Show original library values
                // Make Lab non-bold if it was calculated from spectral (not device-measured)
                const labIsMeasured = !colorData.lab_calculated;
                const originalLab = labIsMeasured ? 
                    `<strong>Lab(${colorData.L.toFixed(2)}, ${colorData.a.toFixed(2)}, ${colorData.b.toFixed(2)})</strong>` :
                    `Lab(${colorData.L.toFixed(2)}, ${colorData.a.toFixed(2)}, ${colorData.b.toFixed(2)})`;
               
                // Set swatch color using LittleCMS with rendering intent applied
                const mainColor = lab2rgb(colorData.L, colorData.a, colorData.b);
                mainSwatch.style.backgroundColor = mainColor;
                mainSwatch.style.borderColor = '#e2e8f0';
                mainSwatch.classList.add('valid', 'selected');
               
                // Use LittleCMS to get the accurate color with rendering intent (Lab → RGB uses sRGB)
                convertColor({
                    lab: [colorData.L, colorData.a, colorData.b],
                    profile: 'sRGB.icc'
                }).then(data => {
                    if (data.hex) {
                        let hexColor = data.hex;
                        if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                        mainSwatch.style.backgroundColor = hexColor;
                    }
                }).catch(() => {
                    // Keep local conversion on error
                });
               
                // Show Lab values with rendering intent info
                const gamutToggle = document.getElementById('cmw-gamut-toggle');
                const showGamutColors = gamutToggle && gamutToggle.checked;
               
                if (showGamutColors) {
                    checkGamut(
                        { L: colorData.L, a: colorData.a, b: colorData.b },
                        'GRACoL2013.icc'
                    ).then(gamutData => {
                        let colorStyle = '';
                        if (gamutData) {
                            colorStyle = gamutData.inGamut ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                        }
                        colorLabEl.innerHTML = `<span ${colorStyle}>${originalLab}</span><br><small style="color: #6b7280;">(${intentNames[currentIntent]})</small>`;
                    }).catch(() => {
                        colorLabEl.innerHTML = `${originalLab}<br><small style="color: #6b7280;">(${intentNames[currentIntent]})</small>`;
                    });
                } else {
                    colorLabEl.innerHTML = `${originalLab}<br><small style="color: #6b7280;">(${intentNames[currentIntent]})</small>`;
                }
               
                colorInfoEl.classList.add('show');
               
                // Update rendering comparison if enabled
                const intentsToggle = document.getElementById('cmw-intents-toggle');
                if (intentsToggle && intentsToggle.checked && colorData.L && colorData.a !== undefined && colorData.b !== undefined) {
                    currentOriginalInputData = {
                        type: 'library',
                        colorName: colorData.name,
                        libraryName: colorData.libraryName
                    };
                    updateRenderingIntents({ L: colorData.L, a: colorData.a, b: colorData.b }, currentOriginalInputData);
                }
            } else {
                colorInfoEl.classList.remove('show');
                colorLibraryEl.textContent = '';
                colorLabEl.innerHTML = '';
            }
        }

        /* ─────────────────────
           Section 4 Java Part 2
           ───────────────────── */

        function updateConvertedColorInfo(labData = null, conversionMethod = '', profile = '', gamutStatus = null, renderingIntentData = null) {
            const convertedInfoEl = document.getElementById('cmw-converted-color-info');
            const convertedLabEl = document.getElementById('cmw-converted-color-lab');
            const convertedCmykEl = document.getElementById('cmw-converted-cmyk');
            const convertedTitleEl = convertedInfoEl.querySelector('div:first-child');
            
            // Helper to create gamut indicator text
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            const showGamutIndicator = gamutToggle && gamutToggle.checked;
            
            function getGamutIndicator(inGamut) {
                if (!showGamutIndicator || inGamut === null || inGamut === undefined) {
                    return '';
                }
                if (inGamut) {
                    return '<div style="margin-top: 4px; color: #10b981; font-weight: 600; font-size: 12px;">✓ In Gamut (GRACoL2013)</div>';
                } else {
                    return '<div style="margin-top: 4px; color: #ef4444; font-weight: 600; font-size: 12px;">⚠ Out of Gamut (GRACoL2013)</div>';
                }
            }
           
            if (labData) {
                let methodText = '';
                if (conversionMethod === 'api') {
                    methodText = profile ? ` (${profile})` : ' ';
                } else if (conversionMethod === 'direct') {
                    methodText = profile ? `<br><small style="color: #6b7280;">(${profile})</small>` : '';
                } else if (conversionMethod === 'library') {
                    // For library colors, show "Known Lab Values" as title
                    if (convertedTitleEl) {
                        convertedTitleEl.textContent = 'Known Lab Values';
                    }
                    methodText = profile ? `<br><small style="color: #6b7280;">(${profile})</small>` : '';
                }
                
                // Reset title for non-library methods
                if (conversionMethod !== 'library' && convertedTitleEl) {
                    convertedTitleEl.textContent = 'Converted Lab Values';
                }
               
                // Get current rendering intent and show both original and converted values if different
                const currentIntent = document.getElementById('cmw-default-intent').value;
                const intentsToggle = document.getElementById('cmw-intents-toggle');
                const showRenderingComparison = intentsToggle && intentsToggle.checked;
                const intentNames = {
                    '0': 'P.',
                    '1': 'R.C.',
                    '2': 'S.',
                    '3': 'A.C.'
                };
               
                // Only show rendering intent comparison if BOTH the toggle is ON and intent is not 'none'
                if (showRenderingComparison && currentIntent !== 'none') {
                    // Try to get rendering intent converted values
                    compareRenderingIntents(labData).then(data => {
                        const intentMap = {
                            '0': 'perceptual',
                            '1': 'relative',
                            '2': 'saturation',
                            '3': 'absolute'
                        };
                       
                        const selectedIntentName = intentMap[currentIntent];
                        if (data.renderingIntents[selectedIntentName] && data.renderingIntents[selectedIntentName].lab) {
                            const convertedLab = data.renderingIntents[selectedIntentName].lab;
                            const intentGamut = data.renderingIntents[selectedIntentName].gamut;
                           
                            // Apply color to Lab values based on gamut status ONLY if gamut indicator is enabled
                            let originalColorStyle = '';
                            if (showGamutIndicator && gamutStatus !== null) {
                                originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                            }
                           
                            let intentColorStyle = '';
                            if (showGamutIndicator && intentGamut) {
                                intentColorStyle = intentGamut.inGamut ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                            }
                           
                            const convertedLabText = `<span ${intentColorStyle}><strong>Lab(${convertedLab[0].toFixed(2)}, ${convertedLab[1].toFixed(2)}, ${convertedLab[2].toFixed(2)})</strong></span>`;
                            const originalLabText = `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>`;
                           
                            // Check if values actually changed
                            const valuesChanged = (
                                Math.abs(labData.L - convertedLab[0]) > 0.05 ||
                                Math.abs(labData.a - convertedLab[1]) > 0.05 ||
                                Math.abs(labData.b - convertedLab[2]) > 0.05
                            );
                           
                            // Get CMYK conversion and then update display
                            const selectedType = document.getElementById('cmw-search-type-select').value;
                            if (selectedType === 'lab') {
                                convertColor({
                                    lab: [labData.L, labData.a, labData.b],
                                    profile: 'GRACoL2013.icc'
                                }).then(cmykData => {
                                    let cmykText = '';
                                    let mainGamutStatus = null;
                                    if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                        const cmyk = cmykData.gamut.cmykEquivalent;
                                        cmykText = `<br><strong>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})</strong>`;
                                        mainGamutStatus = cmykData.gamut.inGamut;
                                    }
                                   
                                    if (valuesChanged) {
                                        // Show both Lab values + CMYK + gamut indicator
                                        convertedLabEl.innerHTML = `
                                            <div style="margin-bottom: 4px;">
                                                <strong>Main:</strong> ${originalLabText}
                                            </div>
                                            <div>
                                                <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                            </div>
                                            ${cmykText}
                                            <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                            ${getGamutIndicator(mainGamutStatus)}
                                        `;
                                    } else {
                                        // Values are the same, show single Lab value + CMYK + gamut indicator
                                        convertedLabEl.innerHTML = `${convertedLabText}${cmykText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>${getGamutIndicator(mainGamutStatus)}`;
                                    }
                                }).catch(() => {
                                    // CMYK conversion failed, show without CMYK
                                    if (valuesChanged) {
                                        convertedLabEl.innerHTML = `
                                            <div style="margin-bottom: 4px;">
                                                <strong>Main:</strong> ${originalLabText}
                                            </div>
                                            <div>
                                                <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                            </div>
                                            <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                            ${getGamutIndicator(gamutStatus)}
                                        `;
                                    } else {
                                        convertedLabEl.innerHTML = `${convertedLabText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>${getGamutIndicator(gamutStatus)}`;
                                    }
                                });
                        } else {
                            // Not Lab input, show without CMYK but check gamut
                            checkGamut(labData, 'GRACoL2013.icc').then(gamutData => {
                                const inGamut = gamutData && gamutData.inGamut;
                                if (valuesChanged) {
                                    convertedLabEl.innerHTML = `
                                        <div style="margin-bottom: 4px;">
                                            <strong>Main:</strong> ${originalLabText}
                                        </div>
                                        <div>
                                            <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                        </div>
                                        <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                        ${getGamutIndicator(inGamut)}
                                    `;
                                } else {
                                    convertedLabEl.innerHTML = `${convertedLabText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>${getGamutIndicator(inGamut)}`;
                                }
                            }).catch(() => {
                                if (valuesChanged) {
                                    convertedLabEl.innerHTML = `
                                        <div style="margin-bottom: 4px;">
                                            <strong>Main:</strong> ${originalLabText}
                                        </div>
                                        <div>
                                            <strong>${intentNames[currentIntent]}:</strong> ${convertedLabText}
                                        </div>
                                        <small style="color: #6b7280;">(GRACoL2013.icc)</small>
                                    `;
                                } else {
                                    convertedLabEl.innerHTML = `${convertedLabText}<br><small style="color: #6b7280;">(GRACoL2013.icc - ${intentNames[currentIntent]})</small>`;
                                }
                            });
                        }
                    } else {
                        // Fallback: show original values only
                        let originalColorStyle = '';
                        if (showGamutIndicator && gamutStatus !== null) {
                            originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                        }
                       
                        const selectedType = document.getElementById('cmw-search-type-select').value;
                        if (selectedType === 'lab') {
                            // Get CMYK for fallback case too
                            convertColor({
                                lab: [labData.L, labData.a, labData.b],
                                profile: 'GRACoL2013.icc'
                            }).then(cmykData => {
                                let cmykText = '';
                                let fallbackGamutStatus = null;
                                if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                    const cmyk = cmykData.gamut.cmykEquivalent;
                                    cmykText = `<br><strong>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})</strong>`;
                                    fallbackGamutStatus = cmykData.gamut.inGamut;
                                }
                                // Make Lab bold if it was converted (not from library)
                                const labIsBold = conversionMethod !== 'library';
                                const labText = labIsBold ? 
                                    `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                    `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                                convertedLabEl.innerHTML = `${labText}${cmykText}${methodText}${getGamutIndicator(fallbackGamutStatus)}`;
                            }).catch(() => {
                                const labIsBold = conversionMethod !== 'library';
                                const labText = labIsBold ? 
                                    `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                    `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                                convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(gamutStatus)}`;
                            });
                        } else {
                            const labIsBold = conversionMethod !== 'library';
                            const labText = labIsBold ? 
                                `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                            convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(gamutStatus)}`;
                        }
                    }
                       
                    }).catch(() => {
                        // Fallback: show original values only
                        let originalColorStyle = '';
                        if (showGamutIndicator && gamutStatus !== null) {
                            originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                        }
                       
                        const selectedType = document.getElementById('cmw-search-type-select').value;
                        if (selectedType === 'lab') {
                            // Get CMYK for error fallback case too
                            convertColor({
                                lab: [labData.L, labData.a, labData.b],
                                profile: 'GRACoL2013.icc'
                            }).then(cmykData => {
                                let cmykText = '';
                                let errorGamutStatus = null;
                                if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                    const cmyk = cmykData.gamut.cmykEquivalent;
                                    cmykText = `<br><strong>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})</strong>`;
                                    errorGamutStatus = cmykData.gamut.inGamut;
                                }
                                const labIsBold = conversionMethod !== 'library';
                                const labText = labIsBold ? 
                                    `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                    `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                                convertedLabEl.innerHTML = `${labText}${cmykText}${methodText}${getGamutIndicator(errorGamutStatus)}`;
                            }).catch(() => {
                                const labIsBold = conversionMethod !== 'library';
                                const labText = labIsBold ? 
                                    `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                    `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                                convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(gamutStatus)}`;
                            });
                        } else {
                            // For non-lab inputs, check gamut
                            checkGamut(labData, 'GRACoL2013.icc').then(gamutData => {
                                const inGamut = gamutData && gamutData.inGamut;
                                const labIsBold = conversionMethod !== 'library';
                                const labText = labIsBold ? 
                                    `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                    `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                                convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(inGamut)}`;
                            }).catch(() => {
                                const labIsBold = conversionMethod !== 'library';
                                const labText = labIsBold ? 
                                    `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                    `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                                convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(gamutStatus)}`;
                            });
                        }
                    });
                } else {
                    // No rendering intent, show original values only
                    let originalColorStyle = '';
                    if (showGamutIndicator && gamutStatus !== null) {
                        originalColorStyle = gamutStatus ? 'style="color: #10b981; font-weight: 600;"' : 'style="color: #ef4444; font-weight: 600;"';
                    }
                   
                    const selectedType = document.getElementById('cmw-search-type-select').value;
                    if (selectedType === 'lab') {
                        // Get CMYK for "none" rendering intent case
                        convertColor({
                            lab: [labData.L, labData.a, labData.b],
                            profile: 'GRACoL2013.icc'
                        }).then(cmykData => {
                            let cmykText = '';
                            let noneGamutStatus = null;
                            if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                const cmyk = cmykData.gamut.cmykEquivalent;
                                cmykText = `<br><strong>CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})</strong>`;
                                noneGamutStatus = cmykData.gamut.inGamut;
                            }
                            const labIsBold = conversionMethod !== 'library';
                            const labText = labIsBold ? 
                                `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                            convertedLabEl.innerHTML = `${labText}${cmykText}${methodText}${getGamutIndicator(noneGamutStatus)}`;
                        }).catch(() => {
                            const labIsBold = conversionMethod !== 'library';
                            const labText = labIsBold ? 
                                `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                            convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(gamutStatus)}`;
                        });
                    } else {
                        // For non-lab inputs with no rendering intent, check gamut
                        checkGamut(labData, 'GRACoL2013.icc').then(gamutData => {
                            const inGamut = gamutData && gamutData.inGamut;
                            const labIsBold = conversionMethod !== 'library';
                            const labText = labIsBold ? 
                                `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                            convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(inGamut)}`;
                        }).catch(() => {
                            const labIsBold = conversionMethod !== 'library';
                            const labText = labIsBold ? 
                                `<span ${originalColorStyle}><strong>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</strong></span>` :
                                `<span ${originalColorStyle}>Lab(${labData.L.toFixed(2)}, ${labData.a.toFixed(2)}, ${labData.b.toFixed(2)})</span>`;
                            convertedLabEl.innerHTML = `${labText}${methodText}${getGamutIndicator(gamutStatus)}`;
                        });
                    }
                }
               
                convertedInfoEl.classList.add('show');
            } else {
                convertedInfoEl.classList.remove('show');
                convertedLabEl.innerHTML = '';
                // Keep CMYK element hidden since we integrate CMYK into Lab display now
                convertedCmykEl.innerHTML = '';
                convertedCmykEl.style.display = 'none';
            }
        }

        function updateGamutWarning(gamutData, profile) {
            // Gamut warnings are disabled - only show visual indicators
            const warningEl = document.getElementById('cmw-gamut-warning');
            warningEl.classList.remove('show');
        }

        /* 11. Color Harmony Functions */
       
        async function updateColorHarmonies(lab) {
            const harmonySection = document.getElementById('cmw-harmonies-section');
            const harmonyToggle = document.getElementById('cmw-harmony-toggle');
           
            if (!harmonyToggle.checked || !lab) {
                harmonySection.style.display = 'none';
                return;
            }
           
            harmonySection.style.display = 'block';
            const loadingEl = document.getElementById('cmw-harmony-loading');
            const colorsEl = document.getElementById('cmw-harmony-colors');
            const statusEl = document.getElementById('cmw-harmony-status');
           
            try {
                loadingEl.classList.add('show');
                colorsEl.innerHTML = '';
                statusEl.classList.remove('show');
               
                const harmonyType = document.getElementById('cmw-harmony-type').value;
               
                // Always use local calculation for now to ensure proper original color handling
                console.log('Calculating harmonies for Lab:', lab, 'Type:', harmonyType);
                const data = calculateLocalHarmoniesWithLibraryMatching(lab, harmonyType);
                displayHarmonyColors(data.colors);
               
                // Show success status
                const totalMatches = data.colors.reduce((sum, color) => {
                    if (color.libraryMatches) {
                        return sum + Object.values(color.libraryMatches).reduce((libSum, matches) => libSum + matches.length, 0);
                    }
                    return sum;
                }, 0);
               
                if (totalMatches > 0) {
                    statusEl.textContent = `Generated ${data.colors.length} ${harmonyType} harmony colors with library matches`;
                    statusEl.className = 'cmw-status success show';
                } else {
                    statusEl.textContent = `Generated ${data.colors.length} ${harmonyType} harmony colors`;
                    statusEl.className = 'cmw-status warning show';
                }
               
            } catch (error) {
                console.error('Harmony calculation failed:', error);
                statusEl.textContent = 'Failed to calculate color harmonies';
                statusEl.className = 'cmw-status error show';
            } finally {
                loadingEl.classList.remove('show');
            }
        }

        function displayHarmonyColors(colors) {
            const colorsEl = document.getElementById('cmw-harmony-colors');
            colorsEl.innerHTML = '';
           
            colors.forEach((colorData, index) => {
                const colorEl = document.createElement('div');
                colorEl.className = 'cmw-harmony-color';
               
                const swatchEl = document.createElement('div');
                const labValues = Array.isArray(colorData.lab) ? colorData.lab : [colorData.lab.L, colorData.lab.a, colorData.lab.b];
                swatchEl.className = `cmw-harmony-swatch ${colorData.gamut?.inGamut ? 'in-gamut' : ''}`;
                swatchEl.style.backgroundColor = lab2rgb(labValues[0], labValues[1], labValues[2]);
                swatchEl.style.cursor = 'pointer';
                // Store Lab values for click handler
                swatchEl.dataset.labL = labValues[0];
                swatchEl.dataset.labA = labValues[1];
                swatchEl.dataset.labB = labValues[2];
               
                const infoEl = document.createElement('div');
                infoEl.className = 'cmw-harmony-info';
               
                // Get best library match from your actual libraries
                let bestMatch = null;
                let bestDelta = Infinity;
               
                if (colorData.libraryMatches) {
                    // Check all library groups for the best match
                    Object.values(colorData.libraryMatches).forEach(matches => {
                        if (Array.isArray(matches) && matches.length > 0) {
                            const topMatch = matches[0];
                            if (topMatch.deltaE < bestDelta) {
                                bestMatch = topMatch;
                                bestDelta = topMatch.deltaE;
                            }
                        }
                    });
                }
               
                // Fallback: if no API matches, search locally
                if (!bestMatch) {
                    const localMatches = findClosestInAllLibraries(
                        { L: labValues[0], a: labValues[1], b: labValues[2] },
                        1
                    );
                    if (localMatches.length > 0) {
                        bestMatch = localMatches[0];
                        bestDelta = localMatches[0].deltaE;
                    }
                }
               
                // Determine the type label
                let typeLabel;
                if (colorData.isOriginal || index === 0) {
                    typeLabel = 'Main';
                } else {
                    typeLabel = `Harmony ${index}`;
                }
               
                // Extract color name and library properly
                let colorName = 'No close match';
                let libraryName = '';
               
                if (bestMatch) {
                    // Handle both API format and local format
                    if (bestMatch.name) {
                        colorName = bestMatch.name;
                    } else if (bestMatch.colorData && bestMatch.colorData.name) {
                        colorName = bestMatch.colorData.name;
                    }
                   
                    if (bestMatch.library) {
                        libraryName = bestMatch.library;
                    } else if (bestMatch.colorData && bestMatch.colorData.libraryName) {
                        libraryName = bestMatch.colorData.libraryName;
                    }
                }
                
                // Store color name, library, and purchase links for click handler
                swatchEl.dataset.colorName = colorName !== 'No close match' ? colorName : typeLabel;
                swatchEl.dataset.libraryName = libraryName;
                
                // Store amazon and manufacturer links if available from the matched color
                if (bestMatch) {
                    const amazonLink = bestMatch.amazon_link || bestMatch.amazonLink || 
                                     (bestMatch.colorData && (bestMatch.colorData.amazon_link || bestMatch.colorData.amazonLink));
                    const manufacturerLink = bestMatch.manufacturer_link || bestMatch.manufacturerLink || 
                                           (bestMatch.colorData && (bestMatch.colorData.manufacturer_link || bestMatch.colorData.manufacturerLink));
                    
                    if (amazonLink) swatchEl.dataset.amazonLink = amazonLink;
                    if (manufacturerLink) swatchEl.dataset.manufacturerLink = manufacturerLink;
                }
               
                // Get CMYK (GRACoL2013.icc) and Hex (sRGB.icc) conversion from LittleCMS for harmony color
                Promise.all([
                    convertColor({
                        lab: [labValues[0], labValues[1], labValues[2]],
                        profile: 'GRACoL2013.icc'
                    }),
                    convertColor({
                        lab: [labValues[0], labValues[1], labValues[2]],
                        profile: 'sRGB.icc'
                    })
                ]).then(([cmykData, srgbData]) => {
                    let cmykText = 'CMYK: --';
                    if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                        const cmyk = cmykData.gamut.cmykEquivalent;
                        cmykText = `CMYK(${cmyk[0].toFixed(2)}, ${cmyk[1].toFixed(2)}, ${cmyk[2].toFixed(2)}, ${cmyk[3].toFixed(2)})`;
                    }
                   
                    // Get hex from sRGB.icc conversion for accurate RGB/Hex display
                    if (!srgbData.hex) {
                        throw new Error('LittleCMS did not return hex value');
                    }
                    let hexValue = srgbData.hex;
                    if (!hexValue.startsWith('#')) {
                        hexValue = '#' + hexValue;
                    }
                    hexValue = hexValue.toUpperCase();
                    
                    // Store the LittleCMS hex value for the popup to use
                    swatchEl.dataset.lcmsHex = hexValue;
                   
                    infoEl.innerHTML = `
                        <div class="cmw-harmony-type">${typeLabel}</div>
                        <div class="cmw-harmony-match">${colorName}</div>
                        <div class="cmw-harmony-brand">${libraryName}</div>
                        <div class="cmw-harmony-cmyk">${cmykText}</div>
                        <div class="cmw-harmony-hex">${hexValue}</div>
                        <div class="cmw-harmony-lab">Lab(${labValues.map(v => v.toFixed(2)).join(', ')})</div>
                    `;
                }).catch((error) => {
                    console.error('LittleCMS API unavailable for harmony colors:', error);
                    // Show error state - no fallback to local JS conversion
                    infoEl.innerHTML = `
                        <div class="cmw-harmony-type">${typeLabel}</div>
                        <div class="cmw-harmony-match">${colorName}</div>
                        <div class="cmw-harmony-brand">${libraryName}</div>
                        <div class="cmw-harmony-cmyk">API Error</div>
                        <div class="cmw-harmony-hex">API Error</div>
                        <div class="cmw-harmony-lab">Lab(${labValues.map(v => v.toFixed(2)).join(', ')})</div>
                    `;
                });
               
                colorEl.appendChild(swatchEl);
                colorEl.appendChild(infoEl);
                colorsEl.appendChild(colorEl);
            });
        }

        function calculateLocalHarmonies(lab, harmonyType) {
            // Fallback local harmony calculation
            const harmonies = [];
            const baseHue = Math.atan2(lab.b, lab.a) * 180 / Math.PI;
           
            let hueOffsets = [];
            switch (harmonyType) {
                case 'complementary':
                    hueOffsets = [0, 180];
                    break;
                case 'triadic':
                    hueOffsets = [0, 120, 240];
                    break;
                case 'tetradic':
                    hueOffsets = [0, 90, 180, 270];
                    break;
                case 'analogous':
                    hueOffsets = [0, 30, -30];
                    break;
                case 'splitComplementary':
                    hueOffsets = [0, 150, 210];
                    break;
                case 'monochromatic':
                    hueOffsets = [0, 0, 0, 0, 0];
                    break;
                default:
                    hueOffsets = [0, 180];
            }
           
            hueOffsets.forEach((offset, index) => {
                let newLab;
                if (harmonyType === 'monochromatic') {
                    const lightnessMod = (index - 2) * 15; // Vary lightness
                    newLab = {
                        L: Math.max(0, Math.min(100, lab.L + lightnessMod)),
                        a: lab.a,
                        b: lab.b
                    };
                } else {
                    const newHue = (baseHue + offset) * Math.PI / 180;
                    const chroma = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
                    newLab = {
                        L: lab.L,
                        a: chroma * Math.cos(newHue),
                        b: chroma * Math.sin(newHue)
                    };
                }
               
                harmonies.push({
                    lab: [newLab.L, newLab.a, newLab.b],
                    gamut: { inGamut: true }, // Assume in gamut for fallback
                    libraryMatches: {}
                });
            });
           
            return harmonies;
        }

        /* 12. Rendering Intent Functions */
       
        // Store current color data for rendering intent calculations
        let currentColorData = null;
        let currentRenderingIntentData = null;
        let currentOriginalInputData = null; // Track original input for rendering intents

        // Function to apply rendering intent to any Lab values
        async function applyRenderingIntentToLab(lab, originalData = null) {
            const currentIntent = document.getElementById('cmw-default-intent').value;
           
            // If it's None, return original values
            if (currentIntent === 'none') {
                return {
                    lab: lab,
                    intent: 'None',
                    converted: false
                };
            }
           
            // If it's Relative Colorimetric (default), no conversion needed
            if (currentIntent === '1') {
                return {
                    lab: lab,
                    intent: 'Relative Colorimetric',
                    converted: false
                };
            }
           
            try {
                // Get rendering intent data for this color
                const data = await compareRenderingIntents(lab, originalData);
                const intentMap = {
                    '0': 'perceptual',
                    '1': 'relative',
                    '2': 'saturation',
                    '3': 'absolute'
                };
               
                const intentNames = {
                    'none': 'None',
                    '0': 'Perceptual',
                    '1': 'Relative Colorimetric',
                    '2': 'Saturation',
                    '3': 'Absolute Colorimetric'
                };
               
                const selectedIntentName = intentMap[currentIntent];
                if (data.renderingIntents[selectedIntentName] && data.renderingIntents[selectedIntentName].lab) {
                    return {
                        lab: {
                            L: data.renderingIntents[selectedIntentName].lab[0],
                            a: data.renderingIntents[selectedIntentName].lab[1],
                            b: data.renderingIntents[selectedIntentName].lab[2]
                        },
                        intent: intentNames[currentIntent],
                        converted: true,
                        gamut: data.renderingIntents[selectedIntentName].gamut
                    };
                }
            } catch (error) {
                console.warn('Failed to apply rendering intent:', error);
            }
           
            // Fallback to original values
            const intentNames = {
                'none': 'None',
                '0': 'Perceptual',
                '1': 'Relative Colorimetric',
                '2': 'Saturation',
                '3': 'Absolute Colorimetric'
            };
           
            return {
                lab: lab,
                intent: intentNames[currentIntent],
                converted: false
            };
        }

        async function updateRenderingIntents(lab, originalData = null) {
            const intentsSection = document.getElementById('cmw-intents-section');
            const intentsToggle = document.getElementById('cmw-intents-toggle');
            const loadingEl = document.getElementById('cmw-intents-loading');
            const statusEl = document.getElementById('cmw-intents-status');
            const currentIntent = document.getElementById('cmw-default-intent').value;
           
            if (!intentsToggle.checked || !lab || currentIntent === 'none') {
                intentsSection.style.display = 'none';
                resetIntentCards();
                currentRenderingIntentData = null;
                return;
            }
           
            intentsSection.style.display = 'block';
           
            try {
                loadingEl.classList.add('show');
                statusEl.classList.remove('show');
                resetIntentCards();
               
                console.log('=== Rendering Intent Comparison ===');
                console.log('Lab values:', lab);
                console.log('Original data:', originalData);
                console.log('API Base URL:', getApiBaseUrl());
               
                // Try API first with comprehensive error handling
                let renderingData = null;
                let apiError = null;
               
                try {
                    const data = await compareRenderingIntents(lab, originalData);
                    if (data && data.renderingIntents) {
                        renderingData = data.renderingIntents;
                        console.log('✓ API rendering intent data received:', renderingData);
                    } else {
                        console.warn('⚠ API returned unexpected format:', data);
                        throw new Error('Invalid API response format');
                    }
                } catch (error) {
                    apiError = error;
                    console.warn('✗ API rendering intent comparison failed:', error.message);
                }
               
                if (renderingData) {
                    // Success: Use API data
                    currentRenderingIntentData = renderingData;
                    displayRenderingIntents(renderingData);
                   
                    // Show success message with input type info
                    let inputTypeMsg = '';
                    if (originalData && originalData.type === 'library') {
                        inputTypeMsg = ' (Library color)';
                    } else if (originalData && originalData.type === 'cmyk') {
                        inputTypeMsg = ' (CMYK input)';
                    } else if (originalData && originalData.type === 'rgb') {
                        inputTypeMsg = ' (RGB input)';
                    } else if (originalData && originalData.type === 'hex') {
                        inputTypeMsg = ' (Hex input)';
                    } else {
                        inputTypeMsg = ' (Lab input)';
                    }
                   
                    statusEl.textContent = `Rendering intent comparison complete${inputTypeMsg}`;
                    statusEl.className = 'cmw-status success show';
                   
                    console.log('✓ Successfully displayed API rendering intents');
                   
                } else {
                    // Fallback: Generate demo data
                    console.log('→ Using fallback rendering intent display');
                    displayFallbackRenderingIntents(lab);
                    currentRenderingIntentData = null;
                   
                    // More concise error message
                    let errorMsg = 'Using fallback comparison';
                    if (apiError && apiError.message.includes('Failed to fetch')) {
                        errorMsg += ' (API server not reachable)';
                    }
                   
                    statusEl.textContent = errorMsg;
                    statusEl.className = 'cmw-status warning show';
                }
               
            } catch (error) {
                console.error('Critical error in rendering intent section:', error);
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.className = 'cmw-status error show';
               
                // Still try to show fallback
                displayFallbackRenderingIntents(lab);
               
            } finally {
                loadingEl.classList.remove('show');
            }
        }

        // Helper function to update preview with current data
        function updateColorPreviewWithCurrentData() {
            const selectedType = document.getElementById('cmw-search-type-select').value;
           
            // Only update for non-name searches where we have converted color info
            if (selectedType !== 'name' && currentAnalysisData) {
                const gamutToggle = document.getElementById('cmw-gamut-toggle');
                const showGamut = gamutToggle && gamutToggle.checked;
               
                if (showGamut || currentRenderingIntentData) {
                    // Update the converted color info with rendering intent data
                    updateConvertedColorInfo(
                        currentAnalysisData,
                        'direct',
                        'GRACoL2013.icc',
                        null,
                        currentRenderingIntentData
                    );
                }
            }
        }

        function resetIntentCards() {
            ['perceptual', 'relative', 'saturation', 'absolute'].forEach(intent => {
                const card = document.getElementById(`cmw-intent-${intent}`);
                if (card) {
                    card.classList.remove('current');
                    const swatch = card.querySelector('.cmw-intent-swatch');
                    const delta = card.querySelector('.cmw-intent-delta');
                    const labEl = card.querySelector('.cmw-intent-lab');
                   
                    swatch.style.backgroundColor = '#f8fafc';
                    swatch.classList.remove('in-gamut');
                    swatch.classList.add('no-gamut-indicator'); // Hide indicator when reset
                    delta.textContent = 'ΔE: --';
                    labEl.textContent = 'Lab: --';
                }
            });
        }

        function displayRenderingIntents(intents) {
            const currentIntent = document.getElementById('cmw-default-intent').value;
            const intentMap = {
                'none': 'none',
                '0': 'perceptual',
                '1': 'relative',
                '2': 'saturation',
                '3': 'absolute'
            };
           
            // Don't display anything if "none" is selected
            if (currentIntent === 'none') {
                return;
            }
            
            // Check if gamut indicator is enabled
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            const showGamutIndicator = gamutToggle && gamutToggle.checked;
           
            console.log('Displaying rendering intents:', intents);
            console.log('Current intent setting:', currentIntent, 'maps to:', intentMap[currentIntent]);
            console.log('Gamut indicator enabled:', showGamutIndicator);
           
            Object.entries(intents).forEach(([intentName, data]) => {
                const card = document.getElementById(`cmw-intent-${intentName}`);
                if (!card) {
                    console.warn(`Card not found for intent: cmw-intent-${intentName}`);
                    return;
                }
               
                if (data.error) {
                    console.warn(`Error in intent data for ${intentName}:`, data.error);
                    return;
                }
               
                const swatch = card.querySelector('.cmw-intent-swatch');
                const delta = card.querySelector('.cmw-intent-delta');
                const labEl = card.querySelector('.cmw-intent-lab');
               
                // Highlight current intent
                if (intentMap[currentIntent] === intentName) {
                    card.classList.add('current');
                    console.log(`Highlighted ${intentName} as current intent`);
                } else {
                    card.classList.remove('current');
                }
               
                // Set swatch color using LittleCMS for consistency with popup
                if (data.lab && data.lab.length >= 3) {
                    // Show immediate preview with local conversion
                    swatch.style.backgroundColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                   
                    // Then update with LittleCMS conversion for accuracy (Lab → RGB uses sRGB)
                    convertColor({
                        lab: [data.lab[0], data.lab[1], data.lab[2]],
                        profile: 'sRGB.icc'
                    }).then(lcmsData => {
                        if (lcmsData.hex) {
                            let hexColor = lcmsData.hex;
                            if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                            swatch.style.backgroundColor = hexColor;
                            // Store for popup consistency
                            swatch.dataset.lcmsHex = hexColor.toUpperCase();
                        }
                    }).catch(() => {
                        // Keep local conversion on error
                    });
                   
                    // Only show gamut indicator if gamut toggle is on
                    if (showGamutIndicator) {
                        // Remove the hide class first
                        swatch.classList.remove('no-gamut-indicator');
                        if (data.gamut && data.gamut.inGamut) {
                            swatch.classList.add('in-gamut');
                        } else {
                            swatch.classList.remove('in-gamut');
                            // Out of gamut - the default ::after shows the warning
                        }
                    } else {
                        // Hide gamut indicator when toggle is off
                        swatch.classList.remove('in-gamut');
                        swatch.classList.add('no-gamut-indicator');
                    }
                   
                    delta.textContent = `ΔE: ${(data.deltaE || 0).toFixed(2)}`;
                    labEl.textContent = `Lab(${data.lab.map(v => v.toFixed(2)).join(', ')})`;
                } else {
                    console.warn(`Invalid lab data for ${intentName}:`, data);
                    swatch.style.backgroundColor = '#f8fafc';
                    swatch.classList.remove('in-gamut');
                    delta.textContent = 'ΔE: --';
                    labEl.textContent = 'Lab: --';
                }
            });
        }

        function displayFallbackRenderingIntents(lab) {
            // No fallback - LittleCMS API is required for rendering intent calculations
            // Show error state for all intent cards
            console.error('LittleCMS API unavailable - cannot display rendering intents');
            
            ['perceptual', 'relative', 'saturation', 'absolute'].forEach(intentName => {
                const card = document.getElementById(`cmw-intent-${intentName}`);
                if (!card) return;
               
                const swatch = card.querySelector('.cmw-intent-swatch');
                const delta = card.querySelector('.cmw-intent-delta');
                const labEl = card.querySelector('.cmw-intent-lab');
               
                card.classList.remove('current');
                swatch.style.backgroundColor = '#f0f0f0';
                swatch.classList.remove('in-gamut');
                delta.textContent = 'API Error';
                labEl.textContent = 'LittleCMS unavailable';
            });
        }

        /* 13. Search and Results Functions */
       
        function searchByNameComplete(query) {
            const q = query.trim().toLowerCase();
            if (!q) return [];
           
            const results = [];
           
            let targetLibrary = null;
            let searchTerm = q;
            let showLibraryColors = false; // Flag to show colors from library
            let colorTypeFilter = null; // LAB-based color type filter
            
            // Define LAB-based color type filters
            const colorTypes = {
                'red': (L, a, b) => a > 20 && Math.abs(b) < 50 && L > 20 && L < 80,
                'blue': (L, a, b) => b < -10 && a < 30 && L > 20 && L < 80,
                'green': (L, a, b) => a < -10 && b > 0 && L > 20 && L < 80,
                'yellow': (L, a, b) => b > 40 && a > -20 && a < 40 && L > 50,
                'orange': (L, a, b) => a > 20 && b > 30 && L > 40 && L < 85,
                'purple': (L, a, b) => a > 10 && b < -5 && L > 20 && L < 70,
                'violet': (L, a, b) => a > 10 && b < -5 && L > 20 && L < 70,
                'pink': (L, a, b) => a > 15 && b > -10 && L > 60 && L < 95,
                'brown': (L, a, b) => a > 5 && b > 5 && L > 20 && L < 60,
                'gray': (L, a, b) => Math.abs(a) < 10 && Math.abs(b) < 10 && L > 30 && L < 80,
                'grey': (L, a, b) => Math.abs(a) < 10 && Math.abs(b) < 10 && L > 30 && L < 80,
                'black': (L, a, b) => L < 30,
                'white': (L, a, b) => L > 85 && Math.abs(a) < 10 && Math.abs(b) < 10,
                'beige': (L, a, b) => a > -5 && a < 15 && b > 5 && b < 30 && L > 60 && L < 90,
                'tan': (L, a, b) => a > 0 && a < 20 && b > 10 && b < 35 && L > 50 && L < 75,
                'cream': (L, a, b) => a > -5 && a < 10 && b > 5 && b < 25 && L > 80,
                'navy': (L, a, b) => b < -15 && a < 10 && L < 40,
                'teal': (L, a, b) => a < -5 && b < 5 && b > -25 && L > 30 && L < 70,
                'turquoise': (L, a, b) => a < -15 && b < -5 && L > 50,
                'aqua': (L, a, b) => a < -15 && b < -5 && L > 50,
                'maroon': (L, a, b) => a > 15 && b > -5 && b < 20 && L < 40,
                'burgundy': (L, a, b) => a > 15 && b > -10 && b < 15 && L < 45,
                'coral': (L, a, b) => a > 25 && b > 20 && L > 55 && L < 80,
                'peach': (L, a, b) => a > 10 && b > 15 && L > 70 && L < 90,
                'lavender': (L, a, b) => a > 5 && b < -5 && L > 70 && L < 90,
                'mint': (L, a, b) => a < -10 && b > 5 && L > 75,
                'olive': (L, a, b) => a < 5 && b > 10 && b < 40 && L > 35 && L < 65,
                'sage': (L, a, b) => a < -5 && a > -15 && b > 5 && b < 20 && L > 55 && L < 75
            };
            
            // Check if query matches a color type
            if (colorTypes[q]) {
                colorTypeFilter = colorTypes[q];
            }
           
            // Build dynamic prefixes from all loaded libraries
            const brandPrefixes = {
                'behr': ['behr'],
                'sherwin': ['sherwin', 'sw', 'sherwin williams'],
                'bm': ['bm', 'benjamin', 'benjamin moore'],
                'pantone': ['pantone', 'pms']
            };
            
            // Add all other libraries dynamically
            for (const [libId, libName] of Object.entries(libNames)) {
                const nameLower = libName.toLowerCase();
                if (!brandPrefixes[libId]) {
                    brandPrefixes[libId] = [nameLower, libId.toLowerCase()];
                }
            }
           
            // Check if query is just a library name or starts with library name
            for (const [libId, prefixes] of Object.entries(brandPrefixes)) {
                for (const prefix of prefixes) {
                    // Exact match of library name - show colors from that library
                    if (q === prefix) {
                        targetLibrary = libId;
                        searchTerm = '';
                        showLibraryColors = true;
                        break;
                    }
                    // Partial match of library name (at least 3 chars) - show colors from that library
                    if (q.length >= 3 && prefix.startsWith(q) && !q.includes(' ')) {
                        targetLibrary = libId;
                        searchTerm = '';
                        showLibraryColors = true;
                        break;
                    }
                    // Library name with space/dash - search within that library
                    if (q.startsWith(prefix + ' ') || q.startsWith(prefix + '-') || q.startsWith(prefix + '#')) {
                        targetLibrary = libId;
                        searchTerm = q.substring(prefix.length).replace(/^[\s\-#]+/, '').trim();
                        break;
                    }
                }
                if (targetLibrary) break;
            }
           
            const libsToSearch = targetLibrary ? [targetLibrary] : Object.keys(libs);
            const activeLibs = getActiveLibraries();
           
            for (const libId of libsToSearch) {
                const lib = libs[libId];
                
                // If showing library colors (just library name typed), return first colors
                if (showLibraryColors) {
                    const libraryColors = (lib || []).slice(0, 20); // Get first 20 colors
                    for (const color of libraryColors) {
                        results.push({
                            color,
                            matchType: 'library',
                            isFromActiveLibrary: activeLibs.includes(libId),
                            isTargetLibrary: true
                        });
                    }
                    continue;
                }
                
                // Normal search logic (with optional color type filtering)
                for (const color of lib || []) {
                    const colorName = color.name.toLowerCase();
                    const matchAgainst = targetLibrary ? searchTerm : q;
                   
                    let matchType = null;
                    
                    // First check name matches
                    if (colorName === matchAgainst ||
                        (targetLibrary && colorName.includes(matchAgainst)) ||
                        (!targetLibrary && colorName === q)) {
                        matchType = 'exact';
                    } else if (colorName.includes(matchAgainst)) {
                        matchType = 'partial';
                    }
                    // If no name match but we have a color type filter, check LAB values
                    else if (colorTypeFilter && colorTypeFilter(color.L, color.a, color.b)) {
                        matchType = 'colortype';
                    }
                   
                    if (matchType) {
                        results.push({
                            color,
                            matchType,
                            isFromActiveLibrary: activeLibs.includes(libId),
                            isTargetLibrary: !!targetLibrary
                        });
                    }
                }
            }
           
            results.sort((a, b) => {
                if (a.isTargetLibrary && !b.isTargetLibrary) return -1;
                if (!a.isTargetLibrary && b.isTargetLibrary) return 1;
                if (a.isFromActiveLibrary && !b.isFromActiveLibrary) return -1;
                if (!a.isFromActiveLibrary && b.isFromActiveLibrary) return 1;
                
                // Prioritize exact name matches over color type matches
                const matchPriority = { exact: 0, partial: 1, colortype: 2, library: 3 };
                const aPriority = matchPriority[a.matchType] || 99;
                const bPriority = matchPriority[b.matchType] || 99;
                if (aPriority !== bPriority) return aPriority - bPriority;
                
                return 0;
            });
           
            return results;
        }

        function displayResults(matches, profile = null) {
            const table = document.getElementById('cmw-out');
            const tbody = table.querySelector('tbody');
            const thead = table.querySelector('thead tr');
           
            tbody.innerHTML = '';
           
            // Check if Amazon link filter is enabled
            const amazonFilter = document.getElementById('cmw-filter-amazon');
            const filterControls = document.getElementById('cmw-filter-controls');
            const filterCount = document.getElementById('cmw-filter-count');
            
            // Count colors with Amazon links (check multiple possible field names)
            const colorsWithAmazon = matches.filter(m => m.c && (m.c.amazon_link || m.c.amazonLink)).length;
            
            console.log('🔍 Amazon Filter Check:', {
                totalMatches: matches.length,
                colorsWithAmazon: colorsWithAmazon,
                sampleColor: matches[0]?.c
            });
            
            // Show/hide filter controls based on whether any colors have Amazon links
            if (colorsWithAmazon > 0) {
                filterControls.style.display = 'block';
                filterCount.textContent = `${colorsWithAmazon} available`;
                console.log('✅ Amazon filter shown:', colorsWithAmazon, 'colors with links');
            } else {
                filterControls.style.display = 'none';
                console.log('⚠️ No colors with Amazon links found in results');
            }
            
            // Apply Amazon link filter if enabled
            let filteredMatches = matches;
            if (amazonFilter && amazonFilter.checked) {
                filteredMatches = matches.filter(m => m.c && (m.c.amazon_link || m.c.amazonLink));
                console.log('🎯 Filter applied:', filteredMatches.length, 'colors with Amazon links shown');
            }
           
            // Check if gamut checking is enabled
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            const showGamut = gamutToggle && gamutToggle.checked;
           
            // Update table header - always show Lab column, gamut info will be in the color
            thead.innerHTML = `
                <th>Swatch</th>
                <th>Name</th>
                <th>Library</th>
                <th>ΔE</th>
                <th>Lab</th>
            `;
           
            // Determine which profile to use for gamut checking
            let gamutProfile = 'GRACoL2013.icc';
            if (showGamut) {
                const searchType = document.getElementById('cmw-search-type-select').value;
                if (searchType === 'cmyk' && profile && profile.includes('SWOP')) {
                    gamutProfile = profile;
                }
            }
           
            // Process matches asynchronously for gamut checking
            const processMatches = async () => {
                for (const { c, d } of filteredMatches) {
                    const col = lab2rgb(c.L, c.a, c.b);
                   
                    let labDisplay = `${c.L.toFixed(2)}, ${c.a.toFixed(2)}, ${c.b.toFixed(2)}`;
                   
                    if (showGamut) {
                        try {
                            const gamutData = await checkGamut({ L: c.L, a: c.a, b: c.b }, gamutProfile);
                            if (gamutData) {
                                const labColor = gamutData.inGamut ? '#10b981' : '#ef4444'; // green if in gamut, red if out
                                labDisplay = `<span style="color: ${labColor};">${labDisplay}</span>`;
                            }
                        } catch (error) {
                            console.error('Gamut check failed for', c.name, ':', error);
                        }
                    }
                   
                    // Shorten "Pantone" to "PMS" in display
                    let displayName = c.name.replace(/^Pantone\s*/i, 'PMS ');
                    // Convert Crayola color names to lowercase
                    if (c.library === 'crayola') {
                        displayName = displayName.toLowerCase();
                    }
                    const displayLibrary = (c.libraryName || 'Unknown').replace(/^Pantone$/i, 'PMS');
                    
                    // Add Amazon link indicator if present (check both field names)
                    const hasAmazonLink = c.amazon_link || c.amazonLink;
                    const amazonIndicator = hasAmazonLink ? ' <img src="https://www.amazon.com/favicon.ico" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 4px;" title="Available on Amazon">' : '';
                    
                    // Store all color data in row dataset for click handler (including RGB & CMYK if present)
                    // Store library ID to retrieve full color object (with spectral) later
                    const rowHTML = `
                        <tr style="cursor: pointer;" 
                            title="${hasAmazonLink ? 'Click for details and purchase link' : 'Click for details'}"
                            data-color-name="${c.name.replace(/"/g, '&quot;')}"
                            data-color-l="${c.L}"
                            data-color-a="${c.a}"
                            data-color-b="${c.b}"
                            data-library-name="${(c.libraryName || '').replace(/"/g, '&quot;')}"
                            data-library="${c.library || ''}"
                            data-amazon-link="${(c.amazon_link || c.amazonLink || '').replace(/"/g, '&quot;')}"
                            data-manufacturer-link="${(c.manufacturer_link || c.manufacturerLink || '').replace(/"/g, '&quot;')}"
                            data-hex="${(c.hex || '').replace(/"/g, '&quot;')}"
                            data-rgb-r="${c.rgb_r !== undefined ? c.rgb_r : ''}"
                            data-rgb-g="${c.rgb_g !== undefined ? c.rgb_g : ''}"
                            data-rgb-b="${c.rgb_b !== undefined ? c.rgb_b : ''}"
                            data-cmyk-c="${c.cmyk_c !== undefined ? c.cmyk_c : ''}"
                            data-cmyk-m="${c.cmyk_m !== undefined ? c.cmyk_m : ''}"
                            data-cmyk-y="${c.cmyk_y !== undefined ? c.cmyk_y : ''}"
                            data-cmyk-k="${c.cmyk_k !== undefined ? c.cmyk_k : ''}"
                            data-manufacturer="${(c.manufacturer || '').replace(/"/g, '&quot;')}"
                            data-filament-type="${(c.filament_type || '').replace(/"/g, '&quot;')}"
                            data-lab-calculated="${c.lab_calculated ? 'true' : 'false'}"
                            data-has-spectral="${c.spectral ? 'true' : 'false'}">
                            <td><div class="cmw-swatch" style="background:${col}"></div></td>
                            <td>${displayName}${amazonIndicator}</td>
                            <td>${displayLibrary}</td>
                            <td>${d.toFixed(2)}</td>
                            <td>${labDisplay}</td>
                        </tr>
                    `;
                   
                    tbody.insertAdjacentHTML('beforeend', rowHTML);
                }
            };
           
            processMatches();
            table.hidden = false;
        }

        /* 14. Main Search Function */
       
        async function performUnifiedSearch() {
            if (!libsLoaded) {
                showStatus('Color libraries are still loading. Please wait.', 'error');
                return;
            }
           
            const activeLibs = getActiveLibraries();
            if (activeLibs.length === 0) {
                showStatus('Please select at least one color library for results.', 'error');
                return;
            }
           
            const selectedType = document.getElementById('cmw-search-type-select').value;
            let finalLab = null;
            let searchType = '';
            let selectedColorName = null; // Track selected color name for exclusion from results
           
            showLoading(true);
           
            try {
                if (selectedType === 'name') {
                    const nameInput = document.getElementById('cmw-name-input');
                    const query = nameInput.value.trim();
                    const preview = document.getElementById('cmw-color-preview');
                   
                    if (!query) {
                        throw new Error('Please enter a hex or color name.');
                    }
                   
                    // Check if there's already a selected library color with stored Lab values
                    // Use those directly instead of re-searching
                    if (preview.dataset.selectedL && preview.dataset.selectedA && preview.dataset.selectedB && preview.dataset.selectedName) {
                        const L = parseFloat(preview.dataset.selectedL);
                        const a = parseFloat(preview.dataset.selectedA);
                        const b = parseFloat(preview.dataset.selectedB);
                        const displayName = preview.dataset.selectedName;
                        const libraryName = preview.dataset.selectedLibrary || '';
                        
                        finalLab = { L, a, b };
                        searchType = displayName;
                        selectedColorName = displayName;
                        
                        // Store original library color data for rendering intent comparison
                        currentOriginalInputData = {
                            type: 'library',
                            colorName: displayName,
                            libraryName: libraryName
                        };
                        
                        document.getElementById('cmw-name-suggestions').classList.remove('show');
                        
                        console.log('Using stored library Lab values:', L, a, b);
                    } else if (isValidHex(query)) {
                        const normalizedHex = query.startsWith('#') ? query.substring(1) : query;
                        const rgb = hex2rgb(normalizedHex);
                        const data = await convertColor({
                            rgb: [rgb.r, rgb.g, rgb.b],
                            profile: 'sRGB.icc'
                        });
                        finalLab = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                        searchType = `hex #${normalizedHex}`;
                        document.getElementById('cmw-name-suggestions').classList.remove('show');
                        // Don't reset selected color info for hex searches - preserve intent swatch
                       
                        // Clear original input data for hex search
                        currentOriginalInputData = null;
                    } else {
                        // Handle name search with suggestions
                        const nameResults = searchByNameComplete(query);
                       
                        if (nameResults.length === 0) {
                            throw new Error(`No colors found matching "${query}" in any library. Try a different search term or hex value.`);
                        }
                       
                        const exactMatch = nameResults.find(r => r.matchType === 'exact');
                        if (exactMatch) {
                            // Shorten "Pantone" to "PMS" for display
                            const displayName = exactMatch.color.name.replace(/^Pantone\s*/i, 'PMS ');
                            finalLab = { L: exactMatch.color.L, a: exactMatch.color.a, b: exactMatch.color.b };
                            searchType = displayName;
                           
                            // Store the selected color name for exclusion from results
                            selectedColorName = exactMatch.color.name;
                           
                            // Store original library color data for rendering intent comparison (Lab-based but with context)
                            currentOriginalInputData = {
                                type: 'library',
                                colorName: displayName,
                                libraryName: exactMatch.color.libraryName
                            };
                           
                            // Update preview for exact match
                            const exactColor = lab2rgb(exactMatch.color.L, exactMatch.color.a, exactMatch.color.b);
                            preview.style.backgroundColor = exactColor;
                            preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                            preview.classList.add('valid', 'selected');
                           
                            preview.dataset.selectedL = exactMatch.color.L;
                            preview.dataset.selectedA = exactMatch.color.a;
                            preview.dataset.selectedB = exactMatch.color.b;
                            preview.dataset.selectedColor = exactColor;
                            preview.dataset.selectedName = displayName;
                            preview.dataset.selectedLibrary = exactMatch.color.libraryName;
                            preview.dataset.amazonLink = exactMatch.color.amazon_link || exactMatch.color.amazonLink || '';
                            preview.dataset.manufacturerLink = exactMatch.color.manufacturer_link || exactMatch.color.manufacturerLink || '';
                            // Store RGB & CMYK if available from library
                            preview.dataset.hex = exactMatch.color.hex || '';
                            preview.dataset.rgbR = exactMatch.color.rgb_r !== undefined ? exactMatch.color.rgb_r : '';
                            preview.dataset.rgbG = exactMatch.color.rgb_g !== undefined ? exactMatch.color.rgb_g : '';
                            preview.dataset.rgbB = exactMatch.color.rgb_b !== undefined ? exactMatch.color.rgb_b : '';
                            preview.dataset.cmykC = exactMatch.color.cmyk_c !== undefined ? exactMatch.color.cmyk_c : '';
                            preview.dataset.cmykM = exactMatch.color.cmyk_m !== undefined ? exactMatch.color.cmyk_m : '';
                            preview.dataset.cmykY = exactMatch.color.cmyk_y !== undefined ? exactMatch.color.cmyk_y : '';
                            preview.dataset.cmykK = exactMatch.color.cmyk_k !== undefined ? exactMatch.color.cmyk_k : '';
                           
                            updateSelectedColorInfo({
                                name: displayName,
                                libraryName: exactMatch.color.libraryName,
                                L: exactMatch.color.L,
                                a: exactMatch.color.a,
                                b: exactMatch.color.b
                            });
                           
                            // Update converted color info with library's known Lab values
                            const gamutToggle = document.getElementById('cmw-gamut-toggle');
                            const showGamut = gamutToggle && gamutToggle.checked;
                            const libLab = { L: exactMatch.color.L, a: exactMatch.color.a, b: exactMatch.color.b };
                            if (showGamut) {
                                checkGamut(libLab, 'GRACoL2013.icc')
                                    .then(gamutData => {
                                        updateConvertedColorInfo(
                                            libLab,
                                            'library',
                                            `${exactMatch.color.libraryName} Library`,
                                            gamutData ? gamutData.inGamut : null
                                        );
                                    })
                                    .catch(() => {
                                        updateConvertedColorInfo(libLab, 'library', `${exactMatch.color.libraryName} Library`);
                                    });
                            } else {
                                updateConvertedColorInfo(libLab, 'library', `${exactMatch.color.libraryName} Library`);
                            }
                           
                            document.getElementById('cmw-name-suggestions').classList.remove('show');
                        } else {
                            showSuggestions(query);
                            showStatus(`Found ${nameResults.length} partial matches. Click a suggestion to find closest colors.`, 'success', true);
                            showLoading(false);
                            return;
                        }
                    }
                   
                } else if (selectedType === 'lab') {
                    const L = parseFloat(document.getElementById('cmw-lab-l').value);
                    const a = parseFloat(document.getElementById('cmw-lab-a').value);
                    const b = parseFloat(document.getElementById('cmw-lab-b').value);
                   
                    if (isNaN(L) || isNaN(a) || isNaN(b)) {
                        throw new Error('Please enter all Lab values (L*, a*, b*).');
                    }
                   
                    if (L < 0 || L > 100) {
                        throw new Error('L* value must be between 0 and 100.');
                    }
                    if (a < -128 || a > 127 || b < -128 || b > 127) {
                        throw new Error('a* and b* values must be between -128 and 127.');
                    }
                   
                    finalLab = { L, a, b };
                    searchType = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)})`;
                   
                    // Clear original input data for Lab search
                    currentOriginalInputData = null;
                   
                } else if (selectedType === 'cmyk') {
                    const c = parseFloat(document.getElementById('cmw-cmyk-c').value);
                    const m = parseFloat(document.getElementById('cmw-cmyk-m').value);
                    const y = parseFloat(document.getElementById('cmw-cmyk-y').value);
                    const k = parseFloat(document.getElementById('cmw-cmyk-k').value);
                   
                    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
                        throw new Error('Please enter all CMYK values (C, M, Y, K).');
                    }
                   
                    if (c < 0 || c > 100 || m < 0 || m > 100 || y < 0 || y > 100 || k < 0 || k > 100) {
                        throw new Error('CMYK values must be between 0 and 100.');
                    }
                   
                    const profile = document.getElementById('cmw-profile-select').value;
                    const data = await convertColor({
                        cmyk: [c, m, y, k],
                        profile: profile
                    });
                    finalLab = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                    searchType = `CMYK(${c}, ${m}, ${y}, ${k}) via ${profile}`;
                   
                    // Store CMYK info for display purposes only (not used for rendering intent API calls)
                    currentOriginalInputData = {
                        type: 'cmyk',
                        values: [c, m, y, k],
                        profile: profile
                    };
                   
                } else if (selectedType === 'rgb') {
                    const r = parseFloat(document.getElementById('cmw-rgb-r').value);
                    const g = parseFloat(document.getElementById('cmw-rgb-g').value);
                    const b = parseFloat(document.getElementById('cmw-rgb-b').value);
                   
                    if (isNaN(r) || isNaN(g) || isNaN(b)) {
                        throw new Error('Please enter all RGB values (R, G, B).');
                    }
                   
                    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
                        throw new Error('RGB values must be between 0 and 255.');
                    }
                   
                    const data = await convertColor({
                        rgb: [r, g, b],
                        profile: 'sRGB.icc'
                    });
                    finalLab = { L: data.lab[0], a: data.lab[1], b: data.lab[2] };
                    searchType = `RGB(${r}, ${g}, ${b}) via sRGB.icc`;
                   
                    // Clear original input data for RGB search
                    currentOriginalInputData = null;
                }
               
                if (!finalLab) {
                    throw new Error('Unable to determine color values for search.');
                }
               
                // Store current analysis data for features
                currentAnalysisData = finalLab;
                console.log('Set currentAnalysisData:', currentAnalysisData);
               
                // Update the intent swatch for the search color (maintain rendering intent display)
                updateIntentSwatch(finalLab);
               
                // Perform search
                const resultsCount = getResultsCount();
                console.log('Performing search with resultsCount:', resultsCount, 'selectedColorName:', selectedColorName);
                // Exclude the selected color from results if it was an exact name match
                const matches = nearest(finalLab.L, finalLab.a, finalLab.b, resultsCount, selectedColorName || null);
                console.log('Search matches found:', matches.length, matches);
               
                // Store results globally for 3D visualization
                currentSearchResults = matches;
                console.log('=== Search Results Storage ===');
                console.log('Stored', matches.length, 'results for 3D visualization');
                console.log('Rendering intent enabled:', document.getElementById('cmw-default-intent').value !== 'none');
               
                // Debug: Check for duplicates in stored results
                const resultNames = matches.map(m => m.c.name);
                const uniqueNames = new Set(resultNames);
                if (resultNames.length !== uniqueNames.size) {
                    console.warn('⚠️ Duplicate names detected in search results:');
                    const nameCount = {};
                    resultNames.forEach(name => {
                        nameCount[name] = (nameCount[name] || 0) + 1;
                    });
                    Object.entries(nameCount).forEach(([name, count]) => {
                        if (count > 1) {
                            console.warn(`  - "${name}": ${count} times`);
                        }
                    });
                }
               
                const profile = selectedType === 'cmyk' ? document.getElementById('cmw-profile-select').value : null;
                displayResults(matches, profile);
               
                // Update advanced features if enabled
                const harmonyToggle = document.getElementById('cmw-harmony-toggle');
                if (harmonyToggle.checked) {
                    updateColorHarmonies(finalLab);
                }
               
                // Always try to update rendering intents if enabled - ensure CMYK works like other types
                const intentsToggle = document.getElementById('cmw-intents-toggle');
                if (intentsToggle.checked) {
                    console.log('=== Updating Rendering Intents from Search ===');
                    console.log('Final Lab values:', finalLab);
                   
                    // For CMYK, use null to ensure consistent Lab-based processing like other input types
                    const renderingOriginalData = (selectedType === 'cmyk') ? null : currentOriginalInputData;
                    console.log('Original input data for rendering:', renderingOriginalData);
                    console.log('Calling updateRenderingIntents...');
                    updateRenderingIntents(finalLab, renderingOriginalData);
                }
               
                document.getElementById('cmw-name-suggestions').classList.remove('show');
               
                // For non-name searches, clear library color info but preserve intent swatch
                if (selectedType !== 'name') {
                    const colorInfoEl = document.getElementById('cmw-selected-color-info');
                    colorInfoEl.classList.remove('show');
                   
                    const preview = document.getElementById('cmw-color-preview');
                    preview.classList.remove('selected');
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    // Don't call updateSelectedColorInfo(null) as it would reset the intent swatch
                }
               
                showStatus(`Found ${matches.length} closest colors to ${searchType}`, 'success', true);
               
            } catch (error) {
                showStatus(error.message, 'error');
            } finally {
                showLoading(false);
            }
        }
        /* ─────────────────────
           Section 5 Java Part 3
           ───────────────────── */
        /* 15. Suggestion Functions */
       
        let currentSuggestionQuery = '';
        let currentSuggestionOffset = 0;
        let allMatchedColors = [];
        let isLoadingMoreSuggestions = false;
        let hasMoreSuggestions = true;
        const SUGGESTIONS_BATCH_SIZE = 20;

        function initializeSuggestions(query) {
            currentSuggestionQuery = query;
            currentSuggestionOffset = 0;
            hasMoreSuggestions = true;
            isLoadingMoreSuggestions = false;
           
            allMatchedColors = searchByNameComplete(query);
           
            const suggestionsContent = document.querySelector('.cmw-suggestions-content');
            suggestionsContent.innerHTML = '';
           
            const loadingMore = document.getElementById('cmw-loading-more');
            const noMoreResults = document.getElementById('cmw-no-more-results');
            loadingMore.classList.remove('show');
            noMoreResults.classList.remove('show');
           
            if (allMatchedColors.length === 0) {
                return false;
            }
           
            const firstBatch = allMatchedColors.slice(0, SUGGESTIONS_BATCH_SIZE);
            appendSuggestions(firstBatch);
            currentSuggestionOffset = SUGGESTIONS_BATCH_SIZE;
           
            if (allMatchedColors.length <= SUGGESTIONS_BATCH_SIZE) {
                hasMoreSuggestions = false;
                if (allMatchedColors.length === SUGGESTIONS_BATCH_SIZE) {
                    noMoreResults.classList.add('show');
                }
            }
           
            return true;
        }

        function appendSuggestions(suggestions) {
            const suggestionsContent = document.querySelector('.cmw-suggestions-content');
            const preview = document.getElementById('cmw-color-preview');
           
            suggestions.forEach(s => {
                const suggestionEl = document.createElement('div');
                suggestionEl.className = `cmw-suggestion ${!s.isFromActiveLibrary ? 'cmw-disabled-library' : ''}`;
                suggestionEl.dataset.name = s.color.name;
                suggestionEl.dataset.l = s.color.L;
                suggestionEl.dataset.a = s.color.a;
                suggestionEl.dataset.b = s.color.b;
                suggestionEl.dataset.library = s.color.libraryName;
                suggestionEl.dataset.amazonLink = s.color.amazon_link || s.color.amazonLink || '';
                suggestionEl.dataset.manufacturerLink = s.color.manufacturer_link || s.color.manufacturerLink || '';
                // Store RGB & CMYK if available from color library
                suggestionEl.dataset.hex = s.color.hex || '';
                suggestionEl.dataset.rgbR = s.color.rgb_r !== undefined ? s.color.rgb_r : '';
                suggestionEl.dataset.rgbG = s.color.rgb_g !== undefined ? s.color.rgb_g : '';
                suggestionEl.dataset.rgbB = s.color.rgb_b !== undefined ? s.color.rgb_b : '';
                suggestionEl.dataset.cmykC = s.color.cmyk_c !== undefined ? s.color.cmyk_c : '';
                suggestionEl.dataset.cmykM = s.color.cmyk_m !== undefined ? s.color.cmyk_m : '';
                suggestionEl.dataset.cmykY = s.color.cmyk_y !== undefined ? s.color.cmyk_y : '';
                suggestionEl.dataset.cmykK = s.color.cmyk_k !== undefined ? s.color.cmyk_k : '';
                // Shorten "Pantone" to "PMS" in color names for display
                let displayName = s.color.name.replace(/^Pantone\s*/i, 'PMS ');
                // Convert Crayola color names to lowercase
                if (s.color.library === 'crayola') {
                    displayName = displayName.toLowerCase();
                }
                const displayLibrary = (s.color.libraryName || 'Unknown').replace(/^Pantone$/i, 'PMS');
                // Get the color for the swatch
                const swatchColor = lab2rgb(s.color.L, s.color.a, s.color.b);
                suggestionEl.innerHTML = `
                    <div class="cmw-suggestion-swatch" style="background-color: ${swatchColor};"></div>
                    <div class="cmw-suggestion-info">
                        <div class="cmw-suggestion-name">${displayName}</div>
                        <div class="cmw-suggestion-library">${displayLibrary}</div>
                    </div>
                `;
               
                if (!('ontouchstart' in window)) {
                    let isHovering = false;
                   
                    suggestionEl.addEventListener('mouseenter', () => {
                        isHovering = true;
                        const L = parseFloat(suggestionEl.dataset.l);
                        const a = parseFloat(suggestionEl.dataset.a);
                        const b = parseFloat(suggestionEl.dataset.b);
                       
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            const color = lab2rgb(L, a, b);
                            preview.style.backgroundColor = color;
                            preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                            preview.classList.add('valid');
                            preview.dataset.isHovering = 'true';
                           
                            updateSelectedColorInfo({
                                name: suggestionEl.dataset.name,
                                libraryName: suggestionEl.dataset.library,
                                L: L,
                                a: a,
                                b: b
                            });
                        }
                    });
                   
                    suggestionEl.addEventListener('mouseleave', () => {
                        isHovering = false;
                        preview.dataset.isHovering = 'false';
                        setTimeout(() => {
                            if (!isHovering && preview.dataset.isHovering === 'false') {
                                updateColorPreview();
                            }
                        }, 50);
                    });
                }
               
                suggestionEl.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                   
                    console.log('Suggestion clicked:', suggestionEl.dataset.name);
                   
                    const nameInput = document.getElementById('cmw-name-input');
                    // Shorten "Pantone" to "PMS" for display
                    let displayName = suggestionEl.dataset.name.replace(/^Pantone\s*/i, 'PMS ');
                    // Convert Crayola color names to lowercase
                    if (suggestionEl.dataset.library === 'crayola') {
                        displayName = displayName.toLowerCase();
                    }
                    nameInput.value = displayName;
                    document.getElementById('cmw-name-suggestions').classList.remove('show');
                   
                    const L = parseFloat(suggestionEl.dataset.l);
                    const a = parseFloat(suggestionEl.dataset.a);
                    const b = parseFloat(suggestionEl.dataset.b);
                   
                    console.log('Lab values from suggestion:', L, a, b);
                   
                    if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                        const resultsCount = getResultsCount();
                        const clickedColor = lab2rgb(L, a, b);
                        preview.style.backgroundColor = clickedColor;
                        preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                        preview.classList.add('valid', 'selected');
                        preview.dataset.isHovering = 'false';
                       
                        preview.dataset.selectedL = L;
                        preview.dataset.selectedA = a;
                        preview.dataset.selectedB = b;
                        preview.dataset.selectedColor = clickedColor;
                        preview.dataset.selectedName = displayName;
                        preview.dataset.selectedLibrary = suggestionEl.dataset.library;
                        preview.dataset.amazonLink = suggestionEl.dataset.amazonLink || '';
                        preview.dataset.manufacturerLink = suggestionEl.dataset.manufacturerLink || '';
                        // Store RGB & CMYK if available from suggestion
                        preview.dataset.hex = suggestionEl.dataset.hex || '';
                        preview.dataset.rgbR = suggestionEl.dataset.rgbR || '';
                        preview.dataset.rgbG = suggestionEl.dataset.rgbG || '';
                        preview.dataset.rgbB = suggestionEl.dataset.rgbB || '';
                        preview.dataset.cmykC = suggestionEl.dataset.cmykC || '';
                        preview.dataset.cmykM = suggestionEl.dataset.cmykM || '';
                        preview.dataset.cmykY = suggestionEl.dataset.cmykY || '';
                        preview.dataset.cmykK = suggestionEl.dataset.cmykK || '';
                       
                        console.log('About to call updateSelectedColorInfo');
                        await updateSelectedColorInfo({
                            name: displayName,
                            libraryName: suggestionEl.dataset.library,
                            L: L,
                            a: a,
                            b: b
                        });
                       
                        // Update converted color info with library's known Lab values
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        const showGamut = gamutToggle && gamutToggle.checked;
                        if (showGamut) {
                            checkGamut({ L, a, b }, 'GRACoL2013.icc')
                                .then(gamutData => {
                                    updateConvertedColorInfo(
                                        { L, a, b },
                                        'library',
                                        `${suggestionEl.dataset.library} Library`,
                                        gamutData ? gamutData.inGamut : null
                                    );
                                })
                                .catch(() => {
                                    updateConvertedColorInfo({ L, a, b }, 'library', `${suggestionEl.dataset.library} Library`);
                                });
                        } else {
                            updateConvertedColorInfo({ L, a, b }, 'library', `${suggestionEl.dataset.library} Library`);
                        }
                       
                        // Store for features and pass color name for exclusion
                        currentAnalysisData = { L: L, a: a, b: b };
                       
                        console.log('About to call nearest() for results');
                        const matches = nearest(L, a, b, resultsCount, suggestionEl.dataset.name);
                       
                        // Store results globally for 3D visualization
                        currentSearchResults = matches;
                       
                        const profile = document.getElementById('cmw-search-type-select').value === 'cmyk' ?
                            document.getElementById('cmw-profile-select').value : null;
                        console.log('About to display results:', matches);
                        displayResults(matches, profile);
                       
                        // Update features
                        const harmonyToggle = document.getElementById('cmw-harmony-toggle');
                        if (harmonyToggle.checked) {
                            updateColorHarmonies({ L: L, a: a, b: b });
                        }
                       
                        // Update rendering intents for library color
                        const intentsToggle = document.getElementById('cmw-intents-toggle');
                        if (intentsToggle.checked) {
                            const libraryOriginalData = {
                                type: 'library',
                                colorName: suggestionEl.dataset.name,
                                libraryName: suggestionEl.dataset.library
                            };
                            updateRenderingIntents({ L: L, a: a, b: b }, libraryOriginalData);
                        }
                       
                        showStatus(`Showing closest colors to "${suggestionEl.dataset.name}"`, 'success', true);
                    }
                });
               
                suggestionsContent.appendChild(suggestionEl);
            });
        }

        function showSuggestions(query) {
            const suggestionsEl = document.getElementById('cmw-name-suggestions');
           
            if (!query || query.length < 3) {
                suggestionsEl.classList.remove('show');
                return;
            }
           
            const hasResults = initializeSuggestions(query);
           
            if (hasResults) {
                suggestionsEl.classList.add('show');
            } else {
                suggestionsEl.classList.remove('show');
            }
        }

        function setupInfiniteScroll() {
            const suggestionsEl = document.getElementById('cmw-name-suggestions');
           
            suggestionsEl.addEventListener('scroll', () => {
                const scrollTop = suggestionsEl.scrollTop;
                const scrollHeight = suggestionsEl.scrollHeight;
                const clientHeight = suggestionsEl.clientHeight;
               
                if (scrollTop + clientHeight >= scrollHeight - 50) {
                    loadMoreSuggestions();
                }
            });
        }

        function loadMoreSuggestions() {
            if (isLoadingMoreSuggestions || !hasMoreSuggestions) return;
           
            isLoadingMoreSuggestions = true;
            const loadingMore = document.getElementById('cmw-loading-more');
            const noMoreResults = document.getElementById('cmw-no-more-results');
           
            loadingMore.classList.add('show');
            noMoreResults.classList.remove('show');
           
            setTimeout(() => {
                const startIndex = currentSuggestionOffset;
                const endIndex = Math.min(startIndex + SUGGESTIONS_BATCH_SIZE, allMatchedColors.length);
                const batch = allMatchedColors.slice(startIndex, endIndex);
               
                if (batch.length === 0) {
                    hasMoreSuggestions = false;
                    loadingMore.classList.remove('show');
                    noMoreResults.classList.add('show');
                    isLoadingMoreSuggestions = false;
                    return;
                }
               
                appendSuggestions(batch);
                currentSuggestionOffset = endIndex;
               
                if (endIndex >= allMatchedColors.length) {
                    hasMoreSuggestions = false;
                    noMoreResults.classList.add('show');
                }
               
                loadingMore.classList.remove('show');
                isLoadingMoreSuggestions = false;
            }, 200);
        }

        /* 18. 3D Color Space Widget - REMOVED */
        // See 3D_WIDGET_DOCUMENTATION.md for implementation details
        // Removed on 2025-12-25 - Feature deprecated
       
        /* 19. API Connectivity Check */
       
        // Simple API connectivity check for initialization
        async function checkApiConnectivity() {
            const apiUrl = getApiBaseUrl();
            console.log('Checking API connectivity:', apiUrl);
           
            try {
                // Try a simple endpoint to see if API is responding
                const response = await fetch(`${apiUrl}/convert`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lab: [50, 0, 0], // Test with neutral gray
                        profile: 'GRACoL2013.icc'
                    })
                });
               
                if (response.ok) {
                    console.log('✓ API server responding');
                    showStatus('API server connected - enhanced features available!', 'success');
                    return true;
                } else if (response.status === 400 || response.status === 422) {
                    // Bad request might be expected for test data, but server is responding
                    console.log('✓ API server responding (got expected error for test data)');
                    showStatus('API server connected - enhanced features available!', 'success');
                    return true;
                } else {
                    console.log('⚠ API server returned:', response.status);
                    showStatus(`API server returned ${response.status} - some features may be limited`, 'warning');
                    return false;
                }
            } catch (error) {
                if (error.message.includes('Failed to fetch')) {
                    console.log('✗ API server not reachable');
                    showStatus('API server not reachable - using basic color matching only', 'warning');
                } else {
                    console.log('✗ API connectivity error:', error.message);
                    showStatus('API connectivity issue - some features may be limited', 'warning');
                }
                return false;
            }
        }
       
        // Fetch gamut boundary points from the API
        async function fetchGamutBoundary(profile, resolution = 25, currentLab = null) {
            const apiUrl = `${getApiBaseUrl()}/gamut-boundary`;
           
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        profile: profile,
                        resolution: resolution,
                        currentLab: currentLab
                    })
                });
               
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
               
                const data = await response.json();
                return data.boundaryPoints; // [[L,a,b], [L,a,b], ...]
               
            } catch (error) {
                console.warn('Gamut boundary API failed, using mock data:', error);
               
                // Fallback: Generate mock gamut boundary data for testing
                return generateMockGamutBoundary(resolution);
            }
        }

        // Generate mock gamut boundary data for testing when API is unavailable
        function generateMockGamutBoundary(resolution = 25) {
            const points = [];
            const step = 100 / resolution;
           
            // Create a rough cylindrical gamut shape in Lab space
            for (let L = 0; L <= 100; L += step) {
                for (let angle = 0; angle < 360; angle += 15) {
                    const rad = angle * Math.PI / 180;
                   
                    // Vary radius based on lightness to create gamut-like shape
                    let radius;
                    if (L < 20 || L > 90) {
                        radius = 20; // Smaller gamut at extremes
                    } else {
                        radius = 60; // Larger gamut in middle lightness
                    }
                   
                    const a = radius * Math.cos(rad);
                    const b = radius * Math.sin(rad);
                   
                    points.push([L, a, b]);
                }
            }
           
            console.log(`Generated ${points.length} mock gamut boundary points`);
            return points;
        }

        (function init() {
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
                return;
            }

            /* ─────────────────────
               Hamburger Menu
               ───────────────────── */
            const hamburgerIcon = document.getElementById('cmw-hamburger-icon');
            const hamburgerDropdown = document.getElementById('cmw-hamburger-dropdown');
            
            hamburgerIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                const isActive = hamburgerDropdown.classList.contains('active');
                
                if (isActive) {
                    hamburgerDropdown.classList.remove('active');
                    hamburgerIcon.classList.remove('active');
                } else {
                    hamburgerDropdown.classList.add('active');
                    hamburgerIcon.classList.add('active');
                }
            });
            
            // Handle menu item clicks
            document.querySelectorAll('.cmw-hamburger-menu-item').forEach(item => {
                if (!item.classList.contains('divider')) {
                    item.addEventListener('click', () => {
                        const action = item.dataset.action;
                        console.log('Menu action:', action);
                        
                        // Close menu after clicking
                        hamburgerDropdown.classList.remove('active');
                        hamburgerIcon.classList.remove('active');
                        
                        if (action === 'preferences') {
                            openPreferencesModal();
                        } else {
                            // Placeholder for future functionality
                            alert(`${item.textContent.trim()} - Coming soon!`);
                        }
                    });
                }
            });
            
            // Close hamburger menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!hamburgerIcon.contains(e.target) && 
                    !hamburgerDropdown.contains(e.target)) {
                    hamburgerDropdown.classList.remove('active');
                    hamburgerIcon.classList.remove('active');
                }
            });
            
            /* ─────────────────────
               User Preferences
               ───────────────────── */
            
            // User preferences state (loaded from localStorage)
            const userPreferences = {
                showClosestLibraries: false,
                selectedLibraries: []
            };
            
            // Load preferences from localStorage
            function loadUserPreferences() {
                const saved = localStorage.getItem('cmw-user-preferences');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        userPreferences.showClosestLibraries = parsed.showClosestLibraries || false;
                        userPreferences.selectedLibraries = parsed.selectedLibraries || [];
                    } catch (e) {
                        console.error('Error loading preferences:', e);
                    }
                }
            }
            
            // Save preferences to localStorage
            function saveUserPreferences() {
                try {
                    localStorage.setItem('cmw-user-preferences', JSON.stringify(userPreferences));
                    console.log('✓ Preferences saved', userPreferences);
                } catch (e) {
                    console.error('Error saving preferences:', e);
                }
            }
            
            // Open preferences modal
            function openPreferencesModal() {
                const modal = document.getElementById('cmw-preferences-modal');
                const showClosestCheckbox = document.getElementById('cmw-pref-show-closest');
                const librarySelection = document.getElementById('cmw-pref-library-selection');
                
                // Set checkbox state
                showClosestCheckbox.checked = userPreferences.showClosestLibraries;
                librarySelection.style.display = userPreferences.showClosestLibraries ? 'block' : 'none';
                
                // Populate library checkboxes
                populatePreferenceLibraries();
                
                // Show modal
                modal.style.display = 'flex';
            }
            
            // Close preferences modal
            function closePreferencesModal() {
                const modal = document.getElementById('cmw-preferences-modal');
                modal.style.display = 'none';
            }
            
            // Populate library checkboxes in preferences (hidden, for tracking)
            function populatePreferenceLibraries() {
                const container = document.getElementById('cmw-pref-libraries-container');
                container.innerHTML = '';
                
                // Combine public libraries and custom libraries
                const allLibraries = [];
                
                // Add public libraries
                if (libraryManifest && libraryManifest.length > 0) {
                    libraryManifest.forEach(lib => {
                        allLibraries.push({ id: lib.id, name: lib.name, type: 'public' });
                    });
                }
                
                // Add custom libraries
                const customLibs = Object.keys(libs).filter(libId => {
                    return !libraryManifest.some(ml => ml.id === libId);
                });
                
                customLibs.forEach(libId => {
                    if (libNames[libId]) {
                        allLibraries.push({ id: libId, name: libNames[libId], type: 'custom' });
                    }
                });
                
                allLibraries.forEach(lib => {
                    // Default to NONE selected (empty array means none, not all)
                    // Only check if explicitly in selectedLibraries array
                    const checked = userPreferences.selectedLibraries.length > 0 && userPreferences.selectedLibraries.includes(lib.id);
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `cmw-pref-lib-${lib.id}`;
                    checkbox.value = lib.id;
                    checkbox.checked = checked;
                    checkbox.dataset.libraryName = lib.name;
                    checkbox.className = 'cmw-pref-library-checkbox';
                    
                    checkbox.addEventListener('change', updatePrefActiveLibrariesDisplay);
                    
                    container.appendChild(checkbox);
                });
                
                // Initialize the display
                updatePrefActiveLibrariesDisplay();
                initPrefLibrarySearch();
            }
            
            // Update the active libraries display (chips)
            function updatePrefActiveLibrariesDisplay() {
                const activeLibrariesDiv = document.getElementById('cmw-pref-active-libraries');
                const checkboxes = Array.from(document.querySelectorAll('#cmw-pref-libraries-container input[type="checkbox"]'));
                const checkedBoxes = checkboxes.filter(cb => cb.checked);
                
                activeLibrariesDiv.innerHTML = '';
                
                if (checkedBoxes.length === 0) {
                    // No libraries selected
                    const noneSpan = document.createElement('span');
                    noneSpan.style.cssText = 'color: #9ca3af; font-size: 13px; font-style: italic;';
                    noneSpan.textContent = 'No libraries selected (closest match disabled)';
                    activeLibrariesDiv.appendChild(noneSpan);
                } else if (checkedBoxes.length === checkboxes.length) {
                    // All libraries active
                    const allActiveSpan = document.createElement('span');
                    allActiveSpan.style.cssText = 'color: #10b981; font-size: 13px; display: flex; align-items: center; gap: 4px;';
                    allActiveSpan.innerHTML = `
                        <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                        All libraries active
                    `;
                    activeLibrariesDiv.appendChild(allActiveSpan);
                } else {
                    // Show specific active libraries
                    checkedBoxes.forEach(checkbox => {
                        const chip = document.createElement('div');
                        chip.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; background: #0065a3; color: white; padding: 6px 12px; border-radius: 16px; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s ease;';
                        chip.innerHTML = `
                            ${checkbox.dataset.libraryName}
                            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round;">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        `;
                        chip.addEventListener('click', () => {
                            checkbox.checked = false;
                            checkbox.dispatchEvent(new Event('change'));
                        });
                        activeLibrariesDiv.appendChild(chip);
                    });
                }
            }
            
            // Initialize preference library search
            function initPrefLibrarySearch() {
                const searchInput = document.getElementById('cmw-pref-library-search');
                const suggestionsDiv = document.getElementById('cmw-pref-library-suggestions');
                const checkboxes = Array.from(document.querySelectorAll('#cmw-pref-libraries-container input[type="checkbox"]'));
                
                let currentMatches = [];
                let highlightedIndex = -1;
                let suggestionsVisible = false;
                
                function showSuggestions(inputText, forceShowAll = false) {
                    const query = inputText.toLowerCase().trim();
                    const showAll = forceShowAll || query === '*' || query.startsWith('* ');
                    
                    console.log('🔍 Pref showSuggestions:', { inputText, query, forceShowAll, showAll, checkboxCount: checkboxes.length });
                    
                    if (query === '' && !forceShowAll) {
                        suggestionsDiv.style.display = 'none';
                        suggestionsVisible = false;
                        currentMatches = [];
                        highlightedIndex = -1;
                        return;
                    }
                    
                    const filterText = query.startsWith('* ') ? query.substring(2).trim() : '';
                    
                    if (showAll) {
                        // Show all libraries (optionally filtered)
                        if (filterText === '') {
                            // Show ALL libraries
                            currentMatches = checkboxes;
                            console.log('⭐ Showing ALL libraries:', currentMatches.length);
                        } else {
                            // Show all, but filter by text after asterisk
                            currentMatches = checkboxes.filter(cb => 
                                cb.dataset.libraryName.toLowerCase().includes(filterText)
                            );
                            console.log('⭐ Showing filtered libraries:', currentMatches.length, 'filter:', filterText);
                        }
                    } else {
                        // Normal search
                        currentMatches = checkboxes.filter(cb => 
                            cb.dataset.libraryName.toLowerCase().includes(query)
                        );
                        console.log('🔎 Normal search results:', currentMatches.length);
                    }
                    
                    if (currentMatches.length === 0) {
                        suggestionsDiv.style.display = 'none';
                        suggestionsVisible = false;
                        return;
                    }
                    
                    suggestionsDiv.innerHTML = '';
                    currentMatches.forEach((checkbox, index) => {
                        const div = document.createElement('div');
                        div.style.cssText = 'padding: 10px 16px; cursor: pointer; transition: background 0.2s; display: flex; justify-content: space-between; align-items: center;';
                        div.innerHTML = `
                            <span style="color: #374151;">${checkbox.dataset.libraryName}</span>
                            ${checkbox.checked ? '<span style="color: #10b981; font-size: 12px;">✓ Active</span>' : '<span style="color: #6b7280; font-size: 12px;">Inactive</span>'}
                        `;
                        div.addEventListener('mouseover', () => {
                            highlightedIndex = index;
                            updateSuggestionHighlight();
                        });
                        div.addEventListener('click', () => {
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change'));
                            searchInput.value = '';
                            suggestionsDiv.style.display = 'none';
                            suggestionsVisible = false;
                        });
                        suggestionsDiv.appendChild(div);
                    });
                    
                    highlightedIndex = -1;
                    suggestionsDiv.style.display = 'block';
                    suggestionsVisible = true;
                }
                
                searchInput.addEventListener('input', (e) => {
                    console.log('📝 Pref input event:', e.target.value);
                    showSuggestions(e.target.value, false);
                });
                
                searchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        
                        if (!suggestionsVisible || currentMatches.length === 0) {
                            // Show all libraries when dropdown is closed
                            showSuggestions(e.target.value, true);
                        } else {
                            // Navigate down in open dropdown
                            highlightedIndex = (highlightedIndex + 1) % currentMatches.length;
                            updateSuggestionHighlight();
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        
                        if (suggestionsVisible && currentMatches.length > 0) {
                            if (highlightedIndex <= 0) {
                                // At top - close dropdown
                                suggestionsDiv.style.display = 'none';
                                suggestionsVisible = false;
                                highlightedIndex = -1;
                                currentMatches = [];
                            } else {
                                // Navigate up
                                highlightedIndex = (highlightedIndex - 1 + currentMatches.length) % currentMatches.length;
                                updateSuggestionHighlight();
                            }
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        if (highlightedIndex >= 0 && highlightedIndex < currentMatches.length) {
                            const checkbox = currentMatches[highlightedIndex];
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change'));
                            searchInput.value = '';
                            suggestionsDiv.style.display = 'none';
                            suggestionsVisible = false;
                        }
                    } else if (e.key === 'Escape') {
                        suggestionsDiv.style.display = 'none';
                        suggestionsVisible = false;
                        searchInput.value = '';
                    }
                });
                
                function updateSuggestionHighlight() {
                    const items = suggestionsDiv.children;
                    Array.from(items).forEach((item, index) => {
                        if (index === highlightedIndex) {
                            item.style.background = '#f3f4f6';
                        } else {
                            item.style.background = 'white';
                        }
                    });
                }
                
                // Close suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!searchInput.contains(e.target) && !suggestionsDiv.contains(e.target)) {
                        suggestionsDiv.style.display = 'none';
                        suggestionsVisible = false;
                    }
                });
            }
            
            // Toggle library selection visibility
            document.getElementById('cmw-pref-show-closest').addEventListener('change', (e) => {
                const librarySelection = document.getElementById('cmw-pref-library-selection');
                librarySelection.style.display = e.target.checked ? 'block' : 'none';
            });
            
            // Close button
            document.getElementById('cmw-preferences-close').addEventListener('click', closePreferencesModal);
            
            // Save preferences button
            document.getElementById('cmw-preferences-save').addEventListener('click', () => {
                const showClosestCheckbox = document.getElementById('cmw-pref-show-closest');
                userPreferences.showClosestLibraries = showClosestCheckbox.checked;
                
                // Get selected libraries from hidden container
                const checkboxes = document.querySelectorAll('#cmw-pref-libraries-container input[type="checkbox"]');
                const allCheckboxes = Array.from(checkboxes);
                const checkedCheckboxes = allCheckboxes.filter(cb => cb.checked);
                
                // Save the exact selection
                // Empty array = no libraries (closest match disabled)
                // Array with IDs = only those libraries
                // All checked = treated as all active
                userPreferences.selectedLibraries = checkedCheckboxes.map(cb => cb.value);
                
                saveUserPreferences();
                closePreferencesModal();
                
                // Show confirmation
                alert('Preferences saved successfully! Your settings will persist across sessions.');
            });
            
            // Close modal when clicking outside
            document.getElementById('cmw-preferences-modal').addEventListener('click', (e) => {
                if (e.target.id === 'cmw-preferences-modal') {
                    closePreferencesModal();
                }
            });
            
            // Load preferences on page load
            loadUserPreferences();
            
            // Populate libraries after manifest loads
            setTimeout(() => {
                if (libraryManifest && libraryManifest.length > 0) {
                    console.log('✓ Libraries available for preferences');
                }
            }, 2000);
            
            /* ─────────────────────
               Header Search Icon
               ───────────────────── */
            const headerSearchIcon = document.getElementById('cmw-header-search-icon');
            const headerSearchContainer = document.getElementById('cmw-header-search-container');
            const headerSearchInput = document.getElementById('cmw-header-search-input');
            
            headerSearchIcon.addEventListener('click', () => {
                const isActive = headerSearchContainer.classList.contains('active');
                
                if (isActive) {
                    headerSearchContainer.classList.remove('active');
                    headerSearchIcon.classList.remove('active');
                } else {
                    headerSearchContainer.classList.add('active');
                    headerSearchIcon.classList.add('active');
                    setTimeout(() => {
                        headerSearchInput.focus();
                    }, 300);
                }
            });
            
            // Close search input when clicking outside
            document.addEventListener('click', (e) => {
                if (!headerSearchIcon.contains(e.target) && 
                    !headerSearchContainer.contains(e.target)) {
                    headerSearchContainer.classList.remove('active');
                    headerSearchIcon.classList.remove('active');
                }
            });
            
            // Handle search input (placeholder for now - can implement search functionality later)
            headerSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const searchValue = headerSearchInput.value.trim();
                    if (searchValue) {
                        // Set the main color search to use the header search value
                        const nameInput = document.getElementById('cmw-name-input');
                        const searchTypeSelect = document.getElementById('cmw-search-type-select');
                        
                        searchTypeSelect.value = 'name';
                        nameInput.value = searchValue;
                        nameInput.dispatchEvent(new Event('input', { bubbles: true }));
                        nameInput.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        // Scroll to search section
                        document.getElementById('cmw-color-search-toggle').scrollIntoView({ behavior: 'smooth', block: 'start' });
                        
                        // Expand Color Search if collapsed
                        const colorSearchToggle = document.getElementById('cmw-color-search-toggle');
                        const colorSearchContent = document.getElementById('cmw-color-search-content');
                        if (colorSearchToggle.classList.contains('collapsed')) {
                            colorSearchToggle.classList.remove('collapsed');
                            colorSearchContent.classList.remove('collapsed');
                        }
                        
                        // Close the header search
                        headerSearchContainer.classList.remove('active');
                        headerSearchIcon.classList.remove('active');
                        headerSearchInput.value = '';
                    }
                }
            });

            const nameInput = document.getElementById('cmw-name-input');
            const searchBtn = document.getElementById('cmw-search-btn');
            const searchTypeSelect = document.getElementById('cmw-search-type-select');
            const labInputs = ['cmw-lab-l', 'cmw-lab-a', 'cmw-lab-b'].map(id => document.getElementById(id));
            const cmykInputs = ['cmw-cmyk-c', 'cmw-cmyk-m', 'cmw-cmyk-y', 'cmw-cmyk-k'].map(id => document.getElementById(id));
            const rgbInputs = ['cmw-rgb-r', 'cmw-rgb-g', 'cmw-rgb-b'].map(id => document.getElementById(id));
            const harmonyTypeSelect = document.getElementById('cmw-harmony-type');
            const harmonyToggle = document.getElementById('cmw-harmony-toggle');

            setupInfiniteScroll();
            
            // Initialize with dynamic library loading
            showLoading(true);
            initializeLibraries()
                .then(() => {
                    showLoading(false);
                    libsLoaded = true;
                    const totalColors = Object.values(libs).reduce((sum, lib) => sum + (lib?.length || 0), 0);
                    showStatus(`Color libraries loaded successfully! ${totalColors} colors available.`);
                    console.log('All library fetches completed');
                   
                    // Load custom libraries AFTER container is created
                    loadCustomLibraries();
                    
                    // Update library selector to include public libraries (call after manifest is loaded)
                    updateLibrarySelector();
                    
                    // Add event delegation for custom library toggles (Amazon filter reset)
                    const customLibrariesContainer = document.getElementById('cmw-custom-libraries-container');
                    if (customLibrariesContainer) {
                        customLibrariesContainer.addEventListener('change', (e) => {
                            if (e.target.type === 'checkbox') {
                                resetAmazonFilter();
                            }
                        });
                    }
                   
                    // Update library counts after loading
                    initializeLibraryCounts();
                    
                    // Check API connectivity after libraries are loaded
                    setTimeout(() => {
                        checkApiConnectivity();
                    }, 1000);
                })
                .catch((error) => {
                    showLoading(false);
                    console.error('Library initialization failed:', error);
                    showStatus('Failed to load some color libraries. Functionality may be limited.', 'error');
                    initializeLibraryCounts(); // Still initialize counts even on error
                });
           
            // Initialize library search input references
            const librarySearchInput = document.getElementById('cmw-library-search');
            const activeLibrariesDisplay = document.getElementById('cmw-active-libraries-display');
            const librarySuggestions = document.getElementById('cmw-library-suggestions');
            let suggestionsVisible = false;
            let userHasSelectedSpecificLibraries = false; // Track if user switched to specific library mode
            let currentMatches = []; // Track current matching libraries for Enter key
            let highlightedIndex = -1; // Track which suggestion is highlighted (-1 = none)
            let inactivityTimer = null; // Timer for auto-closing dropdown after 6s of ANY inactivity (highlighted or not)
            
            console.log('🔍 Library search elements:', {
                input: !!librarySearchInput,
                display: !!activeLibrariesDisplay,
                suggestions: !!librarySuggestions
            });
            
            function updateActiveLibrariesDisplay() {
                const checkboxes = document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]');
                const activeLibs = Array.from(checkboxes).filter(cb => cb.checked);
                
                console.log('📊 Updating display - Total checkboxes:', checkboxes.length, 'Active:', activeLibs.length);
                
                if (activeLibs.length === 0) {
                    activeLibrariesDisplay.innerHTML = `
                        <span style="color: #ef4444; font-size: 13px; display: flex; align-items: center; gap: 4px;">
                            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="12" y1="8" x2="12" y2="12"></line>
                                <line x1="12" y1="16" x2="12.01" y2="16"></line>
                            </svg>
                            No libraries selected - type library name to add
                        </span>
                    `;
                } else if (activeLibs.length === checkboxes.length) {
                    activeLibrariesDisplay.innerHTML = `
                        <span style="color: #10b981; font-size: 13px; display: flex; align-items: center; gap: 4px;">
                            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            All libraries active
                        </span>
                    `;
                } else {
                    activeLibrariesDisplay.innerHTML = activeLibs.map(cb => {
                        const libName = cb.nextElementSibling.textContent.split('(')[0].trim();
                        return `
                            <div style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: #0065a3; color: white; border-radius: 16px; font-size: 13px; cursor: pointer;" data-lib-id="${cb.value}" class="cmw-active-lib-chip">
                                <span>${libName}</span>
                                <span style="font-weight: bold; font-size: 16px; line-height: 1;">×</span>
                            </div>
                        `;
                    }).join('');
                    
                    console.log('✅ Created', activeLibs.length, 'pill badges');
                    
                    // Add click handlers to remove chips
                    activeLibrariesDisplay.querySelectorAll('.cmw-active-lib-chip').forEach(chip => {
                        chip.addEventListener('click', () => {
                            const libId = chip.dataset.libId;
                            const checkbox = document.querySelector(`#cmw-public-libraries-container input[value="${libId}"]`);
                            if (checkbox) {
                                // Check if this will be the last library BEFORE unchecking
                                const currentChecked = document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]:checked');
                                const isLastLibrary = currentChecked.length === 1;
                                
                                // Uncheck the library
                                checkbox.checked = false;
                                
                                // If this was the last library, revert to "all libraries" mode
                                if (isLastLibrary) {
                                    console.log('🔄 Last library removed - reverting to "all libraries" mode');
                                    // Check all libraries again (including the one we just unchecked)
                                    const allCheckboxes = document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]');
                                    allCheckboxes.forEach(cb => cb.checked = true);
                                    // Reset the flag so user can select specific libraries again
                                    userHasSelectedSpecificLibraries = false;
                                    // Reset any filters
                                    resetAmazonFilter();
                                    console.log('✓ All libraries re-enabled, flag reset, filters reset');
                                }
                                
                                // Dispatch event and update display once
                                checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                                updateActiveLibrariesDisplay();
                            }
                        });
                    });
                }
            }
            
            function processLibrarySearch(searchText, addMode = true) {
                const text = searchText.toLowerCase().trim();
                if (!text) {
                    return; // Don't do anything with empty input
                }
                
                console.log('Processing library search:', text, 'addMode:', addMode, 'userHasSelectedSpecificLibraries:', userHasSelectedSpecificLibraries);
                
                // Split by spaces or commas
                const keywords = text.split(/[\s,]+/).filter(k => k.length > 0);
                
                // Get all library checkboxes
                const checkboxes = document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]');
                console.log('Found checkboxes:', checkboxes.length);
                
                // First time using search: uncheck all and switch to specific mode
                // Subsequent times: keep additive behavior
                if (!userHasSelectedSpecificLibraries) {
                    console.log('🔄 First time selecting libraries - switching to specific mode');
                    checkboxes.forEach(cb => cb.checked = false);
                    userHasSelectedSpecificLibraries = true;
                } else if (!addMode) {
                    // Explicit replace mode (not first time, but user wants to replace)
                    checkboxes.forEach(cb => cb.checked = false);
                }
                
                // Check matching libraries (additive)
                let matchCount = 0;
                keywords.forEach(keyword => {
                    checkboxes.forEach(cb => {
                        const label = cb.nextElementSibling.textContent.toLowerCase();
                        const libId = cb.value.toLowerCase();
                        
                        // Match against library ID or name
                        if (libId.includes(keyword) || label.includes(keyword)) {
                            if (!cb.checked) {
                                cb.checked = true;
                                cb.dispatchEvent(new Event('change', { bubbles: true }));
                                matchCount++;
                                console.log('Checked library:', cb.value, label);
                            }
                        }
                    });
                });
                
                console.log('Matched libraries:', matchCount);
                updateActiveLibrariesDisplay();
                resetAmazonFilter();
            }
            
            // Predictive dropdown functionality
            function showLibrarySuggestions(inputText, forceShowAll = false) {
                const text = inputText.toLowerCase().trim();
                console.log('🔎 showLibrarySuggestions called with:', text, 'forceShowAll:', forceShowAll);
                
                // Check if user wants to see all libraries (just * or forced by down arrow)
                const showAllLibraries = forceShowAll || text === '*' || text.startsWith('* ');
                
                // Don't show suggestions for empty input (unless forced)
                if (text.length === 0 && !forceShowAll) {
                    librarySuggestions.style.display = 'none';
                    suggestionsVisible = false;
                    currentMatches = [];
                    highlightedIndex = -1;
                    return;
                }
                
                // Get all library checkboxes
                const checkboxes = document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]');
                console.log('📦 Found', checkboxes.length, 'checkboxes to search');
                const matches = [];
                
                if (showAllLibraries) {
                    console.log('⭐ Show all mode - displaying all libraries');
                    
                    // If user typed "* something", filter by "something"
                    const filterText = text.startsWith('* ') ? text.substring(2).trim() : '';
                    
                    checkboxes.forEach(cb => {
                        const label = cb.nextElementSibling?.textContent;
                        if (!label) return;
                        
                        const libId = cb.value.toLowerCase();
                        const labelLower = label.toLowerCase();
                        
                        // If there's filter text after *, apply it
                        if (filterText) {
                            if (libId.includes(filterText) || labelLower.includes(filterText)) {
                                matches.push({
                                    id: cb.value,
                                    name: label,
                                    score: libId.startsWith(filterText) || labelLower.startsWith(filterText) ? 1 : 0.5
                                });
                            }
                        } else {
                            // No filter, show all
                            matches.push({
                                id: cb.value,
                                name: label,
                                score: 1
                            });
                        }
                    });
                } else if (text.length === 1 && text !== '*') {
                    // 1 letter: Only show libraries that START with that letter
                    console.log('🔤 Single letter - showing only starts-with matches');
                    checkboxes.forEach(cb => {
                        const label = cb.nextElementSibling?.textContent;
                        if (!label) return;
                        
                        const libId = cb.value.toLowerCase();
                        const labelLower = label.toLowerCase();
                        
                        // Only match if library name STARTS with the letter
                        if (libId.startsWith(text) || labelLower.startsWith(text)) {
                            matches.push({
                                id: cb.value,
                                name: label,
                                score: 1
                            });
                        }
                    });
                } else {
                    // 2+ letters: Fuzzy matching (contains anywhere)
                    console.log('🔍 Fuzzy matching (2+ letters)');
                    checkboxes.forEach(cb => {
                        const label = cb.nextElementSibling?.textContent;
                        if (!label) return;
                        
                        const libId = cb.value.toLowerCase();
                        const labelLower = label.toLowerCase();
                        
                        // Fuzzy match: check if library name contains the input
                        if (libId.includes(text) || labelLower.includes(text)) {
                            matches.push({
                                id: cb.value,
                                name: label,
                                score: libId.startsWith(text) || labelLower.startsWith(text) ? 1 : 0.5
                            });
                        }
                    });
                }
                
                console.log('🎯 Found', matches.length, 'matching libraries');
                
                // Sort by score (prioritize matches at the start), then alphabetically
                matches.sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    return a.name.localeCompare(b.name); // Alphabetical for same score
                });
                
                if (matches.length === 0) {
                    librarySuggestions.style.display = 'none';
                    suggestionsVisible = false;
                    currentMatches = []; // Clear matches
                    highlightedIndex = -1; // Reset highlight
                    return;
                }
                
                // Build suggestion items
                let dropdownHTML = '';
                
                // Add header for special keyword views
                if (showAllLibraries) {
                    dropdownHTML = `
                        <div style="padding: 8px 16px; background: #f9fafb; border-bottom: 2px solid #e2e8f0; font-weight: 600; color: #374151; font-size: 12px; text-align: center;">
                            All Available Libraries (${matches.length})
                        </div>
                    `;
                }
                
                // Show more results for *List/*All (20 instead of 10)
                const maxResults = showAllLibraries ? 20 : 10;
                const visibleMatches = matches.slice(0, maxResults);
                
                dropdownHTML += visibleMatches.map(match => `
                    <div class="cmw-library-suggestion-item" data-lib-id="${match.id}" style="padding: 10px 16px; cursor: pointer; border-bottom: 1px solid #f3f4f6; transition: background 0.15s;">
                        ${match.name}
                    </div>
                `).join('');
                
                // Add "showing X of Y" footer if there are more results
                if (matches.length > maxResults) {
                    dropdownHTML += `
                        <div style="padding: 8px 16px; background: #f9fafb; font-size: 11px; color: #6b7280; text-align: center; border-top: 1px solid #e2e8f0;">
                            Showing ${maxResults} of ${matches.length} libraries - type more to narrow down
                        </div>
                    `;
                }
                
                librarySuggestions.innerHTML = dropdownHTML;
                
                // Store only visible matches for navigation (not all matches)
                currentMatches = visibleMatches;
                
                console.log('✨ Built dropdown with', Math.min(maxResults, matches.length), 'suggestions');
                
                // Reset highlighted index when showing new suggestions
                highlightedIndex = -1;
                
                // Add hover styles and click handlers
                const suggestionItems = librarySuggestions.querySelectorAll('.cmw-library-suggestion-item');
                suggestionItems.forEach((item, index) => {
                    item.addEventListener('mouseenter', () => {
                        highlightedIndex = index;
                        updateHighlighting(); // This clears the timer
                    });
                    item.addEventListener('mouseleave', () => {
                        highlightedIndex = -1;
                        updateHighlighting(); // This resets the 6s timer
                    });
                    item.addEventListener('click', () => {
                        console.log('🖱️ Clicked suggestion:', item.dataset.libId);
                        clearInactivityTimer(); // Clear timer on selection
                        selectLibraryFromSuggestion(item.dataset.libId);
                    });
                });
                
                // Adjust max-height for *List/*All view (taller dropdown)
                if (showAllLibraries) {
                    librarySuggestions.style.maxHeight = '300px';
                } else {
                    librarySuggestions.style.maxHeight = '200px';
                }
                
                librarySuggestions.style.display = 'block';
                suggestionsVisible = true;
                
                // Start inactivity timer (6s countdown)
                resetInactivityTimer();
            }
            
            function updateHighlighting() {
                const items = librarySuggestions.querySelectorAll('.cmw-library-suggestion-item');
                items.forEach((item, index) => {
                    if (index === highlightedIndex) {
                        item.style.background = '#dbeafe'; // Light blue highlight
                        item.style.borderLeft = '3px solid #0065a3'; // Blue left border
                        item.style.paddingLeft = '13px'; // Adjust for border (16px - 3px)
                        
                        // Scroll into view if needed
                        item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    } else {
                        item.style.background = 'white';
                        item.style.borderLeft = 'none';
                        item.style.paddingLeft = '16px';
                    }
                });
                
                // Reset 6s inactivity timer - user is interacting
                resetInactivityTimer();
            }
            
            function startInactivityTimer() {
                // Clear any existing timer
                clearInactivityTimer();
                
                // Start 6-second countdown (closes dropdown on ANY inactivity)
                inactivityTimer = setTimeout(() => {
                    console.log('⏰ 6s inactivity - auto-closing dropdown');
                    librarySuggestions.style.display = 'none';
                    suggestionsVisible = false;
                    currentMatches = [];
                    highlightedIndex = -1;
                    inactivityTimer = null;
                }, 6000); // 6 seconds
            }
            
            function clearInactivityTimer() {
                if (inactivityTimer) {
                    clearTimeout(inactivityTimer);
                    inactivityTimer = null;
                }
            }
            
            function resetInactivityTimer() {
                // Start timer if dropdown is visible (regardless of highlight state)
                if (suggestionsVisible) {
                    startInactivityTimer();
                }
            }
            
            function selectLibraryFromSuggestion(libId) {
                console.log('Selecting library from suggestion:', libId);
                
                // Clear inactivity timer
                clearInactivityTimer();
                
                // First time using search: uncheck all libraries and switch to specific mode
                if (!userHasSelectedSpecificLibraries) {
                    console.log('🔄 First time selecting libraries - switching to specific mode');
                    const allCheckboxes = document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]');
                    allCheckboxes.forEach(cb => cb.checked = false);
                    userHasSelectedSpecificLibraries = true;
                }
                
                // Check the library checkbox
                const checkbox = document.querySelector(`#cmw-public-libraries-container input[value="${libId}"]`);
                console.log('Found checkbox:', checkbox);
                
                if (checkbox) {
                    checkbox.checked = true;
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                    console.log('Checkbox checked and event dispatched');
                    updateActiveLibrariesDisplay();
                    resetAmazonFilter();
                }
                
                // Clear input and hide suggestions
                librarySearchInput.value = '';
                librarySuggestions.style.display = 'none';
                suggestionsVisible = false;
                currentMatches = []; // Clear matches
                highlightedIndex = -1; // Reset highlight
                librarySearchInput.focus();
            }
            
            // Setup event listeners (only if elements exist)
            if (librarySearchInput && librarySuggestions) {
                console.log('✅ Setting up library search event listeners');
                
                // Handle input events
                librarySearchInput.addEventListener('input', (e) => {
                    console.log('📝 Input event:', e.target.value);
                    clearInactivityTimer(); // User is typing - clear timer
                    showLibrarySuggestions(e.target.value, false);
                });
                
                // Handle arrow keys for navigation
                librarySearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault(); // Prevent cursor from moving
                        
                        if (!suggestionsVisible || currentMatches.length === 0) {
                            // Dropdown not visible or empty - show all libraries
                            console.log('⬇️ Down arrow pressed - showing all libraries');
                            showLibrarySuggestions(e.target.value, true); // Force show all
                        } else {
                            // Dropdown is visible - navigate down
                            console.log('⬇️ Navigate down in dropdown');
                            highlightedIndex = Math.min(highlightedIndex + 1, currentMatches.length - 1);
                            updateHighlighting();
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault(); // Prevent cursor from moving
                        
                        if (suggestionsVisible && currentMatches.length > 0) {
                            // If already at top (index 0 or -1), close the dropdown
                            if (highlightedIndex <= 0) {
                                console.log('⬆️ At top - closing dropdown');
                                clearInactivityTimer(); // Clear timer when closing
                                librarySuggestions.style.display = 'none';
                                suggestionsVisible = false;
                                highlightedIndex = -1;
                                currentMatches = [];
                            } else {
                                // Navigate up
                                console.log('⬆️ Navigate up in dropdown');
                                highlightedIndex--;
                                updateHighlighting(); // This resets the timer
                            }
                        }
                    }
                });
                
                librarySearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        console.log('⏎ Enter pressed with value:', e.target.value, 'Matches:', currentMatches.length, 'Highlighted:', highlightedIndex);
                        e.preventDefault();
                        
                        const text = e.target.value.trim();
                        
                        // If input is just *, don't process it as a search
                        if (text === '*') {
                            console.log('⚠️ Just * - not processing as search');
                            return;
                        }
                        
                        // Priority 1: If there's a highlighted item (from keyboard/mouse navigation), select it
                        if (highlightedIndex >= 0 && highlightedIndex < currentMatches.length) {
                            console.log('✅ Highlighted item found - selecting:', currentMatches[highlightedIndex].name);
                            selectLibraryFromSuggestion(currentMatches[highlightedIndex].id);
                            return;
                        }
                        
                        // Priority 2: If there's exactly one match in the predictive dropdown, select it
                        if (currentMatches.length === 1) {
                            console.log('✅ Exactly 1 match found - auto-selecting:', currentMatches[0].name);
                            selectLibraryFromSuggestion(currentMatches[0].id);
                            return;
                        }
                        
                        // Priority 3: Multiple matches - user needs to narrow down or use arrows
                        if (currentMatches.length > 1) {
                            console.log('⚠️ Multiple matches found (' + currentMatches.length + ') - use arrows to select or type more');
                            // Flash the input border to indicate multiple matches
                            librarySearchInput.style.borderColor = '#f59e0b';
                            setTimeout(() => {
                                librarySearchInput.style.borderColor = '#e2e8f0';
                            }, 300);
                            return;
                        }
                        
                        // No matches in dropdown, process as direct search (for "* something" format)
                        let searchText = text;
                        if (text.startsWith('* ')) {
                            searchText = text.substring(2).trim();
                        }
                        
                        if (searchText) {
                            clearInactivityTimer(); // Clear timer when closing
                            processLibrarySearch(searchText, true); // Add mode
                            e.target.value = ''; // Clear input
                            librarySuggestions.style.display = 'none';
                            suggestionsVisible = false;
                            currentMatches = [];
                            highlightedIndex = -1;
                        }
                    }
                });
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!librarySearchInput.contains(e.target) && !librarySuggestions.contains(e.target)) {
                        clearInactivityTimer(); // Clear timer when closing
                        librarySuggestions.style.display = 'none';
                        suggestionsVisible = false;
                        currentMatches = []; // Clear matches when dropdown closes
                        highlightedIndex = -1; // Reset highlight
                    }
                });
            } else {
                console.error('❌ Library search elements not found!');
            }
            
            // Update display when checkboxes change (from any source)
            const publicLibsContainer = document.getElementById('cmw-public-libraries-container');
            if (publicLibsContainer) {
                publicLibsContainer.addEventListener('change', (e) => {
                    if (e.target.type === 'checkbox') {
                        console.log('🔄 Checkbox changed:', e.target.value, 'checked:', e.target.checked);
                        updateActiveLibrariesDisplay();
                    }
                });
            }
            
            // Add mousemove listener to dropdown to detect ANY mouse activity
            // This resets the 6s inactivity timer whenever mouse moves in dropdown area
            if (librarySuggestions) {
                librarySuggestions.addEventListener('mousemove', () => {
                    if (suggestionsVisible) {
                        resetInactivityTimer();
                    }
                });
            }
            
            // Initialize display after libraries load
            setTimeout(() => {
                const checkboxes = document.querySelectorAll('#cmw-public-libraries-container input[type="checkbox"]');
                console.log('🔧 Initialize: Found', checkboxes.length, 'library checkboxes');
                updateActiveLibrariesDisplay();
            }, 1500); // Increased timeout to ensure libraries are fully loaded
           
            // Initialize collapsible color search
            const colorSearchToggle = document.getElementById('cmw-color-search-toggle');
            const colorSearchContent = document.getElementById('cmw-color-search-content');
           
            colorSearchToggle.addEventListener('click', () => {
                const isCollapsed = colorSearchToggle.classList.contains('collapsed');
               
                if (isCollapsed) {
                    // Expand
                    colorSearchToggle.classList.remove('collapsed');
                    colorSearchContent.classList.remove('collapsed');
                } else {
                    // Collapse
                    colorSearchToggle.classList.add('collapsed');
                    colorSearchContent.classList.add('collapsed');
                }
            });
            
            // Initialize collapsible settings
            const settingsToggle = document.getElementById('cmw-settings-toggle');
            const settingsContent = document.getElementById('cmw-settings-content');
           
            settingsToggle.addEventListener('click', () => {
                const isCollapsed = settingsToggle.classList.contains('collapsed');
               
                if (isCollapsed) {
                    // Expand
                    settingsToggle.classList.remove('collapsed');
                    settingsContent.classList.remove('collapsed');
                } else {
                    // Collapse
                    settingsToggle.classList.add('collapsed');
                    settingsContent.classList.add('collapsed');
                }
            });
           
            searchBtn.addEventListener('click', performUnifiedSearch);

            // Amazon link filter event listener
            const amazonFilterCheckbox = document.getElementById('cmw-filter-amazon');
            if (amazonFilterCheckbox) {
                amazonFilterCheckbox.addEventListener('change', () => {
                    // Re-display results with filter applied
                    if (currentSearchResults && currentSearchResults.length > 0) {
                        const searchType = document.getElementById('cmw-search-type-select').value;
                        let profile = null;
                        if (searchType === 'cmyk') {
                            profile = document.getElementById('cmw-cmyk-profile').value;
                        }
                        displayResults(currentSearchResults, profile);
                    }
                });
            }
            
            // Reset Amazon filter when library toggles change
            function resetAmazonFilter() {
                if (amazonFilterCheckbox && amazonFilterCheckbox.checked) {
                    amazonFilterCheckbox.checked = false;
                    console.log('Amazon filter reset due to library toggle change');
                }
            }
            
            // Use event delegation for ALL library toggles (dynamically created + custom)
            // Public libraries are now created dynamically during initialization
            const publicLibrariesContainer = document.getElementById('cmw-public-libraries-container');
            if (publicLibrariesContainer) {
                publicLibrariesContainer.addEventListener('change', (e) => {
                    if (e.target.type === 'checkbox') {
                        resetAmazonFilter();
                    }
                });
            }

            searchTypeSelect.addEventListener('change', (e) => {
                document.getElementById('cmw-name-inputs').classList.remove('active');
                document.getElementById('cmw-lab-inputs').classList.remove('active');
                document.getElementById('cmw-cmyk-inputs').classList.remove('active');
                document.getElementById('cmw-rgb-inputs').classList.remove('active');
               
                const selectedType = e.target.value;
                if (selectedType) {
                    document.getElementById(`cmw-${selectedType}-inputs`).classList.add('active');
                }
               
                // Show/hide profile selector based on selection
                const profileSelector = document.getElementById('cmw-profile-selector');
                if (selectedType === 'cmyk') {
                    profileSelector.style.display = 'block';
                } else {
                    profileSelector.style.display = 'none';
                }
               
                if (selectedType !== 'name') {
                    nameInput.value = '';
                    const preview = document.getElementById('cmw-color-preview');
                    preview.classList.remove('selected');
                    preview.style.borderColor = '#e2e8f0'; // Keep default border for main swatch
                    delete preview.dataset.selectedL;
                    delete preview.dataset.selectedA;
                    delete preview.dataset.selectedB;
                    delete preview.dataset.selectedColor;
                    delete preview.dataset.selectedName;
                    delete preview.dataset.selectedLibrary;
                    updateSelectedColorInfo(null);
                }
                [...labInputs, ...cmykInputs, ...rgbInputs].forEach(input => {
                    if (input) input.value = '';
                });
               
                if (selectedType !== 'name') {
                    document.getElementById('cmw-name-suggestions').classList.remove('show');
                }
               
                updateConvertedColorInfo(null);
                // Clear CMYK display when switching input types
                const convertedCmykEl = document.getElementById('cmw-converted-cmyk');
                convertedCmykEl.style.display = 'none';
                updateColorPreview();
            });

            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') performUnifiedSearch();
            });

            let searchTimeout;
            nameInput.addEventListener('input', (e) => {
                updateColorPreview();
               
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const query = e.target.value.trim();
                    const selectedType = searchTypeSelect.value;
                   
                    if (query.length > 2 && libsLoaded && selectedType === 'name') {
                        showSuggestions(query);
                    } else {
                        document.getElementById('cmw-name-suggestions').classList.remove('show');
                    }
                }, 300);
            });

            [...labInputs, ...cmykInputs, ...rgbInputs].forEach(input => {
                if (input) {
                    input.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') performUnifiedSearch();
                    });
                    input.addEventListener('input', updateColorPreview);
                }
            });

            // Harmony controls
            harmonyToggle.addEventListener('change', () => {
                if (harmonyToggle.checked && currentAnalysisData) {
                    updateColorHarmonies(currentAnalysisData);
                } else {
                    document.getElementById('cmw-harmonies-section').style.display = 'none';
                }
            });

            harmonyTypeSelect.addEventListener('change', (e) => {
                currentHarmonyType = e.target.value;
                if (harmonyToggle.checked && currentAnalysisData) {
                    updateColorHarmonies(currentAnalysisData);
                }
            });

            /* ═══════════════════════════════════════════════════════════════
               PALETTE GENERATOR (Lab D50 → UI Palette Builder)
               ═══════════════════════════════════════════════════════════════ */
            
            // Search Results Harmony Tab switching
            const harmoniesTabHarmonies = document.getElementById('cmw-harmonies-tab-harmonies');
            const harmoniesTabPalette = document.getElementById('cmw-harmonies-tab-palette');
            const harmoniesContentHarmonies = document.getElementById('cmw-harmonies-tab-content-harmonies');
            const harmoniesContentPalette = document.getElementById('cmw-harmonies-tab-content-palette');
            
            function switchHarmoniesTab(tab) {
                const tabs = [harmoniesTabHarmonies, harmoniesTabPalette];
                const contents = [harmoniesContentHarmonies, harmoniesContentPalette];
                
                tabs.forEach((t, i) => {
                    if ((tab === 'harmonies' && i === 0) || (tab === 'palette' && i === 1)) {
                        t.classList.add('active');
                        t.style.borderBottomColor = '#0065a3';
                        t.style.color = '#0065a3';
                        contents[i].style.display = 'block';
                    } else {
                        t.classList.remove('active');
                        t.style.borderBottomColor = 'transparent';
                        t.style.color = '#6b7280';
                        contents[i].style.display = 'none';
                    }
                });
            }
            
            harmoniesTabHarmonies.addEventListener('click', () => switchHarmoniesTab('harmonies'));
            harmoniesTabPalette.addEventListener('click', () => switchHarmoniesTab('palette'));
            
            // Palette Generator - Generate multiple palette types from one base color
            
            // Helper: Convert Lab to LCh (more perceptually uniform for hue operations)
            function lab2lchPalette(lab) {
                const C = Math.sqrt(lab.a * lab.a + lab.b * lab.b);
                let h = Math.atan2(lab.b, lab.a) * (180 / Math.PI);
                if (h < 0) h += 360;
                return { L: lab.L, C: C, h: h };
            }
            
            // Helper: Convert LCh back to Lab
            function lch2labPalette(lch) {
                const hRad = lch.h * (Math.PI / 180);
                return {
                    L: lch.L,
                    a: lch.C * Math.cos(hRad),
                    b: lch.C * Math.sin(hRad)
                };
            }
            
            // Helper: Adjust Lab lightness (with exponential curve for better perception)
            function adjustLabLightness(lab, amount) {
                const newL = lab.L + amount;
                // Clamp and apply slight curve for better visual results
                const clampedL = Math.max(0, Math.min(100, newL));
                return {
                    L: clampedL,
                    a: lab.a,
                    b: lab.b
                };
            }
            
            // Helper: Rotate hue in LCh space (perceptually uniform)
            function rotateLabHue(lab, degrees) {
                const lch = lab2lchPalette(lab);
                lch.h = (lch.h + degrees) % 360;
                if (lch.h < 0) lch.h += 360;
                return lch2labPalette(lch);
            }
            
            // Helper: Adjust chroma (saturation) with limits
            function adjustChroma(lab, multiplier) {
                const lch = lab2lchPalette(lab);
                // Limit chroma to reasonable values for display
                lch.C = Math.min(lch.C * multiplier, 130);
                return lch2labPalette(lch);
            }
            
            // Helper: Desaturate Lab color (reduce chroma)
            function desaturateLabColor(lab, amount) {
                return adjustChroma(lab, 1 - amount);
            }
            
            // Helper: Create toned color (reduce both chroma and adjust lightness toward middle)
            function createTone(lab, desatAmount, lightnessTarget) {
                const lch = lab2lchPalette(lab);
                lch.C = lch.C * (1 - desatAmount);
                
                // Move lightness toward target (usually 50 for mid-tones)
                if (lightnessTarget !== undefined) {
                    const diff = lightnessTarget - lch.L;
                    lch.L = lch.L + diff * 0.3;
                }
                
                return lch2labPalette(lch);
            }
            
            // Helper: Ensure color stays in reasonable gamut
            function clampToGamut(lab) {
                const lch = lab2lchPalette(lab);
                
                // Reduce chroma if lightness is very high or very low
                if (lch.L > 90) {
                    lch.C = Math.min(lch.C, 40);
                } else if (lch.L < 20) {
                    lch.C = Math.min(lch.C, 50);
                }
                
                return lch2labPalette(lch);
            }
            
            // Generate palette variations - All 21 types
            function generatePaletteVariations(baseLab) {
                const palettes = [];
                
                // 1. Generic Gradient
                palettes.push({
                    name: 'Generic Gradient',
                    colors: [
                        baseLab,
                        rotateLabHue(adjustLabLightness(baseLab, -10), -25),
                        rotateLabHue(adjustLabLightness(baseLab, -18), -50),
                        rotateLabHue(adjustLabLightness(baseLab, -25), -80),
                        rotateLabHue(adjustLabLightness(baseLab, -32), -110),
                        adjustLabLightness(desaturateLabColor(baseLab, 0.6), -40)
                    ]
                });
                
                // 2. Matching Gradient
                palettes.push({
                    name: 'Matching Gradient',
                    colors: [
                        baseLab,
                        rotateLabHue(baseLab, -20),
                        rotateLabHue(baseLab, -45),
                        rotateLabHue(baseLab, -75),
                        rotateLabHue(baseLab, -100),
                        rotateLabHue(baseLab, -130)
                    ]
                });
                
                // 3. Spot Palette
                palettes.push({
                    name: 'Spot Palette',
                    colors: [
                        baseLab,
                        createTone(baseLab, 0.75, 50),
                        clampToGamut(desaturateLabColor(adjustLabLightness(baseLab, 38), 0.88)),
                        clampToGamut(rotateLabHue(adjustLabLightness(baseLab, -25), 180))
                    ]
                });
                
                // 4. Twisted Spot Palette
                palettes.push({
                    name: 'Twisted Spot Palette',
                    colors: [
                        baseLab,
                        rotateLabHue(adjustLabLightness(desaturateLabColor(baseLab, 0.4), -18), 180),
                        rotateLabHue(adjustLabLightness(desaturateLabColor(baseLab, 0.85), 40), 180),
                        rotateLabHue(adjustLabLightness(desaturateLabColor(baseLab, 0.6), 8), 165)
                    ]
                });
                
                // 5. Classy Palette
                palettes.push({
                    name: 'Classy Palette',
                    colors: [
                        baseLab,
                        createTone(baseLab, 0.72, 35),
                        createTone(baseLab, 0.62, 60),
                        clampToGamut(rotateLabHue(adjustLabLightness(baseLab, 18), 180)),
                        clampToGamut(rotateLabHue(adjustLabLightness(baseLab, 8), 165))
                    ]
                });
                
                // 6. Cube Palette
                palettes.push({
                    name: 'Cube Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(rotateLabHue(baseLab, 25), 5), 0.7),
                        desaturateLabColor(adjustLabLightness(rotateLabHue(baseLab, -10), 15), 0.55)
                    ]
                });
                
                // 7. Switch Palette
                palettes.push({
                    name: 'Switch Palette',
                    colors: [
                        baseLab,
                        adjustLabLightness(baseLab, -35),
                        rotateLabHue(adjustLabLightness(baseLab, -10), 175),
                        adjustLabLightness(desaturateLabColor(baseLab, 0.8), -55)
                    ]
                });
                
                // 8. Small Switch Palette
                palettes.push({
                    name: 'Small Switch Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(baseLab, 42), 0.88),
                        desaturateLabColor(adjustLabLightness(baseLab, -5), 0.65)
                    ]
                });
                
                // 9. Skip Gradient
                palettes.push({
                    name: 'Skip Gradient',
                    colors: [
                        baseLab,
                        rotateLabHue(adjustLabLightness(baseLab, 10), 50),
                        rotateLabHue(adjustLabLightness(baseLab, -5), 70),
                        rotateLabHue(adjustLabLightness(baseLab, -15), 85)
                    ]
                });
                
                // 10. Natural Palette
                const naturalGrey = createTone(baseLab, 0.68, 45);
                const naturalLight = clampToGamut(desaturateLabColor(adjustLabLightness(baseLab, 48), 0.92));
                const naturalDark = clampToGamut({ L: Math.max(15, baseLab.L - 58), a: baseLab.a * 0.15, b: baseLab.b * 0.15 });
                palettes.push({
                    name: 'Natural Palette',
                    colors: [baseLab, naturalGrey, naturalLight, naturalDark]
                });
                
                // 11. Matching Palette
                palettes.push({
                    name: 'Matching Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(baseLab, -22), 0.72),
                        desaturateLabColor(adjustLabLightness(baseLab, 12), 0.62),
                        rotateLabHue(adjustLabLightness(baseLab, 20), 182),
                        rotateLabHue(adjustLabLightness(baseLab, 10), 170)
                    ]
                });
                
                // 12. Squash Palette
                palettes.push({
                    name: 'Squash Palette',
                    colors: [
                        baseLab,
                        rotateLabHue(baseLab, 175),
                        rotateLabHue(adjustLabLightness(baseLab, 8), 60)
                    ]
                });
                
                // 13. Grey Friends
                palettes.push({
                    name: 'Grey Friends',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(baseLab, -22), 0.72),
                        desaturateLabColor(adjustLabLightness(baseLab, 12), 0.62)
                    ]
                });
                
                // 14. Dotting Palette
                palettes.push({
                    name: 'Dotting Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(baseLab, 12), 0.62),
                        rotateLabHue(adjustLabLightness(baseLab, 18), 180),
                        desaturateLabColor(adjustLabLightness(rotateLabHue(baseLab, 180), 15), 0.55)
                    ]
                });
                
                // 15. Skip Shade Gradient
                palettes.push({
                    name: 'Skip Shade Gradient',
                    colors: [
                        baseLab,
                        rotateLabHue(adjustLabLightness(baseLab, 5), 35),
                        rotateLabHue(adjustLabLightness(baseLab, 12), 60),
                        rotateLabHue(adjustLabLightness(baseLab, 8), 75)
                    ]
                });
                
                // 16. Threedom
                palettes.push({
                    name: 'Threedom',
                    colors: [
                        baseLab,
                        rotateLabHue(baseLab, 175),
                        rotateLabHue(adjustLabLightness(baseLab, 5), -85)
                    ]
                });
                
                // 17. Highlight Palette
                palettes.push({
                    name: 'Highlight Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(baseLab, -10), 0.65),
                        adjustLabLightness(desaturateLabColor(baseLab, 0.85), -58),
                        adjustLabLightness(desaturateLabColor(baseLab, 0.8), -42)
                    ]
                });
                
                // 18. Neighbor Palette
                palettes.push({
                    name: 'Neighbor Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(rotateLabHue(baseLab, 20), 5), 0.7),
                        desaturateLabColor(adjustLabLightness(rotateLabHue(baseLab, 15), -15), 0.65),
                        desaturateLabColor(adjustLabLightness(rotateLabHue(baseLab, 10), -28), 0.7)
                    ]
                });
                
                // 19. Discreet Palette
                palettes.push({
                    name: 'Discreet Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(baseLab, -8), 0.68),
                        desaturateLabColor(adjustLabLightness(baseLab, 50), 0.92),
                        adjustLabLightness(desaturateLabColor(baseLab, 0.8), -42)
                    ]
                });
                
                // 20. Dust Palette
                palettes.push({
                    name: 'Dust Palette',
                    colors: [
                        baseLab,
                        desaturateLabColor(adjustLabLightness(baseLab, -22), 0.72),
                        desaturateLabColor(adjustLabLightness(baseLab, 12), 0.62),
                        rotateLabHue(adjustLabLightness(baseLab, 18), 180)
                    ]
                });
                
                // 21. Collective
                palettes.push({
                    name: 'Collective',
                    colors: [
                        baseLab,
                        rotateLabHue(baseLab, -25),
                        rotateLabHue(baseLab, 175)
                    ]
                });
                
                return palettes;
            }
            
            // Display all palettes
            function displayAllPalettes(palettes) {
                const container = document.getElementById('cmw-palette-container');
                const cardsContainer = document.getElementById('cmw-palette-cards');
                cardsContainer.innerHTML = '';
                container.style.display = 'block';
                
                palettes.forEach(palette => {
                    const paletteCard = document.createElement('div');
                    paletteCard.style.cssText = `
                        background: white;
                        border: 2px solid #e2e8f0;
                        border-radius: 12px;
                        padding: 20px;
                        margin-bottom: 20px;
                        transition: all 0.2s;
                    `;
                    paletteCard.addEventListener('mouseenter', () => {
                        paletteCard.style.borderColor = '#0065a3';
                        paletteCard.style.boxShadow = '0 4px 12px rgba(0,101,163,0.1)';
                    });
                    paletteCard.addEventListener('mouseleave', () => {
                        paletteCard.style.borderColor = '#e2e8f0';
                        paletteCard.style.boxShadow = 'none';
                    });
                    
                    // Palette name
                    const title = document.createElement('h3');
                    title.textContent = palette.name;
                    title.style.cssText = `
                        margin: 0 0 16px 0;
                        font-size: 16px;
                        font-weight: 700;
                        color: #1f2937;
                        text-align: center;
                    `;
                    paletteCard.appendChild(title);
                    
                    // Color swatches container
                    const swatchesRow = document.createElement('div');
                    swatchesRow.style.cssText = `
                        display: flex;
                        gap: 12px;
                        justify-content: center;
                        flex-wrap: wrap;
                    `;
                    
                    palette.colors.forEach((lab, i) => {
                        const hex = lab2rgb(lab.L, lab.a, lab.b);
                        
                        const swatchContainer = document.createElement('div');
                        swatchContainer.style.cssText = `
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            gap: 6px;
                        `;
                        
                        const swatch = document.createElement('div');
                        swatch.style.cssText = `
                            background: ${hex};
                            width: 80px;
                            height: 80px;
                            border: 2px solid #e2e8f0;
                            border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.2s;
                        `;
                        swatch.title = `Click to copy ${hex}`;
                        swatch.addEventListener('click', () => {
                            navigator.clipboard.writeText(hex);
                            showPaletteStatus(`${hex} copied!`);
                        });
                        swatch.addEventListener('mouseenter', () => {
                            swatch.style.transform = 'scale(1.08)';
                            swatch.style.boxShadow = '0 4px 8px rgba(0,0,0,0.15)';
                        });
                        swatch.addEventListener('mouseleave', () => {
                            swatch.style.transform = 'scale(1)';
                            swatch.style.boxShadow = 'none';
                        });
                        
                        const label = document.createElement('div');
                        label.textContent = hex;
                        label.style.cssText = `
                            font-family: monospace;
                            font-size: 11px;
                            font-weight: 600;
                            color: #6b7280;
                            cursor: pointer;
                        `;
                        label.title = 'Click to copy';
                        label.addEventListener('click', () => {
                            navigator.clipboard.writeText(hex);
                            showPaletteStatus(`${hex} copied!`);
                        });
                        
                        swatchContainer.appendChild(swatch);
                        swatchContainer.appendChild(label);
                        swatchesRow.appendChild(swatchContainer);
                    });
                    
                    paletteCard.appendChild(swatchesRow);
                    cardsContainer.appendChild(paletteCard);
                });
            }
            
            function showPaletteStatus(message) {
                const status = document.getElementById('cmw-harmony-status');
                const currentText = status.textContent;
                status.textContent = currentText + ' | ' + message;
                status.className = 'cmw-status success show';
            }

            // Rendering intent controls
            const intentsToggle = document.getElementById('cmw-intents-toggle');
           
            intentsToggle.addEventListener('change', () => {
                console.log('=== Rendering Intent Toggle Changed ===');
                console.log('Toggle checked:', intentsToggle.checked);
                console.log('Current analysis data:', currentAnalysisData);
                console.log('API URL:', getApiBaseUrl());
                
                if (intentsToggle.checked) {
                    // Check for current analysis data first
                    if (currentAnalysisData) {
                        console.log('→ Calling updateRenderingIntents with currentAnalysisData...');
                        updateRenderingIntents(currentAnalysisData, currentOriginalInputData);
                    } else {
                        // Check if there's a selected library color
                        const preview = document.getElementById('cmw-color-preview');
                        if (preview.dataset.selectedL && preview.dataset.selectedA && preview.dataset.selectedB) {
                            const labData = {
                                L: parseFloat(preview.dataset.selectedL),
                                a: parseFloat(preview.dataset.selectedA),
                                b: parseFloat(preview.dataset.selectedB)
                            };
                           
                            // Create library color original data
                            const libraryOriginalData = {
                                type: 'library',
                                colorName: preview.dataset.selectedName,
                                libraryName: preview.dataset.selectedLibrary
                            };
                           
                            console.log('→ Calling updateRenderingIntents with selected library color:', labData);
                            updateRenderingIntents(labData, libraryOriginalData);
                        } else {
                            // Check if there's valid currentColorData
                            if (currentColorData && currentColorData.L !== undefined) {
                                console.log('→ Calling updateRenderingIntents with currentColorData:', currentColorData);
                                updateRenderingIntents(currentColorData, currentOriginalInputData);
                            } else {
                                // Show the section but with a message
                                const intentsSection = document.getElementById('cmw-intents-section');
                                const statusEl = document.getElementById('cmw-intents-status');
                                intentsSection.style.display = 'block';
                                statusEl.textContent = 'Enter a color to compare rendering intents';
                                statusEl.className = 'cmw-status warning show';
                                resetIntentCards();
                                console.log('→ No color data available for rendering intent comparison');
                            }
                        }
                    }
                } else {
                    document.getElementById('cmw-intents-section').style.display = 'none';
                    resetIntentCards();
                    console.log('→ Hiding rendering intent section');
                    
                    // Refresh converted color info to remove rendering intent values
                    if (currentColorData) {
                        const selectedType = document.getElementById('cmw-search-type-select').value;
                        const gamutToggle = document.getElementById('cmw-gamut-toggle');
                        let profile = 'GRACoL2013.icc';
                        let method = 'direct';
                        
                        if (selectedType === 'cmyk') {
                            profile = document.getElementById('cmw-profile-select').value;
                            method = 'api';
                        } else if (selectedType === 'rgb' || (selectedType === 'name' && isValidHex(document.getElementById('cmw-name-input').value.trim()))) {
                            method = 'api';
                        }
                        
                        // Update without rendering intent data
                        if (gamutToggle && gamutToggle.checked) {
                            checkGamut(currentColorData, profile).then(gamutData => {
                                updateConvertedColorInfo(currentColorData, method, profile, gamutData ? gamutData.inGamut : null);
                            }).catch(() => {
                                updateConvertedColorInfo(currentColorData, method, profile, null);
                            });
                        } else {
                            updateConvertedColorInfo(currentColorData, method, profile, null);
                        }
                    }
                }
            });

            // Rendering intent change handler
            document.getElementById('cmw-default-intent').addEventListener('change', () => {
                console.log('Rendering intent changed, currentAnalysisData:', currentAnalysisData);
               
                const currentIntent = document.getElementById('cmw-default-intent').value;
               
                // Update rendering intents if section is visible
                if (intentsToggle.checked && currentAnalysisData && currentIntent !== 'none') {
                    updateRenderingIntents(currentAnalysisData, currentOriginalInputData);
                }
               
                // Update ALL color displays when rendering intent changes
                const selectedType = document.getElementById('cmw-search-type-select').value;
                const preview = document.getElementById('cmw-color-preview');
               
                // For library colors (name input with selected color)
                if (preview.dataset.selectedName && preview.dataset.selectedL) {
                    const selectedColorData = {
                        name: preview.dataset.selectedName,
                        libraryName: preview.dataset.selectedLibrary,
                        L: parseFloat(preview.dataset.selectedL),
                        a: parseFloat(preview.dataset.selectedA),
                        b: parseFloat(preview.dataset.selectedB)
                    };
                    updateSelectedColorInfo(selectedColorData);
                }
               
                // For converted color info (Lab, CMYK, RGB, Hex inputs) - update with new rendering intent values
                if (currentColorData) {
                    let profile = 'GRACoL2013.icc';
                    let method = 'direct';
                   
                    if (selectedType === 'cmyk') {
                        profile = document.getElementById('cmw-profile-select').value;
                        method = 'api';
                    } else if (selectedType === 'rgb' || (selectedType === 'name' && isValidHex(document.getElementById('cmw-name-input').value.trim()))) {
                        method = 'api';
                    }
                   
                    updateConvertedColorInfo(currentColorData, method, profile);
                }
               
                // Update intent swatch for ANY valid color currently displayed
                if (currentColorData && currentIntent !== 'none') {
                    updateIntentSwatch(currentColorData);
                }
            });

            // Gamut toggle change handler - refresh converted color info when toggled
            const gamutToggle = document.getElementById('cmw-gamut-toggle');
            gamutToggle.addEventListener('change', () => {
                console.log('Gamut toggle changed:', gamutToggle.checked);
                
                // Refresh the converted color info to show/hide gamut indicator
                if (currentColorData) {
                    const selectedType = document.getElementById('cmw-search-type-select').value;
                    let profile = 'GRACoL2013.icc';
                    let method = 'direct';
                    
                    if (selectedType === 'cmyk') {
                        profile = document.getElementById('cmw-profile-select').value;
                        method = 'api';
                    } else if (selectedType === 'rgb' || (selectedType === 'name' && isValidHex(document.getElementById('cmw-name-input').value.trim()))) {
                        method = 'api';
                    }
                    
                    // Re-call updateConvertedColorInfo to refresh the gamut indicator
                    if (gamutToggle.checked) {
                        // When turning ON, fetch gamut status and update
                        checkGamut(currentColorData, profile).then(gamutData => {
                            updateConvertedColorInfo(currentColorData, method, profile, gamutData ? gamutData.inGamut : null);
                        }).catch(() => {
                            updateConvertedColorInfo(currentColorData, method, profile, null);
                        });
                    } else {
                        // When turning OFF, just refresh without gamut status
                        updateConvertedColorInfo(currentColorData, method, profile, null);
                    }
                }
                
                // Also refresh the rendering intent display if it's visible
                // Use currentAnalysisData if available, otherwise currentColorData
                const labDataForIntents = currentAnalysisData || currentColorData;
                if (intentsToggle.checked && labDataForIntents) {
                    updateRenderingIntents(labDataForIntents, currentOriginalInputData);
                }
            });

            /* ─────────────────────
               Color Harmony Feature (New - Independent)
               ───────────────────── */
            
            // Harmony section collapsible toggle
            const harmonyNewToggle = document.getElementById('cmw-harmony-new-toggle');
            const harmonyNewContent = document.getElementById('cmw-harmony-new-content');
            
            harmonyNewToggle.addEventListener('click', () => {
                const isCollapsed = harmonyNewToggle.classList.contains('collapsed');
                
                if (isCollapsed) {
                    harmonyNewToggle.classList.remove('collapsed');
                    harmonyNewContent.classList.remove('collapsed');
                } else {
                    harmonyNewToggle.classList.add('collapsed');
                    harmonyNewContent.classList.add('collapsed');
                }
            });
            
            // Harmony color input format switching
            const harmonyFormatSelect = document.getElementById('cmw-harmony-format');
            const harmonyInputGroups = {
                hex: document.getElementById('cmw-harmony-hex-inputs'),
                lab: document.getElementById('cmw-harmony-lab-inputs'),
                rgb: document.getElementById('cmw-harmony-rgb-inputs'),
                cmyk: document.getElementById('cmw-harmony-cmyk-inputs')
            };
            
            harmonyFormatSelect.addEventListener('change', (e) => {
                // Hide all input groups
                Object.values(harmonyInputGroups).forEach(group => {
                    if (group) group.style.display = 'none';
                });
                // Show selected group
                if (harmonyInputGroups[e.target.value]) {
                    harmonyInputGroups[e.target.value].style.display = 'flex';
                }
            });
            
            // Live preview for harmony inputs
            async function updateHarmonyPreview() {
                const format = harmonyFormatSelect.value;
                const harmonySwatch = document.getElementById('cmw-harmony-swatch');
                const harmonyValues = document.getElementById('cmw-harmony-values');
                
                try {
                    if (format === 'hex') {
                        const hex = document.getElementById('cmw-harmony-hex').value.trim().replace(/^#/, '');
                        if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                            harmonySwatch.style.background = '#' + hex;
                            const rgb = hex2rgb(hex);
                            const data = await convertColor({ rgb: [rgb.r, rgb.g, rgb.b], profile: 'sRGB.icc' });
                            harmonyValues.textContent = `Lab: ${data.lab[0].toFixed(2)}, ${data.lab[1].toFixed(2)}, ${data.lab[2].toFixed(2)} | Hex: #${hex.toUpperCase()}`;
                        }
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById('cmw-harmony-lab-l').value);
                        const a = parseFloat(document.getElementById('cmw-harmony-lab-a').value);
                        const b = parseFloat(document.getElementById('cmw-harmony-lab-b').value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            const data = await convertColor({ lab: [L, a, b], profile: 'sRGB.icc' });
                            harmonySwatch.style.background = data.hex.startsWith('#') ? data.hex : '#' + data.hex;
                            harmonyValues.textContent = `Lab: ${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)} | Hex: ${data.hex}`;
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById('cmw-harmony-rgb-r').value);
                        const g = parseInt(document.getElementById('cmw-harmony-rgb-g').value);
                        const b = parseInt(document.getElementById('cmw-harmony-rgb-b').value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            const data = await convertColor({ rgb: [r, g, b], profile: 'sRGB.icc' });
                            harmonySwatch.style.background = data.hex.startsWith('#') ? data.hex : '#' + data.hex;
                            harmonyValues.textContent = `Lab: ${data.lab[0].toFixed(2)}, ${data.lab[1].toFixed(2)}, ${data.lab[2].toFixed(2)} | Hex: ${data.hex}`;
                        }
                    } else if (format === 'cmyk') {
                        const c = parseFloat(document.getElementById('cmw-harmony-cmyk-c').value);
                        const m = parseFloat(document.getElementById('cmw-harmony-cmyk-m').value);
                        const y = parseFloat(document.getElementById('cmw-harmony-cmyk-y').value);
                        const k = parseFloat(document.getElementById('cmw-harmony-cmyk-k').value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            const data = await convertColor({ cmyk: [c, m, y, k], profile: 'GRACoL2013.icc' });
                            harmonySwatch.style.background = data.hex.startsWith('#') ? data.hex : '#' + data.hex;
                            harmonyValues.textContent = `Lab: ${data.lab[0].toFixed(2)}, ${data.lab[1].toFixed(2)}, ${data.lab[2].toFixed(2)} | Hex: ${data.hex}`;
                        }
                    }
                } catch (err) {
                    console.error('Harmony preview error:', err);
                }
            }
            
            // Add input listeners to all harmony inputs
            ['cmw-harmony-hex', 'cmw-harmony-lab-l', 'cmw-harmony-lab-a', 'cmw-harmony-lab-b',
             'cmw-harmony-rgb-r', 'cmw-harmony-rgb-g', 'cmw-harmony-rgb-b',
             'cmw-harmony-cmyk-c', 'cmw-harmony-cmyk-m', 'cmw-harmony-cmyk-y', 'cmw-harmony-cmyk-k'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', updateHarmonyPreview);
                }
            });
            
            // Harmony mode toggle (library vs hex)
            const harmonyMode = document.getElementById('cmw-harmony-mode');
            const harmonyLibrarySelector = document.getElementById('cmw-harmony-library-selector');
            
            harmonyMode.addEventListener('change', (e) => {
                if (e.target.value === 'library') {
                    harmonyLibrarySelector.style.display = 'block';
                } else {
                    harmonyLibrarySelector.style.display = 'none';
                }
            });
            
            // Initialize harmony library search (wrapped in setTimeout to ensure DOM is ready)
            setTimeout(() => {
                console.log('🎵 Starting harmony library search initialization...');
                
                const harmonyLibrarySearchInput = document.getElementById('cmw-harmony-library-search');
                const harmonyActiveLibrariesDisplay = document.getElementById('cmw-harmony-active-libraries');
                const harmonyLibrarySuggestions = document.getElementById('cmw-harmony-library-suggestions');
                
                console.log('🎵 Harmony library search elements:', {
                    input: !!harmonyLibrarySearchInput,
                    display: !!harmonyActiveLibrariesDisplay,
                    suggestions: !!harmonyLibrarySuggestions
                });
                
                let harmonySuggestionsVisible = false;
                let harmonyUserHasSelectedSpecificLibraries = false;
                let harmonyCurrentMatches = [];
                let harmonyHighlightedIndex = -1;
                let harmonyInactivityTimer = null;
            
            // Create hidden checkbox container for harmony libraries (mirroring cmw-public-libraries-container)
            const harmonyLibrariesContainer = document.createElement('div');
            harmonyLibrariesContainer.id = 'cmw-harmony-libraries-container';
            harmonyLibrariesContainer.style.display = 'none';
            document.body.appendChild(harmonyLibrariesContainer);
            
            // Populate hidden checkboxes when libraries are loaded
            function populateHarmonyLibraryCheckboxes() {
                if (!libraryManifest || libraryManifest.length === 0) {
                    console.log('⏳ Waiting for libraryManifest to load for harmony...');
                    setTimeout(populateHarmonyLibraryCheckboxes, 1000);
                    return;
                }
                
                console.log('✅ Populating harmony library checkboxes:', libraryManifest.length, 'libraries');
                harmonyLibrariesContainer.innerHTML = '';
                libraryManifest.forEach(lib => {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `harmony-toggle-${lib.id}`;
                    checkbox.value = lib.id;
                    checkbox.checked = true; // All libraries active by default
                    
                    const label = document.createElement('label');
                    label.htmlFor = `harmony-toggle-${lib.id}`;
                    
                    const labelText = document.createTextNode(lib.name + ' ');
                    const countSpan = document.createElement('span');
                    countSpan.textContent = '(' + (libs[lib.id] ? libs[lib.id].length : 0) + ')';
                    
                    label.appendChild(labelText);
                    label.appendChild(countSpan);
                    
                    harmonyLibrariesContainer.appendChild(checkbox);
                    harmonyLibrariesContainer.appendChild(label);
                    
                    console.log('🎵 Added harmony checkbox:', lib.name, 'with label text:', label.textContent);
                });
                
                console.log('✅ Harmony checkboxes populated successfully');
                updateHarmonyActiveLibrariesDisplay();
            }
            
            setTimeout(populateHarmonyLibraryCheckboxes, 2000);
            
            function updateHarmonyActiveLibrariesDisplay() {
                const checkboxes = document.querySelectorAll('#cmw-harmony-libraries-container input[type="checkbox"]');
                const activeLibs = Array.from(checkboxes).filter(cb => cb.checked);
                
                if (activeLibs.length === 0) {
                    harmonyActiveLibrariesDisplay.innerHTML = `
                        <span style="color: #ef4444; font-size: 13px; display: flex; align-items: center; gap: 4px;">
                            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="12" y1="8" x2="12" y2="12"></line>
                                <line x1="12" y1="16" x2="12.01" y2="16"></line>
                            </svg>
                            No libraries selected - type library name to add
                        </span>
                    `;
                } else if (activeLibs.length === checkboxes.length) {
                    harmonyActiveLibrariesDisplay.innerHTML = `
                        <span style="color: #10b981; font-size: 13px; display: flex; align-items: center; gap: 4px;">
                            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: currentColor; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            All libraries active
                        </span>
                    `;
                } else {
                    harmonyActiveLibrariesDisplay.innerHTML = activeLibs.map(cb => {
                        const libName = cb.nextElementSibling.textContent.split('(')[0].trim();
                        return `
                            <div style="display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: #0065a3; color: white; border-radius: 16px; font-size: 13px; cursor: pointer;" data-lib-id="${cb.value}" class="cmw-harmony-active-lib-chip">
                                <span>${libName}</span>
                                <span style="font-weight: bold; font-size: 16px; line-height: 1;">×</span>
                            </div>
                        `;
                    }).join('');
                    
                    // Add click handlers to remove chips
                    harmonyActiveLibrariesDisplay.querySelectorAll('.cmw-harmony-active-lib-chip').forEach(chip => {
                        chip.addEventListener('click', () => {
                            const libId = chip.dataset.libId;
                            const checkbox = document.querySelector(`#cmw-harmony-libraries-container input[value="${libId}"]`);
                            if (checkbox) {
                                const currentChecked = document.querySelectorAll('#cmw-harmony-libraries-container input[type="checkbox"]:checked');
                                const isLastLibrary = currentChecked.length === 1;
                                
                                checkbox.checked = false;
                                
                                if (isLastLibrary) {
                                    const allCheckboxes = document.querySelectorAll('#cmw-harmony-libraries-container input[type="checkbox"]');
                                    allCheckboxes.forEach(cb => cb.checked = true);
                                    harmonyUserHasSelectedSpecificLibraries = false;
                                }
                                
                                updateHarmonyActiveLibrariesDisplay();
                            }
                        });
                    });
                }
            }
            
            function showHarmonyLibrarySuggestions(inputText, forceShowAll = false) {
                const text = inputText.toLowerCase().trim();
                console.log('🔎 showHarmonyLibrarySuggestions called with:', text, 'forceShowAll:', forceShowAll);
                
                const showAllLibraries = forceShowAll || text === '*' || text.startsWith('* ');
                
                if (text.length === 0 && !forceShowAll) {
                    harmonyLibrarySuggestions.style.display = 'none';
                    harmonySuggestionsVisible = false;
                    harmonyCurrentMatches = [];
                    harmonyHighlightedIndex = -1;
                    return;
                }
                
                const checkboxes = document.querySelectorAll('#cmw-harmony-libraries-container input[type="checkbox"]');
                console.log('📦 Harmony: Found', checkboxes.length, 'checkboxes to search');
                const matches = [];
                
                if (showAllLibraries) {
                    console.log('⭐ Harmony: Show all mode - displaying all libraries');
                    const filterText = text.startsWith('* ') ? text.substring(2).trim() : '';
                    
                    checkboxes.forEach(cb => {
                        const label = cb.nextElementSibling?.textContent;
                        console.log('🔍 Harmony checkbox label:', label, 'for value:', cb.value);
                        if (!label) return;
                        
                        const libId = cb.value.toLowerCase();
                        const labelLower = label.toLowerCase();
                        
                        if (filterText) {
                            if (libId.includes(filterText) || labelLower.includes(filterText)) {
                                matches.push({
                                    id: cb.value,
                                    name: label,
                                    score: libId.startsWith(filterText) || labelLower.startsWith(filterText) ? 1 : 0.5
                                });
                            }
                        } else {
                            matches.push({
                                id: cb.value,
                                name: label,
                                score: 1
                            });
                        }
                    });
                } else if (text.length === 1 && text !== '*') {
                    checkboxes.forEach(cb => {
                        const label = cb.nextElementSibling?.textContent;
                        if (!label) return;
                        
                        const libId = cb.value.toLowerCase();
                        const labelLower = label.toLowerCase();
                        
                        if (libId.startsWith(text) || labelLower.startsWith(text)) {
                            matches.push({
                                id: cb.value,
                                name: label,
                                score: 1
                            });
                        }
                    });
                } else {
                    checkboxes.forEach(cb => {
                        const label = cb.nextElementSibling?.textContent;
                        if (!label) return;
                        
                        const libId = cb.value.toLowerCase();
                        const labelLower = label.toLowerCase();
                        
                        if (libId.includes(text) || labelLower.includes(text)) {
                            matches.push({
                                id: cb.value,
                                name: label,
                                score: libId.startsWith(text) || labelLower.startsWith(text) ? 1 : 0.5
                            });
                        }
                    });
                }
                
                matches.sort((a, b) => {
                    if (b.score !== a.score) return b.score - a.score;
                    return a.name.localeCompare(b.name);
                });
                
                if (matches.length === 0) {
                    harmonyLibrarySuggestions.style.display = 'none';
                    harmonySuggestionsVisible = false;
                    harmonyCurrentMatches = [];
                    harmonyHighlightedIndex = -1;
                    return;
                }
                
                let dropdownHTML = '';
                
                if (showAllLibraries) {
                    dropdownHTML = `
                        <div style="padding: 8px 16px; background: #f9fafb; border-bottom: 2px solid #e2e8f0; font-weight: 600; color: #374151; font-size: 12px; text-align: center;">
                            All Available Libraries (${matches.length})
                        </div>
                    `;
                }
                
                const maxResults = showAllLibraries ? 20 : 10;
                const visibleMatches = matches.slice(0, maxResults);
                
                dropdownHTML += visibleMatches.map(match => `
                    <div class="cmw-harmony-library-suggestion-item" data-lib-id="${match.id}" style="padding: 10px 16px; cursor: pointer; border-bottom: 1px solid #f3f4f6; transition: background 0.15s;">
                        ${match.name}
                    </div>
                `).join('');
                
                if (matches.length > maxResults) {
                    dropdownHTML += `
                        <div style="padding: 8px 16px; background: #f9fafb; font-size: 11px; color: #6b7280; text-align: center; border-top: 1px solid #e2e8f0;">
                            Showing ${maxResults} of ${matches.length} libraries - type more to narrow down
                        </div>
                    `;
                }
                
                harmonyLibrarySuggestions.innerHTML = dropdownHTML;
                harmonyCurrentMatches = visibleMatches;
                harmonyHighlightedIndex = -1;
                
                const suggestionItems = harmonyLibrarySuggestions.querySelectorAll('.cmw-harmony-library-suggestion-item');
                suggestionItems.forEach((item, index) => {
                    item.addEventListener('mouseenter', () => {
                        harmonyHighlightedIndex = index;
                        updateHarmonyHighlighting();
                    });
                    item.addEventListener('mouseleave', () => {
                        harmonyHighlightedIndex = -1;
                        updateHarmonyHighlighting();
                    });
                    item.addEventListener('click', () => {
                        clearHarmonyInactivityTimer();
                        selectHarmonyLibraryFromSuggestion(item.dataset.libId);
                    });
                });
                
                if (showAllLibraries) {
                    harmonyLibrarySuggestions.style.maxHeight = '300px';
                } else {
                    harmonyLibrarySuggestions.style.maxHeight = '200px';
                }
                
                console.log('🎯 Found', matches.length, 'matching harmony libraries, showing', visibleMatches.length);
                harmonyLibrarySuggestions.style.display = 'block';
                harmonySuggestionsVisible = true;
                
                resetHarmonyInactivityTimer();
            }
            
            function updateHarmonyHighlighting() {
                const items = harmonyLibrarySuggestions.querySelectorAll('.cmw-harmony-library-suggestion-item');
                items.forEach((item, index) => {
                    if (index === harmonyHighlightedIndex) {
                        item.style.background = '#dbeafe';
                        item.style.borderLeft = '3px solid #0065a3';
                        item.style.paddingLeft = '13px';
                        item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                    } else {
                        item.style.background = 'white';
                        item.style.borderLeft = 'none';
                        item.style.paddingLeft = '16px';
                    }
                });
                
                resetHarmonyInactivityTimer();
            }
            
            function startHarmonyInactivityTimer() {
                clearHarmonyInactivityTimer();
                
                harmonyInactivityTimer = setTimeout(() => {
                    harmonyLibrarySuggestions.style.display = 'none';
                    harmonySuggestionsVisible = false;
                    harmonyCurrentMatches = [];
                    harmonyHighlightedIndex = -1;
                    harmonyInactivityTimer = null;
                }, 6000);
            }
            
            function clearHarmonyInactivityTimer() {
                if (harmonyInactivityTimer) {
                    clearTimeout(harmonyInactivityTimer);
                    harmonyInactivityTimer = null;
                }
            }
            
            function resetHarmonyInactivityTimer() {
                if (harmonySuggestionsVisible) {
                    startHarmonyInactivityTimer();
                }
            }
            
            function selectHarmonyLibraryFromSuggestion(libId) {
                clearHarmonyInactivityTimer();
                
                if (!harmonyUserHasSelectedSpecificLibraries) {
                    const allCheckboxes = document.querySelectorAll('#cmw-harmony-libraries-container input[type="checkbox"]');
                    allCheckboxes.forEach(cb => cb.checked = false);
                    harmonyUserHasSelectedSpecificLibraries = true;
                }
                
                const checkbox = document.querySelector(`#cmw-harmony-libraries-container input[value="${libId}"]`);
                
                if (checkbox) {
                    checkbox.checked = true;
                    updateHarmonyActiveLibrariesDisplay();
                }
                
                harmonyLibrarySearchInput.value = '';
                harmonyLibrarySuggestions.style.display = 'none';
                harmonySuggestionsVisible = false;
                harmonyCurrentMatches = [];
                harmonyHighlightedIndex = -1;
                harmonyLibrarySearchInput.focus();
            }
            
            // Setup event listeners
            if (harmonyLibrarySearchInput && harmonyLibrarySuggestions) {
                console.log('✅ Setting up harmony library search event listeners');
                
                harmonyLibrarySearchInput.addEventListener('input', (e) => {
                    console.log('📝 Harmony input event:', e.target.value);
                    clearHarmonyInactivityTimer();
                    showHarmonyLibrarySuggestions(e.target.value, false);
                });
                
                harmonyLibrarySearchInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        console.log('⬇️ Harmony down arrow pressed');
                        
                        if (!harmonySuggestionsVisible || harmonyCurrentMatches.length === 0) {
                            console.log('⬇️ Showing all harmony libraries');
                            showHarmonyLibrarySuggestions(e.target.value, true);
                        } else {
                            console.log('⬇️ Navigate down in harmony dropdown');
                            harmonyHighlightedIndex = Math.min(harmonyHighlightedIndex + 1, harmonyCurrentMatches.length - 1);
                            updateHarmonyHighlighting();
                        }
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        console.log('⬆️ Harmony up arrow pressed');
                        
                        if (harmonySuggestionsVisible && harmonyCurrentMatches.length > 0) {
                            if (harmonyHighlightedIndex <= 0) {
                                console.log('⬆️ At top - closing harmony dropdown');
                                clearHarmonyInactivityTimer();
                                harmonyLibrarySuggestions.style.display = 'none';
                                harmonySuggestionsVisible = false;
                                harmonyHighlightedIndex = -1;
                                harmonyCurrentMatches = [];
                            } else {
                                console.log('⬆️ Navigate up in harmony dropdown');
                                harmonyHighlightedIndex--;
                                updateHarmonyHighlighting();
                            }
                        }
                    }
                });
                
                harmonyLibrarySearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        console.log('⏎ Harmony Enter pressed with value:', e.target.value);
                        e.preventDefault();
                        
                        const text = e.target.value.trim();
                        
                        if (text === '*') {
                            console.log('⚠️ Just * - not processing');
                            return;
                        }
                        
                        if (harmonyHighlightedIndex >= 0 && harmonyHighlightedIndex < harmonyCurrentMatches.length) {
                            console.log('✅ Highlighted harmony item found - selecting');
                            selectHarmonyLibraryFromSuggestion(harmonyCurrentMatches[harmonyHighlightedIndex].id);
                            return;
                        }
                        
                        if (harmonyCurrentMatches.length === 1) {
                            console.log('✅ Exactly 1 harmony match found - auto-selecting');
                            selectHarmonyLibraryFromSuggestion(harmonyCurrentMatches[0].id);
                            return;
                        }
                        
                        if (harmonyCurrentMatches.length > 1) {
                            console.log('⚠️ Multiple harmony matches - use arrows or type more');
                            harmonyLibrarySearchInput.style.borderColor = '#f59e0b';
                            setTimeout(() => {
                                harmonyLibrarySearchInput.style.borderColor = '#e2e8f0';
                            }, 300);
                            return;
                        }
                    }
                });
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!harmonyLibrarySearchInput.contains(e.target) && !harmonyLibrarySuggestions.contains(e.target)) {
                        clearHarmonyInactivityTimer();
                        harmonyLibrarySuggestions.style.display = 'none';
                        harmonySuggestionsVisible = false;
                        harmonyCurrentMatches = [];
                        harmonyHighlightedIndex = -1;
                    }
                });
            } else {
                console.error('❌ Harmony library search elements not found!');
            }
            
            // Update display when checkboxes change (from any source)
            if (harmonyLibrariesContainer) {
                harmonyLibrariesContainer.addEventListener('change', (e) => {
                    if (e.target.type === 'checkbox') {
                        console.log('🔄 Harmony checkbox changed:', e.target.value, 'checked:', e.target.checked);
                        updateHarmonyActiveLibrariesDisplay();
                    }
                });
            }
            
                // Add mousemove listener to dropdown to detect ANY mouse activity
                if (harmonyLibrarySuggestions) {
                    harmonyLibrarySuggestions.addEventListener('mousemove', () => {
                        if (harmonySuggestionsVisible) {
                            resetHarmonyInactivityTimer();
                        }
                    });
                }
                
                console.log('✅ Harmony library search initialization complete!');
            }, 100); // End of harmony initialization setTimeout
            
            // Get harmony color data from inputs
            async function getHarmonyColorData() {
                const format = harmonyFormatSelect.value;
                
                try {
                    if (format === 'hex') {
                        const input = document.getElementById('cmw-harmony-hex').value.trim();
                        const cleanHex = input.replace(/^#/, '');
                        if (/^[0-9A-Fa-f]{6}$/.test(cleanHex)) {
                            const rgb = hex2rgb(cleanHex);
                            const data = await convertColor({
                                rgb: [rgb.r, rgb.g, rgb.b],
                                profile: 'sRGB.icc'
                            });
                            return {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex ? (data.hex.startsWith('#') ? data.hex : '#' + data.hex) : '#' + cleanHex
                            };
                        }
                        return null;
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById('cmw-harmony-lab-l').value);
                        const a = parseFloat(document.getElementById('cmw-harmony-lab-a').value);
                        const b = parseFloat(document.getElementById('cmw-harmony-lab-b').value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            const data = await convertColor({
                                lab: [L, a, b],
                                profile: 'sRGB.icc'
                            });
                            return {
                                lab: { L, a, b },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex
                            };
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById('cmw-harmony-rgb-r').value);
                        const g = parseInt(document.getElementById('cmw-harmony-rgb-g').value);
                        const b = parseInt(document.getElementById('cmw-harmony-rgb-b').value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            const data = await convertColor({
                                rgb: [r, g, b],
                                profile: 'sRGB.icc'
                            });
                            return {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex
                            };
                        }
                    } else if (format === 'cmyk') {
                        const c = parseFloat(document.getElementById('cmw-harmony-cmyk-c').value);
                        const m = parseFloat(document.getElementById('cmw-harmony-cmyk-m').value);
                        const y = parseFloat(document.getElementById('cmw-harmony-cmyk-y').value);
                        const k = parseFloat(document.getElementById('cmw-harmony-cmyk-k').value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            const data = await convertColor({
                                cmyk: [c, m, y, k],
                                profile: 'GRACoL2013.icc'
                            });
                            return {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex
                            };
                        }
                    }
                } catch (error) {
                    console.error('Error getting harmony color data:', error);
                    return null;
                }
                
                return null;
            }
            
            // Update harmony swatch as user types
            ['cmw-harmony-hex', 'cmw-harmony-lab-l', 'cmw-harmony-lab-a', 'cmw-harmony-lab-b', 
             'cmw-harmony-rgb-r', 'cmw-harmony-rgb-g', 'cmw-harmony-rgb-b',
             'cmw-harmony-cmyk-c', 'cmw-harmony-cmyk-m', 'cmw-harmony-cmyk-y', 'cmw-harmony-cmyk-k'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', async () => {
                        const colorData = await getHarmonyColorData();
                        if (colorData) {
                            document.getElementById('cmw-harmony-swatch').style.background = colorData.hex;
                            document.getElementById('cmw-harmony-values').textContent = 
                                `Lab: ${colorData.lab.L.toFixed(2)}, ${colorData.lab.a.toFixed(2)}, ${colorData.lab.b.toFixed(2)} | Hex: ${colorData.hex}`;
                        }
                    });
                }
            });
            
            // Helper function to find closest colors in selected libraries only
            function findClosestInSelectedLibraries(targetLab, selectedLibs, maxResults = 5) {
                const allMatches = [];
                const seenLabValues = new Set();
                
                for (const libId of selectedLibs) {
                    const lib = libs[libId];
                    if (!lib || lib.length === 0) continue;
                    
                    for (const color of lib) {
                        const labKey = `${color.L.toFixed(1)}_${color.a.toFixed(1)}_${color.b.toFixed(1)}`;
                        if (seenLabValues.has(labKey)) continue;
                        seenLabValues.add(labKey);
                        
                        const deltaE = dE(targetLab.L, targetLab.a, targetLab.b, color.L, color.a, color.b);
                        allMatches.push({
                            name: color.name,
                            library: color.libraryName || libNames[libId],
                            deltaE: deltaE,
                            lab: [color.L, color.a, color.b],
                            colorData: color
                        });
                    }
                }
                
                allMatches.sort((a, b) => a.deltaE - b.deltaE);
                return allMatches.slice(0, maxResults);
            }
            
            // Calculate Harmonies Button - Uses LittleCMS API like Settings version
            document.getElementById('cmw-harmony-calculate-btn').addEventListener('click', async () => {
                const loadingEl = document.getElementById('cmw-harmony-loading');
                const colorsEl = document.getElementById('cmw-harmony-colors');
                const statusEl = document.getElementById('cmw-harmony-status');
                const mode = harmonyMode.value;
                const harmonyType = document.getElementById('cmw-harmony-new-type').value;
                
                // Get base color
                const colorData = await getHarmonyColorData();
                if (!colorData) {
                    statusEl.textContent = 'Please enter a valid color';
                    statusEl.className = 'cmw-status show error';
                    return;
                }
                
                // Show loading
                loadingEl.style.display = 'flex';
                colorsEl.innerHTML = '';
                statusEl.className = 'cmw-status';
                
                try {
                    const lab = colorData.lab;
                    
                    // Calculate harmony colors (returns array directly)
                    const harmonyColors = calculateLocalHarmonies({ L: lab.L, a: lab.a, b: lab.b }, harmonyType);
                    
                    if (mode === 'hex') {
                        // Hex mode: Use LittleCMS API to get accurate hex values
                        for (let i = 0; i < harmonyColors.length; i++) {
                            const color = harmonyColors[i];
                            const labValues = Array.isArray(color.lab) ? color.lab : [color.lab.L, color.lab.a, color.lab.b];
                            
                            // Create card element
                            const cardEl = document.createElement('div');
                            cardEl.className = 'cmw-harmony-card';
                            
                            const swatchEl = document.createElement('div');
                            swatchEl.className = 'cmw-harmony-card-swatch';
                            swatchEl.style.background = lab2rgb(labValues[0], labValues[1], labValues[2]);
                            swatchEl.style.cursor = 'pointer';
                            
                            const titleEl = document.createElement('div');
                            titleEl.className = 'cmw-harmony-card-title';
                            titleEl.textContent = i === 0 ? 'Base Color' : `Harmony ${i}`;
                            
                            const hexEl = document.createElement('div');
                            hexEl.className = 'cmw-harmony-card-hex';
                            hexEl.textContent = 'Loading...';
                            
                            const labEl = document.createElement('div');
                            labEl.className = 'cmw-harmony-card-lab';
                            labEl.textContent = `Lab: ${labValues[0].toFixed(2)}, ${labValues[1].toFixed(2)}, ${labValues[2].toFixed(2)}`;
                            
                            cardEl.appendChild(swatchEl);
                            cardEl.appendChild(titleEl);
                            cardEl.appendChild(hexEl);
                            cardEl.appendChild(labEl);
                            colorsEl.appendChild(cardEl);
                            
                            // Add click handler to show modal
                            swatchEl.addEventListener('click', () => {
                                const displayColor = window.getComputedStyle(swatchEl).backgroundColor;
                                showColorModal({
                                    name: titleEl.textContent,
                                    L: labValues[0],
                                    a: labValues[1],
                                    b: labValues[2],
                                    displayColor
                                });
                            });
                            
                            // Get accurate hex from LittleCMS API (sRGB.icc)
                            convertColor({
                                lab: labValues,
                                profile: 'sRGB.icc'
                            }).then(srgbData => {
                                let hexValue = srgbData.hex;
                                if (!hexValue.startsWith('#')) {
                                    hexValue = '#' + hexValue;
                                }
                                hexValue = hexValue.toUpperCase();
                                hexEl.textContent = hexValue;
                                swatchEl.style.background = hexValue;
                            }).catch(error => {
                                console.error('LittleCMS API error:', error);
                                hexEl.textContent = 'API Error';
                            });
                        }
                        
                        statusEl.textContent = `Generated ${harmonyColors.length} harmony colors`;
                        statusEl.className = 'cmw-status show success';
                        
                    } else {
                        // Library mode: Use LittleCMS API and find library matches
                        const harmonyCheckboxes = document.querySelectorAll('#cmw-harmony-libraries-container input[type="checkbox"]');
                        const selectedLibs = Array.from(harmonyCheckboxes).filter(cb => cb.checked).map(cb => cb.value);
                        
                        if (selectedLibs.length === 0) {
                            throw new Error('No libraries selected - please select at least one library');
                        }
                        
                        for (let i = 0; i < harmonyColors.length; i++) {
                            const color = harmonyColors[i];
                            const labValues = Array.isArray(color.lab) ? color.lab : [color.lab.L, color.lab.a, color.lab.b];
                            
                            // Find library matches (convert array to object)
                            const matches = findClosestInSelectedLibraries({ L: labValues[0], a: labValues[1], b: labValues[2] }, selectedLibs, 3);
                            
                            // Create card element
                            const cardEl = document.createElement('div');
                            cardEl.className = 'cmw-harmony-card';
                            
                            const swatchEl = document.createElement('div');
                            swatchEl.className = 'cmw-harmony-card-swatch';
                            swatchEl.style.background = lab2rgb(labValues[0], labValues[1], labValues[2]);
                            swatchEl.style.cursor = 'pointer';
                            
                            const titleEl = document.createElement('div');
                            titleEl.className = 'cmw-harmony-card-title';
                            titleEl.textContent = i === 0 ? 'Base Color' : `Harmony ${i}`;
                            
                            const hexEl = document.createElement('div');
                            hexEl.className = 'cmw-harmony-card-hex';
                            hexEl.textContent = 'Loading...';
                            
                            const cmykEl = document.createElement('div');
                            cmykEl.className = 'cmw-harmony-card-lab';
                            cmykEl.textContent = 'CMYK: Loading...';
                            
                            const labEl = document.createElement('div');
                            labEl.className = 'cmw-harmony-card-lab';
                            labEl.textContent = `Lab: ${labValues[0].toFixed(2)}, ${labValues[1].toFixed(2)}, ${labValues[2].toFixed(2)}`;
                            
                            const matchesEl = document.createElement('div');
                            matchesEl.className = 'cmw-harmony-card-matches';
                            
                            if (matches && matches.length > 0) {
                                matches.slice(0, 3).forEach(match => {
                                    const matchDiv = document.createElement('div');
                                    matchDiv.className = 'cmw-harmony-card-match';
                                    matchDiv.innerHTML = `<strong>${match.library}:</strong> ${match.name} (ΔE: ${match.deltaE.toFixed(2)})`;
                                    matchesEl.appendChild(matchDiv);
                                });
                            } else {
                                matchesEl.innerHTML = '<div class="cmw-harmony-card-match">No library matches</div>';
                            }
                            
                            cardEl.appendChild(swatchEl);
                            cardEl.appendChild(titleEl);
                            cardEl.appendChild(hexEl);
                            cardEl.appendChild(cmykEl);
                            cardEl.appendChild(labEl);
                            cardEl.appendChild(matchesEl);
                            colorsEl.appendChild(cardEl);
                            
                            // Add click handler to show modal
                            swatchEl.addEventListener('click', () => {
                                const displayColor = window.getComputedStyle(swatchEl).backgroundColor;
                                showColorModal({
                                    name: titleEl.textContent,
                                    L: labValues[0],
                                    a: labValues[1],
                                    b: labValues[2],
                                    displayColor
                                });
                            });
                            
                            // Get accurate CMYK and Hex from LittleCMS API
                            Promise.all([
                                convertColor({
                                    lab: labValues,
                                    profile: 'GRACoL2013.icc'
                                }),
                                convertColor({
                                    lab: labValues,
                                    profile: 'sRGB.icc'
                                })
                            ]).then(([cmykData, srgbData]) => {
                                // Update CMYK
                                if (cmykData.gamut && cmykData.gamut.cmykEquivalent) {
                                    const cmyk = cmykData.gamut.cmykEquivalent;
                                    cmykEl.textContent = `CMYK: ${cmyk[0].toFixed(1)}, ${cmyk[1].toFixed(1)}, ${cmyk[2].toFixed(1)}, ${cmyk[3].toFixed(1)}`;
                                } else {
                                    cmykEl.textContent = 'CMYK: --';
                                }
                                
                                // Update Hex
                                let hexValue = srgbData.hex;
                                if (!hexValue.startsWith('#')) {
                                    hexValue = '#' + hexValue;
                                }
                                hexValue = hexValue.toUpperCase();
                                hexEl.textContent = hexValue;
                                swatchEl.style.background = hexValue;
                            }).catch(error => {
                                console.error('LittleCMS API error:', error);
                                hexEl.textContent = 'API Error';
                                cmykEl.textContent = 'CMYK: API Error';
                            });
                        }
                        
                        statusEl.textContent = `Generated ${harmonyColors.length} harmony colors with library matches`;
                        statusEl.className = 'cmw-status show success';
                    }
                    
                    // Generate palette variations from the base color
                    const palettes = generatePaletteVariations(lab);
                    displayAllPalettes(palettes);
                    
                } catch (error) {
                    console.error('Error calculating harmonies:', error);
                    statusEl.textContent = error.message || 'Error calculating harmonies';
                    statusEl.className = 'cmw-status show error';
                } finally {
                    loadingEl.style.display = 'none';
                }
            });

            /* ─────────────────────
               Color Spectrum Browser Feature
               ───────────────────── */
            
            const spectrumToggle = document.getElementById('cmw-spectrum-toggle');
            const spectrumContent = document.getElementById('cmw-spectrum-content');
            const spectrumLibrarySelect = document.getElementById('cmw-spectrum-library');
            const spectrumDisplay = document.getElementById('cmw-spectrum-display');
            const spectrumCanvas = document.getElementById('cmw-spectrum-canvas');
            const spectrumColorsGrid = document.getElementById('cmw-spectrum-colors');
            const spectrumTitle = document.getElementById('cmw-spectrum-title');
            const spectrumStatus = document.getElementById('cmw-spectrum-status');
            const spectrumPrevBtn = document.getElementById('cmw-spectrum-prev');
            const spectrumNextBtn = document.getElementById('cmw-spectrum-next');
            
            let currentSpectrumLibrary = null;
            let sortedSpectrumColors = [];
            let currentColorIndex = 0; // Start index for pagination
            const COLORS_PER_PAGE = 50; // Show 50 colors at a time
            
            // Toggle collapsible
            spectrumToggle.addEventListener('click', () => {
                const isCollapsed = spectrumToggle.classList.contains('collapsed');
                if (isCollapsed) {
                    spectrumToggle.classList.remove('collapsed');
                    spectrumContent.classList.remove('collapsed');
                } else {
                    spectrumToggle.classList.add('collapsed');
                    spectrumContent.classList.add('collapsed');
                }
            });
            
            // Populate library dropdown
            function populateSpectrumLibraries() {
                spectrumLibrarySelect.innerHTML = '<option value="">-- Choose a Library --</option>';
                
                // Add public libraries from manifest
                if (libraryManifest && libraryManifest.length > 0) {
                    libraryManifest.forEach(lib => {
                        const option = document.createElement('option');
                        option.value = lib.id;
                        option.textContent = lib.name;
                        spectrumLibrarySelect.appendChild(option);
                    });
                }
                
                // Add custom libraries
                const customLibs = Object.keys(libs).filter(libId => {
                    // Check if it's a custom library (not in manifest)
                    return !libraryManifest.some(ml => ml.id === libId);
                });
                
                if (customLibs.length > 0) {
                    customLibs.forEach(libId => {
                        if (libNames[libId]) {
                            const option = document.createElement('option');
                            option.value = libId;
                            option.textContent = `${libNames[libId]} (Custom)`;
                            spectrumLibrarySelect.appendChild(option);
                        }
                    });
                }
            }
            
            // Convert Lab to HSL hue
            function labToHue(L, a, b) {
                // Convert Lab to RGB first
                const rgb = lab2rgbValues(L, a, b);
                return rgbToHue(rgb.r, rgb.g, rgb.b);
            }
            
            function lab2rgbValues(L, a, b) {
                // Simple Lab to RGB conversion (approximate)
                let y = (L + 16) / 116;
                let x = a / 500 + y;
                let z = y - b / 200;
                
                x = 0.95047 * ((x * x * x > 0.008856) ? x * x * x : (x - 16/116) / 7.787);
                y = 1.00000 * ((y * y * y > 0.008856) ? y * y * y : (y - 16/116) / 7.787);
                z = 1.08883 * ((z * z * z > 0.008856) ? z * z * z : (z - 16/116) / 7.787);
                
                let r = x *  3.2406 + y * -1.5372 + z * -0.4986;
                let g = x * -0.9689 + y *  1.8758 + z *  0.0415;
                let bl = x *  0.0557 + y * -0.2040 + z *  1.0570;
                
                r = (r > 0.0031308) ? (1.055 * Math.pow(r, 1/2.4) - 0.055) : 12.92 * r;
                g = (g > 0.0031308) ? (1.055 * Math.pow(g, 1/2.4) - 0.055) : 12.92 * g;
                bl = (bl > 0.0031308) ? (1.055 * Math.pow(bl, 1/2.4) - 0.055) : 12.92 * bl;
                
                return {
                    r: Math.max(0, Math.min(255, Math.round(r * 255))),
                    g: Math.max(0, Math.min(255, Math.round(g * 255))),
                    b: Math.max(0, Math.min(255, Math.round(bl * 255)))
                };
            }
            
            function rgbToHue(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const delta = max - min;
                
                if (delta === 0) return 0;
                
                let hue;
                if (max === r) {
                    hue = ((g - b) / delta) % 6;
                } else if (max === g) {
                    hue = (b - r) / delta + 2;
                } else {
                    hue = (r - g) / delta + 4;
                }
                
                hue = Math.round(hue * 60);
                if (hue < 0) hue += 360;
                
                return hue;
            }
            
            // Calculate saturation (chroma) from Lab
            function labToChroma(a, b) {
                return Math.sqrt(a * a + b * b);
            }
            
            // Load and sort library colors by hue, saturation, and lightness
            function loadSpectrumLibrary(libraryId) {
                const library = libs[libraryId];
                if (!library || library.length === 0) {
                    spectrumStatus.textContent = 'Library not loaded or empty';
                    return;
                }
                
                currentSpectrumLibrary = libraryId;
                currentColorIndex = 0;
                
                // Calculate hue, chroma for each color
                const processedColors = library.map(color => {
                    const chroma = labToChroma(color.a, color.b);
                    const hue = labToHue(color.L, color.a, color.b);
                    return {
                        ...color,
                        hue: hue,
                        chroma: chroma,
                        isGray: chroma < 15 // Low chroma = gray/neutral
                    };
                });
                
                // Sort: grays first (by lightness), then by hue, then by lightness within hue
                sortedSpectrumColors = processedColors.sort((a, b) => {
                    // Grays first, sorted by lightness
                    if (a.isGray && b.isGray) {
                        return a.L - b.L; // Light to dark
                    }
                    if (a.isGray) return -1;
                    if (b.isGray) return 1;
                    
                    // Sort chromatic colors by hue first
                    const hueDiff = a.hue - b.hue;
                    if (Math.abs(hueDiff) > 5) return hueDiff;
                    
                    // Within same hue, sort by lightness (light to dark)
                    const lightDiff = b.L - a.L;
                    if (Math.abs(lightDiff) > 5) return lightDiff;
                    
                    // Then by saturation (vibrant to muted)
                    return b.chroma - a.chroma;
                });
                
                spectrumTitle.textContent = `${libNames[libraryId]} Color Spectrum`;
                spectrumDisplay.style.display = 'block';
                
                drawSpectrumCanvas();
                displaySpectrumColors();
            }
            
            // Draw canvas with color gradient
            function drawSpectrumCanvas() {
                const ctx = spectrumCanvas.getContext('2d');
                const width = spectrumCanvas.width;
                const height = spectrumCanvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw each color as a vertical bar
                const barWidth = width / sortedSpectrumColors.length;
                
                sortedSpectrumColors.forEach((color, index) => {
                    const rgb = lab2rgbValues(color.L, color.a, color.b);
                    ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    ctx.fillRect(index * barWidth, 0, Math.ceil(barWidth), height);
                });
                
                // Draw indicator for current page
                const startX = (currentColorIndex / sortedSpectrumColors.length) * width;
                const endIndex = Math.min(currentColorIndex + COLORS_PER_PAGE, sortedSpectrumColors.length);
                const rangeWidth = ((endIndex - currentColorIndex) / sortedSpectrumColors.length) * width;
                
                ctx.strokeStyle = '#0065a3';
                ctx.lineWidth = 3;
                ctx.strokeRect(startX, 0, rangeWidth, height);
            }
            
            // Display colors for current page
            function displaySpectrumColors() {
                const endIndex = Math.min(currentColorIndex + COLORS_PER_PAGE, sortedSpectrumColors.length);
                const colorsToShow = sortedSpectrumColors.slice(currentColorIndex, endIndex);
                
                spectrumColorsGrid.innerHTML = '';
                spectrumColorsGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(80px, 1fr))';
                
                if (colorsToShow.length === 0) {
                    spectrumColorsGrid.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #6b7280; padding: 40px;">No colors to display</div>';
                    spectrumStatus.textContent = '';
                    return;
                }
                
                // Group colors by type
                let lastGroupType = null;
                let groupTitle = null;
                
                colorsToShow.forEach((color, index) => {
                    const actualIndex = currentColorIndex + index;
                    const prevColor = actualIndex > 0 ? sortedSpectrumColors[actualIndex - 1] : null;
                    
                    // Check if we need a new group header
                    let newGroup = false;
                    if (!prevColor || (prevColor.isGray !== color.isGray)) {
                        newGroup = true;
                        groupTitle = color.isGray ? 'Neutrals & Grays' : getHueRangeName(color.hue) + 's';
                    } else if (!color.isGray && prevColor && Math.abs(color.hue - prevColor.hue) > 30) {
                        newGroup = true;
                        groupTitle = getHueRangeName(color.hue) + 's';
                    }
                    
                    // Add group header if needed
                    if (newGroup && index === 0) {
                        const header = document.createElement('div');
                        header.style.cssText = `
                            grid-column: 1 / -1;
                            font-weight: 700;
                            color: #1f2937;
                            font-size: 14px;
                            text-transform: uppercase;
                            letter-spacing: 0.5px;
                            padding: 12px 0 8px 0;
                            border-bottom: 2px solid #e2e8f0;
                            margin-bottom: 8px;
                        `;
                        header.textContent = groupTitle;
                        spectrumColorsGrid.appendChild(header);
                    }
                    
                    const tile = document.createElement('div');
                    tile.style.cssText = `
                        background: ${lab2rgb(color.L, color.a, color.b)};
                        border: 2px solid #e2e8f0;
                        border-radius: 6px;
                        cursor: pointer;
                        transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
                        display: flex;
                        flex-direction: column;
                        justify-content: flex-end;
                        padding: 6px 4px;
                        min-height: 80px;
                        position: relative;
                    `;
                    
                    // Determine text color based on luminance
                    const textColor = color.L > 60 ? '#1f2937' : '#ffffff';
                    const textShadow = color.L > 60 ? '0 1px 1px rgba(255,255,255,0.8)' : '0 1px 2px rgba(0,0,0,0.5)';
                    
                    // Convert Crayola color names to lowercase
                    let displayColorName = color.name;
                    if (color.library === 'crayola') {
                        displayColorName = displayColorName.toLowerCase();
                    }
                    
                    tile.innerHTML = `
                        <div style="color: ${textColor}; font-size: 10px; font-weight: 600; text-align: center; text-shadow: ${textShadow}; line-height: 1.2;">
                            ${displayColorName.length > 20 ? displayColorName.substring(0, 18) + '...' : displayColorName}
                        </div>
                    `;
                    
                    tile.addEventListener('mouseover', () => {
                        tile.style.transform = 'translateY(-2px) scale(1.05)';
                        tile.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
                        tile.style.borderColor = '#0065a3';
                        tile.style.zIndex = '10';
                    });
                    
                    tile.addEventListener('mouseout', () => {
                        tile.style.transform = '';
                        tile.style.boxShadow = '';
                        tile.style.borderColor = '#e2e8f0';
                        tile.style.zIndex = '';
                    });
                    
                    tile.addEventListener('click', () => {
                        const displayColor = window.getComputedStyle(tile).backgroundColor;
                        showColorModal({
                            name: color.name,
                            library: color.library,
                            libraryName: color.libraryName || libNames[currentSpectrumLibrary],
                            L: color.L,
                            a: color.a,
                            b: color.b,
                            amazon_link: color.amazon_link || null,
                            manufacturer_link: color.manufacturer_link || null,
                            hex: color.hex || null,
                            rgb_r: color.rgb_r,
                            rgb_g: color.rgb_g,
                            rgb_b: color.rgb_b,
                            cmyk_c: color.cmyk_c,
                            cmyk_m: color.cmyk_m,
                            lab_calculated: color.lab_calculated,
                            spectral: color.spectral,
                            cmyk_y: color.cmyk_y,
                            cmyk_k: color.cmyk_k,
                            spectral: color.spectral || null,
                            displayColor
                        });
                    });
                    
                    spectrumColorsGrid.appendChild(tile);
                });
                
                // Update status
                const totalColors = sortedSpectrumColors.length;
                const groupName = getCurrentGroupName();
                spectrumStatus.textContent = `Showing colors ${currentColorIndex + 1}-${endIndex} of ${totalColors} | ${groupName}`;
                
                // Update button states
                spectrumPrevBtn.disabled = currentColorIndex === 0;
                spectrumNextBtn.disabled = endIndex >= totalColors;
                spectrumPrevBtn.style.opacity = currentColorIndex === 0 ? '0.5' : '1';
                spectrumNextBtn.style.opacity = endIndex >= totalColors ? '0.5' : '1';
            }
            
            function getCurrentGroupName() {
                const currentColor = sortedSpectrumColors[currentColorIndex];
                if (!currentColor) return '';
                if (currentColor.isGray) return 'Neutrals & Grays';
                return getHueRangeName(currentColor.hue) + 's';
            }
            
            function getHueRangeName(hue) {
                if (hue >= 345 || hue < 15) return 'Red';
                if (hue >= 15 && hue < 45) return 'Red-Orange';
                if (hue >= 45 && hue < 75) return 'Orange';
                if (hue >= 75 && hue < 105) return 'Yellow';
                if (hue >= 105 && hue < 135) return 'Yellow-Green';
                if (hue >= 135 && hue < 165) return 'Green';
                if (hue >= 165 && hue < 195) return 'Cyan';
                if (hue >= 195 && hue < 255) return 'Blue';
                if (hue >= 255 && hue < 285) return 'Purple';
                if (hue >= 285 && hue < 315) return 'Magenta';
                if (hue >= 315 && hue < 345) return 'Pink';
                return 'Red';
            }
            
            // Navigation buttons
            spectrumPrevBtn.addEventListener('click', () => {
                currentColorIndex = Math.max(0, currentColorIndex - COLORS_PER_PAGE);
                drawSpectrumCanvas();
                displaySpectrumColors();
            });
            
            spectrumNextBtn.addEventListener('click', () => {
                const maxIndex = sortedSpectrumColors.length - COLORS_PER_PAGE;
                currentColorIndex = Math.min(maxIndex, currentColorIndex + COLORS_PER_PAGE);
                if (currentColorIndex < 0) currentColorIndex = 0;
                drawSpectrumCanvas();
                displaySpectrumColors();
            });
            
            // Library selection change
            spectrumLibrarySelect.addEventListener('change', (e) => {
                const libraryId = e.target.value;
                if (libraryId) {
                    loadSpectrumLibrary(libraryId);
                } else {
                    spectrumDisplay.style.display = 'none';
                }
            });
            
            // Canvas click to jump to color position
            spectrumCanvas.addEventListener('click', (e) => {
                const rect = spectrumCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickPercent = x / rect.width;
                const clickIndex = Math.floor(clickPercent * sortedSpectrumColors.length);
                
                if (clickIndex >= 0 && clickIndex < sortedSpectrumColors.length) {
                    // Jump to page containing this color
                    currentColorIndex = Math.floor(clickIndex / COLORS_PER_PAGE) * COLORS_PER_PAGE;
                    drawSpectrumCanvas();
                    displaySpectrumColors();
                }
            });
            
            // Populate libraries after they're loaded
            setTimeout(populateSpectrumLibraries, 2000);

            /* ─────────────────────
               Unified Color Libraries Browser
               ───────────────────── */
            
            const librariesToggle = document.getElementById('cmw-libraries-toggle');
            const librariesContent = document.getElementById('cmw-libraries-content');
            const librariesSelector = document.getElementById('cmw-libraries-selector');
            const librariesSortContainer = document.getElementById('cmw-libraries-sort-container');
            const librariesSortSelect = document.getElementById('cmw-libraries-sort');
            const librariesDisplay = document.getElementById('cmw-libraries-display');
            const librariesCanvas = document.getElementById('cmw-libraries-canvas');
            const librariesColorsGrid = document.getElementById('cmw-libraries-colors');
            const librariesTitle = document.getElementById('cmw-libraries-title');
            const librariesStatus = document.getElementById('cmw-libraries-status');
            const librariesPrevBtn = document.getElementById('cmw-libraries-prev');
            const librariesNextBtn = document.getElementById('cmw-libraries-next');
            const librariesPrevBtnBottom = document.getElementById('cmw-libraries-prev-bottom');
            const librariesNextBtnBottom = document.getElementById('cmw-libraries-next-bottom');
            const librariesEditModeBtn = document.getElementById('cmw-libraries-edit-mode');
            const librariesExportBtn = document.getElementById('cmw-libraries-export');
            const librariesImportBtn = document.getElementById('cmw-libraries-import');
            const librariesDeleteBtn = document.getElementById('cmw-libraries-delete-btn');
            
            let currentLibrariesLib = null;
            let sortedLibrariesColors = [];
            let currentLibrariesIndex = 0;
            let librariesEditMode = false;
            let librariesProcessedColors = []; // Store processed colors for re-sorting
            const LIBRARIES_COLORS_PER_PAGE = 48;
            
            // Toggle collapsible
            librariesToggle.addEventListener('click', () => {
                librariesToggle.classList.toggle('collapsed');
                librariesContent.classList.toggle('collapsed');
            });
            
            // Populate library selector (both public and custom libraries)
            function populateLibrariesSelector() {
                librariesSelector.innerHTML = '<option value="">-- Choose a Library --</option>';
                
                // Add public libraries in optgroup
                if (libraryManifest && libraryManifest.length > 0) {
                    const publicGroup = document.createElement('optgroup');
                    publicGroup.label = 'Public Libraries';
                    
                    libraryManifest.forEach(lib => {
                        if (libs[lib.id] && libs[lib.id].length > 0) {
                            const option = document.createElement('option');
                            option.value = lib.id;
                            option.textContent = `${lib.name} (${libs[lib.id].length})`;
                            publicGroup.appendChild(option);
                        }
                    });
                    
                    if (publicGroup.children.length > 0) {
                        librariesSelector.appendChild(publicGroup);
                    }
                }
                
                // Add custom libraries in optgroup (allow empty libraries)
                if (Object.keys(customLibraries).length > 0) {
                    const customGroup = document.createElement('optgroup');
                    customGroup.label = 'Custom Libraries';
                    
                    Object.keys(customLibraries).forEach(libId => {
                        const lib = customLibraries[libId];
                        if (lib) {
                            const option = document.createElement('option');
                            option.value = libId;
                            const colorCount = lib.colors ? lib.colors.length : 0;
                            option.textContent = `${lib.name} (${colorCount})`;
                            option.dataset.isCustom = 'true';
                            customGroup.appendChild(option);
                        }
                    });
                    
                    if (customGroup.children.length > 0) {
                        librariesSelector.appendChild(customGroup);
                    }
                }
            }
            
            
            // Library selection handler
            librariesSelector.addEventListener('change', () => {
                const libId = librariesSelector.value;
                const selectedOption = librariesSelector.options[librariesSelector.selectedIndex];
                const isCustom = selectedOption.dataset.isCustom === 'true';
                
                // Allow empty libraries if they're custom (so user can add colors)
                if (!libId) {
                    librariesDisplay.style.display = 'none';
                    librariesSortContainer.style.display = 'none';
                    const addForm = document.getElementById('cmw-libraries-add-form');
                    if (addForm) addForm.style.display = 'none';
                    return;
                }
                
                // Show sort dropdown when library is selected
                librariesSortContainer.style.display = 'flex';
                
                // For non-custom libraries, check if they have colors
                if (!isCustom && (!libs[libId] || libs[libId].length === 0)) {
                    librariesDisplay.style.display = 'none';
                    const addForm = document.getElementById('cmw-libraries-add-form');
                    if (addForm) addForm.style.display = 'none';
                    return;
                }
                
                // Initialize libs[libId] if it doesn't exist (for empty custom libraries)
                if (!libs[libId]) {
                    libs[libId] = [];
                }
                
                currentLibrariesLib = libId;
                currentLibrariesIndex = 0;
                librariesEditMode = false;
                
                // Show/hide library action buttons and add form
                const addForm = document.getElementById('cmw-libraries-add-form');
                if (isCustom) {
                    // Custom libraries: show edit, export, import, delete, and add form
                    librariesEditModeBtn.style.display = 'inline-block';
                    librariesExportBtn.style.display = 'inline-block';
                    librariesImportBtn.style.display = 'inline-block';
                    librariesDeleteBtn.style.display = 'inline-block';
                    if (addForm) {
                        addForm.style.display = 'block';
                        
                        // Initialize form: reset to lab format and show only lab inputs
                        const formatSelect = document.getElementById('cmw-libraries-format');
                        if (formatSelect) formatSelect.value = 'lab';
                        
                        ['hex', 'lab', 'rgb', 'cmyk'].forEach(fmt => {
                            const group = document.getElementById(`cmw-libraries-${fmt}-inputs`);
                            if (group) {
                                if (fmt === 'lab') {
                                    group.style.display = 'flex';
                                } else {
                                    group.style.display = 'none';
                                }
                            }
                        });
                        
                        // Clear all inputs
                        document.getElementById('cmw-libraries-color-name').value = '';
                        document.getElementById('cmw-libraries-hex').value = '';
                        ['l', 'a', 'b'].forEach(c => {
                            document.getElementById(`cmw-libraries-lab-${c}`).value = '';
                        });
                        ['r', 'g', 'b'].forEach(c => {
                            document.getElementById(`cmw-libraries-rgb-${c}`).value = '';
                        });
                        ['c', 'm', 'y', 'k'].forEach(c => {
                            document.getElementById(`cmw-libraries-cmyk-${c}`).value = '';
                        });
                        
                        // Reset preview
                        const preview = document.getElementById('cmw-libraries-preview-swatch');
                        if (preview) {
                            preview.style.backgroundColor = '#cbd5e1';
                            preview.classList.remove('valid');
                        }
                    }
                } else {
                    // Public libraries: show export only (read-only)
                    librariesEditModeBtn.style.display = 'none';
                    librariesExportBtn.style.display = 'inline-block';
                    librariesImportBtn.style.display = 'none';
                    librariesDeleteBtn.style.display = 'none';
                    if (addForm) addForm.style.display = 'none';
                }
                
                // Update edit mode button text
                librariesEditModeBtn.innerHTML = `
                    <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; display: inline-block; vertical-align: middle; margin-right: 4px;">
                        <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                    </svg>
                    Edit
                `;
                librariesEditModeBtn.style.background = '';
                
                // Process colors with calculated properties
                librariesProcessedColors = libs[libId].map(color => {
                    const hue = Math.atan2(color.b, color.a) * 180 / Math.PI;
                    const adjustedHue = hue < 0 ? hue + 360 : hue;
                    const chroma = Math.sqrt(color.a * color.a + color.b * color.b);
                    
                    return {
                        ...color,
                        hue: adjustedHue,
                        chroma: chroma,
                        isGray: chroma < 15
                    };
                });
                
                // Apply initial sort
                applyLibrariesSort();
                
                const libName = libNames[libId] || (customLibraries[libId]?.name) || libId;
                librariesTitle.textContent = libName;
                librariesDisplay.style.display = 'block';
                
                drawLibrariesCanvas();
                displayLibrariesColors();
            });
            
            // Apply sorting based on selected method
            function applyLibrariesSort() {
                const sortMethod = librariesSortSelect.value;
                
                sortedLibrariesColors = [...librariesProcessedColors].sort((a, b) => {
                    switch(sortMethod) {
                        case 'hue-lightness':
                            // Grays first, sorted by lightness (dark to light)
                            if (a.isGray && b.isGray) return a.L - b.L;
                            if (a.isGray) return -1;
                            if (b.isGray) return 1;
                            
                            // Group by hue ranges (30 degree ranges)
                            const hueRangeA = Math.floor(a.hue / 30);
                            const hueRangeB = Math.floor(b.hue / 30);
                            
                            if (hueRangeA !== hueRangeB) {
                                return a.hue - b.hue;
                            }
                            
                            // Within hue range, sort by lightness (light to dark)
                            const lightnessDiff = b.L - a.L;
                            if (Math.abs(lightnessDiff) > 1) {
                                return lightnessDiff;
                            }
                            
                            // If lightness similar, sort by chroma
                            return a.chroma - b.chroma;
                        
                        case 'hue-saturation':
                            // Grays first, sorted by lightness
                            if (a.isGray && b.isGray) return a.L - b.L;
                            if (a.isGray) return -1;
                            if (b.isGray) return 1;
                            
                            // Group by hue ranges
                            const hueRangeA2 = Math.floor(a.hue / 30);
                            const hueRangeB2 = Math.floor(b.hue / 30);
                            
                            if (hueRangeA2 !== hueRangeB2) {
                                return a.hue - b.hue;
                            }
                            
                            // Within hue range, sort by chroma (low to high)
                            return a.chroma - b.chroma;
                        
                        case 'lightness':
                            // Simple lightness sort (light to dark)
                            return b.L - a.L;
                        
                        case 'saturation':
                            // Chroma/saturation sort (low to high)
                            return a.chroma - b.chroma;
                        
                        case 'hex':
                            // Sort by hex value (#000000 to #FFFFFF)
                            // Convert Lab to RGB to hex for both colors
                            const rgbA = lab2rgbValues(a.L, a.a, a.b);
                            const rgbB = lab2rgbValues(b.L, b.a, b.b);
                            
                            // Ensure values are integers in range 0-255
                            const rA = Math.max(0, Math.min(255, Math.floor(rgbA.r)));
                            const gA = Math.max(0, Math.min(255, Math.floor(rgbA.g)));
                            const bA = Math.max(0, Math.min(255, Math.floor(rgbA.b)));
                            
                            const rB = Math.max(0, Math.min(255, Math.floor(rgbB.r)));
                            const gB = Math.max(0, Math.min(255, Math.floor(rgbB.g)));
                            const bB = Math.max(0, Math.min(255, Math.floor(rgbB.b)));
                            
                            // Convert RGB to hex number (RRGGBB format)
                            const hexA = (rA * 65536) + (gA * 256) + bA;
                            const hexB = (rB * 65536) + (gB * 256) + bB;
                            
                            return hexA - hexB;
                        
                        case 'name':
                            // Alphabetical by name
                            return a.name.localeCompare(b.name);
                        
                        case 'chroma-hue':
                            // Group by chroma ranges, then by hue
                            const chromaRangeA = Math.floor(a.chroma / 20);
                            const chromaRangeB = Math.floor(b.chroma / 20);
                            
                            if (chromaRangeA !== chromaRangeB) {
                                return a.chroma - b.chroma;
                            }
                            
                            // Within chroma range, sort by hue
                            return a.hue - b.hue;
                        
                        default:
                            return 0;
                    }
                });
                
                // Reset to first page
                currentLibrariesIndex = 0;
            }
            
            // Sort change handler
            librariesSortSelect.addEventListener('change', () => {
                if (currentLibrariesLib && librariesProcessedColors.length > 0) {
                    applyLibrariesSort();
                    drawLibrariesCanvas();
                    displayLibrariesColors();
                }
            });
            
            // Draw spectrum canvas
            function drawLibrariesCanvas() {
                const canvas = librariesCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                
                const barWidth = width / sortedLibrariesColors.length;
                
                sortedLibrariesColors.forEach((color, index) => {
                    const rgb = lab2rgbValues(color.L, color.a, color.b);
                    ctx.fillStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    ctx.fillRect(index * barWidth, 0, Math.ceil(barWidth), height);
                });
                
                // Draw indicator for current page
                const startX = (currentLibrariesIndex / sortedLibrariesColors.length) * width;
                const endIndex = Math.min(currentLibrariesIndex + LIBRARIES_COLORS_PER_PAGE, sortedLibrariesColors.length);
                const rangeWidth = ((endIndex - currentLibrariesIndex) / sortedLibrariesColors.length) * width;
                
                ctx.strokeStyle = '#0065a3';
                ctx.lineWidth = 3;
                ctx.strokeRect(startX, 0, rangeWidth, height);
            }
            
            // Display colors for current page
            function displayLibrariesColors() {
                const endIndex = Math.min(currentLibrariesIndex + LIBRARIES_COLORS_PER_PAGE, sortedLibrariesColors.length);
                const colorsToShow = sortedLibrariesColors.slice(currentLibrariesIndex, endIndex);
                
                librariesColorsGrid.innerHTML = '';
                
                colorsToShow.forEach((color) => {
                    const tile = document.createElement('div');
                    tile.style.cssText = `
                        background: ${lab2rgb(color.L, color.a, color.b)};
                        border: 2px solid #e2e8f0;
                        border-radius: 8px;
                        padding: 12px 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        display: flex;
                        flex-direction: column;
                        justify-content: flex-end;
                        min-height: 100px;
                        position: relative;
                    `;
                    
                    const textColor = color.L > 60 ? '#1f2937' : '#ffffff';
                    const textShadow = color.L > 60 ? '0 1px 1px rgba(255,255,255,0.8)' : '0 1px 2px rgba(0,0,0,0.5)';
                    
                    // Convert Crayola color names to lowercase
                    let displayColorName = color.name;
                    if (color.library === 'crayola') {
                        displayColorName = displayColorName.toLowerCase();
                    }
                    
                    tile.innerHTML = `
                        <div style="color: ${textColor}; font-size: 10px; font-weight: 600; text-align: center; text-shadow: ${textShadow}; line-height: 1.2;">
                            ${displayColorName.length > 20 ? displayColorName.substring(0, 18) + '...' : displayColorName}
                        </div>
                    `;
                    
                    // Edit mode: show edit and delete buttons
                    if (librariesEditMode) {
                        // Edit button (top left)
                        const editBtn = document.createElement('div');
                        editBtn.innerHTML = `
                            <svg viewBox="0 0 24 24" style="width: 14px; height: 14px; fill: none; stroke: white; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                            </svg>
                        `;
                        editBtn.style.cssText = `
                            position: absolute;
                            top: 4px;
                            left: 4px;
                            width: 24px;
                            height: 24px;
                            background: #0065a3;
                            color: white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            transition: all 0.2s;
                        `;
                        editBtn.title = 'Edit this color';
                        editBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            editLibraryColor(color);
                        });
                        editBtn.addEventListener('mouseover', () => {
                            editBtn.style.background = '#004d7a';
                            editBtn.style.transform = 'scale(1.1)';
                        });
                        editBtn.addEventListener('mouseout', () => {
                            editBtn.style.background = '#0065a3';
                            editBtn.style.transform = 'scale(1)';
                        });
                        tile.appendChild(editBtn);
                        
                        // Delete button (top right)
                        const deleteBtn = document.createElement('div');
                        deleteBtn.innerHTML = `
                            <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: white; stroke-width: 2.5; stroke-linecap: round; stroke-linejoin: round;">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        `;
                        deleteBtn.style.cssText = `
                            position: absolute;
                            top: 4px;
                            right: 4px;
                            width: 24px;
                            height: 24px;
                            background: #ef4444;
                            color: white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            cursor: pointer;
                            transition: all 0.2s;
                        `;
                        deleteBtn.title = 'Delete this color';
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            deleteLibraryColor(color);
                        });
                        deleteBtn.addEventListener('mouseover', () => {
                            deleteBtn.style.background = '#dc2626';
                            deleteBtn.style.transform = 'scale(1.1)';
                        });
                        deleteBtn.addEventListener('mouseout', () => {
                            deleteBtn.style.background = '#ef4444';
                            deleteBtn.style.transform = 'scale(1)';
                        });
                        tile.appendChild(deleteBtn);
                    }
                    
                    tile.addEventListener('mouseover', () => {
                        if (!librariesEditMode) {
                            tile.style.transform = 'translateY(-2px) scale(1.05)';
                            tile.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
                            tile.style.borderColor = '#0065a3';
                            tile.style.zIndex = '10';
                        }
                    });
                    
                    tile.addEventListener('mouseout', () => {
                        tile.style.transform = '';
                        tile.style.boxShadow = '';
                        tile.style.borderColor = '#e2e8f0';
                        tile.style.zIndex = '';
                    });
                    
                    tile.addEventListener('click', () => {
                        if (!librariesEditMode) {
                            const displayColor = window.getComputedStyle(tile).backgroundColor;
                            showColorModal({
                                name: color.name,
                                library: color.library,
                                libraryName: color.libraryName || libNames[currentLibrariesLib],
                                L: color.L,
                                a: color.a,
                                b: color.b,
                                amazon_link: color.amazon_link || null,
                                manufacturer_link: color.manufacturer_link || null,
                                hex: color.hex || null,
                                rgb_r: color.rgb_r,
                                rgb_g: color.rgb_g,
                                rgb_b: color.rgb_b,
                                cmyk_c: color.cmyk_c,
                                lab_calculated: color.lab_calculated,
                                spectral: color.spectral,
                                cmyk_m: color.cmyk_m,
                                cmyk_y: color.cmyk_y,
                                cmyk_k: color.cmyk_k,
                                spectral: color.spectral || null,
                                displayColor
                            });
                        }
                    });
                    
                    librariesColorsGrid.appendChild(tile);
                });
                
                // Update status with smart description
                const totalColors = sortedLibrariesColors.length;
                const groupName = getSmartLibrariesGroupName(colorsToShow);
                librariesStatus.textContent = `Showing ${currentLibrariesIndex + 1}-${endIndex} of ${totalColors} | ${groupName}`;
                
                // Update button states (both top and bottom)
                librariesPrevBtn.disabled = currentLibrariesIndex === 0;
                librariesNextBtn.disabled = endIndex >= totalColors;
                librariesPrevBtn.style.opacity = currentLibrariesIndex === 0 ? '0.5' : '1';
                librariesNextBtn.style.opacity = endIndex >= totalColors ? '0.5' : '1';
                
                librariesPrevBtnBottom.disabled = currentLibrariesIndex === 0;
                librariesNextBtnBottom.disabled = endIndex >= totalColors;
                librariesPrevBtnBottom.style.opacity = currentLibrariesIndex === 0 ? '0.5' : '1';
                librariesNextBtnBottom.style.opacity = endIndex >= totalColors ? '0.5' : '1';
            }
            
            // Get smart group name based on sort method and actual colors displayed
            function getSmartLibrariesGroupName(colorsToShow) {
                if (!colorsToShow || colorsToShow.length === 0) return 'No colors';
                
                const sortMethod = librariesSortSelect.value;
                
                switch(sortMethod) {
                    case 'hue-lightness':
                    case 'hue-saturation':
                    case 'chroma-hue': {
                        // Analyze hue distribution
                        const hueGroups = {};
                        let grayCount = 0;
                        
                        colorsToShow.forEach(color => {
                            if (color.isGray) {
                                grayCount++;
                            } else {
                                const hueName = getHueRangeName(color.hue);
                                hueGroups[hueName] = (hueGroups[hueName] || 0) + 1;
                            }
                        });
                        
                        const hueNames = Object.keys(hueGroups);
                        
                        if (grayCount === colorsToShow.length) {
                            return 'Neutrals & Grays';
                        } else if (hueNames.length === 1) {
                            return hueNames[0] + 's';
                        } else if (hueNames.length === 2) {
                            return hueNames.join(' & ') + 's';
                        } else if (hueNames.length > 2) {
                            return 'Mixed Hues';
                        }
                        return 'Colors';
                    }
                    
                    case 'lightness': {
                        // Analyze lightness range
                        const avgL = colorsToShow.reduce((sum, c) => sum + c.L, 0) / colorsToShow.length;
                        if (avgL < 30) return 'Very Dark';
                        if (avgL < 50) return 'Dark';
                        if (avgL < 70) return 'Mid-tone';
                        if (avgL < 85) return 'Light';
                        return 'Very Light';
                    }
                    
                    case 'saturation': {
                        // Analyze saturation (chroma)
                        const avgChroma = colorsToShow.reduce((sum, c) => {
                            return sum + Math.sqrt(c.a * c.a + c.b * c.b);
                        }, 0) / colorsToShow.length;
                        
                        if (avgChroma < 10) return 'Neutrals';
                        if (avgChroma < 30) return 'Muted';
                        if (avgChroma < 60) return 'Moderate';
                        return 'Vivid';
                    }
                    
                    case 'name': {
                        // Show alphabetical range
                        const firstLetter = colorsToShow[0].name.charAt(0).toUpperCase();
                        const lastLetter = colorsToShow[colorsToShow.length - 1].name.charAt(0).toUpperCase();
                        if (firstLetter === lastLetter) {
                            return `Names: ${firstLetter}`;
                        }
                        return `Names: ${firstLetter}-${lastLetter}`;
                    }
                    
                    case 'hex': {
                        // Show hex range
                        const firstHex = getHexValueFromLab(colorsToShow[0].L, colorsToShow[0].a, colorsToShow[0].b);
                        const lastHex = getHexValueFromLab(colorsToShow[colorsToShow.length - 1].L, colorsToShow[colorsToShow.length - 1].a, colorsToShow[colorsToShow.length - 1].b);
                        return `Hex: #${firstHex.substring(0, 3)}...${lastHex.substring(3)}`;
                    }
                    
                    default:
                        return 'Colors';
                }
            }
            
            // Edit color from custom library
            function editLibraryColor(color) {
                if (!currentLibrariesLib || !customLibraries[currentLibrariesLib]) return;
                
                // Create modal dialog
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 24px;
                    max-width: 400px;
                    width: 90%;
                    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
                `;
                
                modalContent.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #1f2937; font-size: 20px;">Edit Color</h3>
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #374151;">Color Name:</label>
                        <input type="text" id="edit-color-name" value="${color.name}" style="width: 100%; padding: 10px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px;">
                    </div>
                    <div style="margin-bottom: 16px;">
                        <label style="display: block; margin-bottom: 6px; font-weight: 600; color: #374151;">Lab Values:</label>
                        <div style="display: flex; gap: 8px;">
                            <div style="flex: 1;">
                                <label style="font-size: 12px; color: #6b7280;">L*</label>
                                <input type="number" id="edit-color-l" value="${color.L.toFixed(2)}" min="0" max="100" step="0.1" style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; font-family: monospace;">
                            </div>
                            <div style="flex: 1;">
                                <label style="font-size: 12px; color: #6b7280;">a*</label>
                                <input type="number" id="edit-color-a" value="${color.a.toFixed(2)}" min="-128" max="127" step="0.1" style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; font-family: monospace;">
                            </div>
                            <div style="flex: 1;">
                                <label style="font-size: 12px; color: #6b7280;">b*</label>
                                <input type="number" id="edit-color-b" value="${color.b.toFixed(2)}" min="-128" max="127" step="0.1" style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 14px; font-family: monospace;">
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end;">
                        <button id="edit-cancel-btn" style="padding: 10px 20px; border: 2px solid #e2e8f0; background: white; color: #374151; border-radius: 6px; font-weight: 600; cursor: pointer;">Cancel</button>
                        <button id="edit-save-btn" style="padding: 10px 20px; border: none; background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%); color: white; border-radius: 6px; font-weight: 600; cursor: pointer;">Save Changes</button>
                    </div>
                `;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Cancel button
                document.getElementById('edit-cancel-btn').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                // Click outside to close
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        document.body.removeChild(modal);
                    }
                });
                
                // Save button
                document.getElementById('edit-save-btn').addEventListener('click', () => {
                    const newName = document.getElementById('edit-color-name').value.trim();
                    const newL = parseFloat(document.getElementById('edit-color-l').value);
                    const newA = parseFloat(document.getElementById('edit-color-a').value);
                    const newB = parseFloat(document.getElementById('edit-color-b').value);
                    
                    if (!newName) {
                        alert('Please enter a color name');
                        return;
                    }
                    
                    if (isNaN(newL) || isNaN(newA) || isNaN(newB)) {
                        alert('Please enter valid Lab values');
                        return;
                    }
                    
                    // Find and update the color in custom library
                    const colorIndex = customLibraries[currentLibrariesLib].colors.findIndex(c => 
                        c.name === color.name && c.L === color.L && c.a === color.a && c.b === color.b
                    );
                    
                    if (colorIndex !== -1) {
                        customLibraries[currentLibrariesLib].colors[colorIndex] = {
                            name: newName,
                            L: newL,
                            a: newA,
                            b: newB
                        };
                    }
                    
                    // Update in libs array
                    const libColorIndex = libs[currentLibrariesLib].findIndex(c => 
                        c.name === color.name && c.L === color.L && c.a === color.a && c.b === color.b
                    );
                    
                    if (libColorIndex !== -1) {
                        libs[currentLibrariesLib][libColorIndex] = {
                            name: newName,
                            L: newL,
                            a: newA,
                            b: newB,
                            libraryName: customLibraries[currentLibrariesLib].name
                        };
                    }
                    
                    saveCustomLibraries();
                    
                    // Refresh display
                    librariesSelector.dispatchEvent(new Event('change'));
                    
                    // Close modal
                    document.body.removeChild(modal);
                });
            }
            
            // Delete color from custom library
            function deleteLibraryColor(color) {
                if (!currentLibrariesLib || !customLibraries[currentLibrariesLib]) return;
                
                if (!confirm(`Delete "${color.name}" from this library?`)) return;
                
                // Remove from custom library
                customLibraries[currentLibrariesLib].colors = customLibraries[currentLibrariesLib].colors.filter(c => 
                    !(c.name === color.name && c.L === color.L && c.a === color.a && c.b === color.b)
                );
                
                // Remove from libs array
                libs[currentLibrariesLib] = libs[currentLibrariesLib].filter(c => 
                    !(c.name === color.name && c.L === color.L && c.a === color.a && c.b === color.b)
                );
                
                saveCustomLibraries();
                
                // Refresh display
                librariesSelector.dispatchEvent(new Event('change'));
                
                // Update library selector counts
                populateLibrariesSelector();
                
                // Update the active libraries display
                if (typeof updateActiveLibrariesDisplay === 'function') {
                    updateActiveLibrariesDisplay();
                }
            }
            
            // Edit mode toggle
            librariesEditModeBtn.addEventListener('click', () => {
                librariesEditMode = !librariesEditMode;
                
                if (librariesEditMode) {
                    librariesEditModeBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; display: inline-block; vertical-align: middle; margin-right: 4px;">
                            <polyline points="20 6 9 17 4 12"></polyline>
                        </svg>
                        Done
                    `;
                    librariesEditModeBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    librariesEditModeBtn.style.color = 'white';
                } else {
                    librariesEditModeBtn.innerHTML = `
                        <svg viewBox="0 0 24 24" style="width: 16px; height: 16px; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; display: inline-block; vertical-align: middle; margin-right: 4px;">
                            <path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>
                        </svg>
                        Edit
                    `;
                    librariesEditModeBtn.style.background = '';
                    librariesEditModeBtn.style.color = '';
                }
                
                displayLibrariesColors();
            });
            
            // Export button - export current library
            librariesExportBtn.addEventListener('click', () => {
                if (!currentLibrariesLib) {
                    alert('Please select a library to export');
                    return;
                }
                
                // Check if it's a custom library or public library
                const isCustom = customLibraries[currentLibrariesLib] !== undefined;
                let lib;
                
                if (isCustom) {
                    // Custom library
                    lib = customLibraries[currentLibrariesLib];
                    if (!lib || !lib.colors || lib.colors.length === 0) {
                        alert('Library has no colors to export');
                        return;
                    }
                } else {
                    // Public library
                    const libName = libNames[currentLibrariesLib];
                    if (!libs[currentLibrariesLib] || libs[currentLibrariesLib].length === 0) {
                        alert('Library has no colors to export');
                        return;
                    }
                    
                    // Create a library object for export
                    lib = {
                        name: libName,
                        colors: libs[currentLibrariesLib]
                    };
                }
                
                // Show export format modal
                showExportFormatModal(lib);
            });
            
            // Import button - trigger file import
            librariesImportBtn.addEventListener('click', () => {
                // Simulate clicking the hidden import input, but set target library
                if (currentLibrariesLib && customLibraries[currentLibrariesLib]) {
                    // Store which library to import into
                    window.importTargetLibrary = currentLibrariesLib;
                    document.getElementById('cmw-import-file').click();
                }
            });
            
            // Create Library button
            const librariesCreateBtn = document.getElementById('cmw-libraries-create-btn');
            if (librariesCreateBtn) {
                librariesCreateBtn.addEventListener('click', () => {
                    const libraryName = prompt('Enter a name for the new library:');
                    if (!libraryName || !libraryName.trim()) return;
                    
                    const trimmedName = libraryName.trim();
                    const libraryId = 'custom_' + Date.now();
                    
                    // Check if library name already exists
                    const existingLib = Object.values(customLibraries).find(lib => lib.name === trimmedName);
                    if (existingLib) {
                        alert('A library with this name already exists. Please choose a different name.');
                        return;
                    }
                    
                    // Create new library
                    customLibraries[libraryId] = {
                        name: trimmedName,
                        colors: []
                    };
                    libs[libraryId] = [];
                    libNames[libraryId] = trimmedName;
                    
                    saveCustomLibraries();
                    populateLibrariesSelector();
                    
                    // Auto-select the new library
                    librariesSelector.value = libraryId;
                    librariesSelector.dispatchEvent(new Event('change'));
                    
                    alert(`Library "${trimmedName}" created successfully!`);
                });
            }
            
            // Delete Library button
            if (librariesDeleteBtn) {
                librariesDeleteBtn.addEventListener('click', () => {
                    if (!currentLibrariesLib || !customLibraries[currentLibrariesLib]) {
                        alert('Please select a custom library to delete');
                        return;
                    }
                    
                    const libName = customLibraries[currentLibrariesLib].name;
                    const confirmDelete = confirm(`Are you sure you want to delete the library "${libName}"?\n\nThis action cannot be undone.`);
                    
                    if (!confirmDelete) return;
                    
                    // Delete from custom libraries
                    delete customLibraries[currentLibrariesLib];
                    delete libs[currentLibrariesLib];
                    delete libNames[currentLibrariesLib];
                    
                    // Save and refresh
                    saveCustomLibraries();
                    populateLibrariesSelector();
                    
                    // Hide the display area
                    librariesDisplay.style.display = 'none';
                    currentLibrariesLib = null;
                    
                    // Reset selector
                    librariesSelector.value = '';
                    
                    alert(`Library "${libName}" has been deleted.`);
                });
            }
            
            // Navigation buttons (top)
            librariesPrevBtn.addEventListener('click', () => {
                currentLibrariesIndex = Math.max(0, currentLibrariesIndex - LIBRARIES_COLORS_PER_PAGE);
                drawLibrariesCanvas();
                displayLibrariesColors();
                // Scroll to top of color grid
                librariesColorsGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
            
            librariesNextBtn.addEventListener('click', () => {
                const maxIndex = sortedLibrariesColors.length - LIBRARIES_COLORS_PER_PAGE;
                currentLibrariesIndex = Math.min(maxIndex, currentLibrariesIndex + LIBRARIES_COLORS_PER_PAGE);
                if (currentLibrariesIndex < 0) currentLibrariesIndex = 0;
                drawLibrariesCanvas();
                displayLibrariesColors();
                // Scroll to top of color grid
                librariesColorsGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
            
            // Navigation buttons (bottom)
            librariesPrevBtnBottom.addEventListener('click', () => {
                currentLibrariesIndex = Math.max(0, currentLibrariesIndex - LIBRARIES_COLORS_PER_PAGE);
                drawLibrariesCanvas();
                displayLibrariesColors();
                // Scroll to top of color grid
                librariesColorsGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
            
            librariesNextBtnBottom.addEventListener('click', () => {
                const maxIndex = sortedLibrariesColors.length - LIBRARIES_COLORS_PER_PAGE;
                currentLibrariesIndex = Math.min(maxIndex, currentLibrariesIndex + LIBRARIES_COLORS_PER_PAGE);
                if (currentLibrariesIndex < 0) currentLibrariesIndex = 0;
                drawLibrariesCanvas();
                displayLibrariesColors();
                // Scroll to top of color grid
                librariesColorsGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
            
            // Canvas click to jump to color position
            librariesCanvas.addEventListener('click', (e) => {
                const rect = librariesCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const clickPercent = x / rect.width;
                const clickIndex = Math.floor(clickPercent * sortedLibrariesColors.length);
                
                if (clickIndex >= 0 && clickIndex < sortedLibrariesColors.length) {
                    currentLibrariesIndex = Math.floor(clickIndex / LIBRARIES_COLORS_PER_PAGE) * LIBRARIES_COLORS_PER_PAGE;
                    drawLibrariesCanvas();
                    displayLibrariesColors();
                }
            });
            
            // Populate libraries after they're loaded
            setTimeout(() => {
                populateLibrariesSelector();
            }, 2000);
            
            // Color Libraries Add Form - Format selector
            const librariesFormatSelect = document.getElementById('cmw-libraries-format');
            if (librariesFormatSelect) {
                librariesFormatSelect.addEventListener('change', (e) => {
                    const format = e.target.value;
                    
                    // Hide all input groups
                    ['hex', 'lab', 'rgb', 'cmyk'].forEach(fmt => {
                        const group = document.getElementById(`cmw-libraries-${fmt}-inputs`);
                        if (group) group.style.display = 'none';
                    });
                    
                    // Show selected format inputs (all use flex now)
                    const activeGroup = document.getElementById(`cmw-libraries-${format}-inputs`);
                    if (activeGroup) {
                        activeGroup.style.display = 'flex';
                    }
                });
            }
            
            // Color Libraries Add Form - Input change handlers (update preview)
            function updateLibrariesPreview() {
                const preview = document.getElementById('cmw-libraries-preview-swatch');
                if (!preview) return;
                
                const format = document.getElementById('cmw-libraries-format').value;
                
                try {
                    if (format === 'hex') {
                        let hex = document.getElementById('cmw-libraries-hex').value.trim();
                        // Remove # if user included it
                        hex = hex.replace(/^#/, '');
                        if (hex && /^[0-9A-Fa-f]{6}$/.test(hex)) {
                            preview.style.backgroundColor = `#${hex}`;
                            preview.classList.add('valid');
                        } else {
                            preview.style.backgroundColor = '#cbd5e1';
                            preview.classList.remove('valid');
                        }
                    } else if (format === 'lab') {
                        const l = parseFloat(document.getElementById('cmw-libraries-lab-l').value);
                        const a = parseFloat(document.getElementById('cmw-libraries-lab-a').value);
                        const b = parseFloat(document.getElementById('cmw-libraries-lab-b').value);
                        if (!isNaN(l) && !isNaN(a) && !isNaN(b)) {
                            preview.style.backgroundColor = lab2rgb(l, a, b);
                            preview.classList.add('valid');
                        } else {
                            preview.style.backgroundColor = '#cbd5e1';
                            preview.classList.remove('valid');
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById('cmw-libraries-rgb-r').value);
                        const g = parseInt(document.getElementById('cmw-libraries-rgb-g').value);
                        const b = parseInt(document.getElementById('cmw-libraries-rgb-b').value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            preview.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
                            preview.classList.add('valid');
                        } else {
                            preview.style.backgroundColor = '#cbd5e1';
                            preview.classList.remove('valid');
                        }
                    } else if (format === 'cmyk') {
                        const c = parseFloat(document.getElementById('cmw-libraries-cmyk-c').value);
                        const m = parseFloat(document.getElementById('cmw-libraries-cmyk-m').value);
                        const y = parseFloat(document.getElementById('cmw-libraries-cmyk-y').value);
                        const k = parseFloat(document.getElementById('cmw-libraries-cmyk-k').value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            preview.classList.add('valid');
                            // Just show a placeholder - actual color will be converted via API
                            preview.style.backgroundColor = '#cbd5e1';
                        } else {
                            preview.style.backgroundColor = '#cbd5e1';
                            preview.classList.remove('valid');
                        }
                    }
                } catch (e) {
                    preview.style.backgroundColor = '#cbd5e1';
                    preview.classList.remove('valid');
                }
            }
            
            // Add input listeners for preview update
            ['cmw-libraries-hex', 'cmw-libraries-lab-l', 'cmw-libraries-lab-a', 'cmw-libraries-lab-b',
             'cmw-libraries-rgb-r', 'cmw-libraries-rgb-g', 'cmw-libraries-rgb-b',
             'cmw-libraries-cmyk-c', 'cmw-libraries-cmyk-m', 'cmw-libraries-cmyk-y', 'cmw-libraries-cmyk-k'].forEach(id => {
                const input = document.getElementById(id);
                if (input) {
                    input.addEventListener('input', updateLibrariesPreview);
                }
            });
            
            // Color Libraries Add Form - Add color button
            const librariesAddBtn = document.getElementById('cmw-libraries-add-btn');
            if (librariesAddBtn) {
                librariesAddBtn.addEventListener('click', async () => {
                    const statusEl = document.getElementById('cmw-libraries-add-status');
                    
                    if (!currentLibrariesLib || !customLibraries[currentLibrariesLib]) {
                        statusEl.textContent = 'Please select a custom library first';
                        statusEl.className = 'cmw-status error show';
                        return;
                    }
                    
                    try {
                        statusEl.textContent = 'Converting color...';
                        statusEl.className = 'cmw-status show';
                        
                        const format = document.getElementById('cmw-libraries-format').value;
                        const name = document.getElementById('cmw-libraries-color-name').value.trim();
                        
                        if (!name) {
                            throw new Error('Please enter a color name');
                        }
                        
                        let L, a, b;
                        
                        if (format === 'hex') {
                            let hex = document.getElementById('cmw-libraries-hex').value.trim();
                            // Remove # if user included it
                            hex = hex.replace(/^#/, '');
                            if (!hex || !/^[0-9A-Fa-f]{6}$/.test(hex)) {
                                throw new Error('Please enter a valid 6-character hex code');
                            }
                            const rgb = hex2rgb(hex);
                            const data = await convertColor({ rgb: [rgb.r, rgb.g, rgb.b], profile: 'sRGB.icc' });
                            L = data.lab[0];
                            a = data.lab[1];
                            b = data.lab[2];
                        } else if (format === 'lab') {
                            L = parseFloat(document.getElementById('cmw-libraries-lab-l').value);
                            a = parseFloat(document.getElementById('cmw-libraries-lab-a').value);
                            b = parseFloat(document.getElementById('cmw-libraries-lab-b').value);
                            if (isNaN(L) || isNaN(a) || isNaN(b)) {
                                throw new Error('Please enter all Lab values');
                            }
                        } else if (format === 'rgb') {
                            const r = parseInt(document.getElementById('cmw-libraries-rgb-r').value);
                            const g = parseInt(document.getElementById('cmw-libraries-rgb-g').value);
                            const b = parseInt(document.getElementById('cmw-libraries-rgb-b').value);
                            if (isNaN(r) || isNaN(g) || isNaN(b)) {
                                throw new Error('Please enter all RGB values');
                            }
                            const data = await convertColor({ rgb: [r, g, b], profile: 'sRGB.icc' });
                            L = data.lab[0];
                            a = data.lab[1];
                            b = data.lab[2];
                        } else if (format === 'cmyk') {
                            const c = parseFloat(document.getElementById('cmw-libraries-cmyk-c').value);
                            const m = parseFloat(document.getElementById('cmw-libraries-cmyk-m').value);
                            const y = parseFloat(document.getElementById('cmw-libraries-cmyk-y').value);
                            const k = parseFloat(document.getElementById('cmw-libraries-cmyk-k').value);
                            if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
                                throw new Error('Please enter all CMYK values');
                            }
                            const profile = 'GRACoL2013.icc';
                            const data = await convertColor({ cmyk: [c, m, y, k], profile });
                            L = data.lab[0];
                            a = data.lab[1];
                            b = data.lab[2];
                        }
                        
                        // Add color to library
                        const color = { name, L, a, b };
                        customLibraries[currentLibrariesLib].colors.push(color);
                        libs[currentLibrariesLib].push({ ...color, libraryName: customLibraries[currentLibrariesLib].name });
                        
                        saveCustomLibraries();
                        populateLibrariesSelector();
                        
                        // Refresh display
                        librariesSelector.value = currentLibrariesLib;
                        librariesSelector.dispatchEvent(new Event('change'));
                        
                        // Clear inputs
                        document.getElementById('cmw-libraries-color-name').value = '';
                        document.getElementById('cmw-libraries-hex').value = '';
                        document.getElementById('cmw-libraries-lab-l').value = '';
                        document.getElementById('cmw-libraries-lab-a').value = '';
                        document.getElementById('cmw-libraries-lab-b').value = '';
                        document.getElementById('cmw-libraries-rgb-r').value = '';
                        document.getElementById('cmw-libraries-rgb-g').value = '';
                        document.getElementById('cmw-libraries-rgb-b').value = '';
                        document.getElementById('cmw-libraries-cmyk-c').value = '';
                        document.getElementById('cmw-libraries-cmyk-m').value = '';
                        document.getElementById('cmw-libraries-cmyk-y').value = '';
                        document.getElementById('cmw-libraries-cmyk-k').value = '';
                        document.getElementById('cmw-libraries-preview-swatch').style.backgroundColor = '#cbd5e1';
                        document.getElementById('cmw-libraries-preview-swatch').classList.remove('valid');
                        
                        statusEl.textContent = `Added "${name}" to ${customLibraries[currentLibrariesLib].name}`;
                        statusEl.className = 'cmw-status success show';
                        setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
                    } catch (e) {
                        statusEl.textContent = e.message;
                        statusEl.className = 'cmw-status error show';
                    }
                });
            }

            /* ─────────────────────
               Color Consensus Feature
               ───────────────────── */
            
            // Consensus sample storage
            const consensusSamples = [];
            let sampleIdCounter = 0;
            
            // Helper: Parse color value from input based on format
            function parseColorInput(format, value) {
                value = value.trim();
                
                if (format === 'hex') {
                    // Handle hex input
                    if (!value.startsWith('#')) value = '#' + value;
                    if (!/^#[0-9A-Fa-f]{6}$/.test(value)) {
                        throw new Error('Invalid hex format. Use #RRGGBB');
                    }
                    return { format: 'hex', value: value };
                }
                
                if (format === 'lab') {
                    // Parse Lab values (comma or space separated)
                    const parts = value.split(/[,\s]+/).map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
                    if (parts.length !== 3) {
                        throw new Error('Lab requires 3 values: L, a, b');
                    }
                    if (parts[0] < 0 || parts[0] > 100) {
                        throw new Error('L must be between 0 and 100');
                    }
                    return { format: 'lab', value: parts };
                }
                
                if (format === 'rgb') {
                    // Parse RGB values
                    const parts = value.split(/[,\s]+/).map(v => parseInt(v.trim())).filter(v => !isNaN(v));
                    if (parts.length !== 3) {
                        throw new Error('RGB requires 3 values: R, G, B');
                    }
                    if (parts.some(v => v < 0 || v > 255)) {
                        throw new Error('RGB values must be between 0 and 255');
                    }
                    return { format: 'rgb', value: parts };
                }
                
                if (format === 'cmyk') {
                    // Parse CMYK values
                    const parts = value.split(/[,\s]+/).map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
                    if (parts.length !== 4) {
                        throw new Error('CMYK requires 4 values: C, M, Y, K');
                    }
                    if (parts.some(v => v < 0 || v > 100)) {
                        throw new Error('CMYK values must be between 0 and 100');
                    }
                    return { format: 'cmyk', value: parts, profile: 'GRACoL2013.icc' };
                }
                
                throw new Error('Unknown format');
            }
            
            // Helper: Get preview hex for a sample
            function getSamplePreviewHex(sample) {
                try {
                    if (sample.format === 'hex') {
                        return sample.value;
                    }
                    if (sample.format === 'lab') {
                        return lab2rgb(sample.value[0], sample.value[1], sample.value[2]);
                    }
                    if (sample.format === 'rgb') {
                        const [r, g, b] = sample.value;
                        return `rgb(${r}, ${g}, ${b})`;
                    }
                    if (sample.format === 'cmyk') {
                        // Use pre-computed preview color from LittleCMS if available
                        if (sample.previewColor) {
                            return sample.previewColor;
                        }
                        // Fallback: use lab2rgb if normalizedLab is available (from API response)
                        if (sample.normalizedLab) {
                            return lab2rgb(sample.normalizedLab[0], sample.normalizedLab[1], sample.normalizedLab[2]);
                        }
                        // Last resort fallback (should not happen if API works)
                        console.warn('CMYK preview using fallback - LittleCMS should be used');
                        const [c, m, y, k] = sample.value.map(v => v / 100);
                        const r = Math.round(255 * (1 - c) * (1 - k));
                        const g = Math.round(255 * (1 - m) * (1 - k));
                        const b = Math.round(255 * (1 - y) * (1 - k));
                        return `rgb(${r}, ${g}, ${b})`;
                    }
                } catch (e) {
                    return '#808080';
                }
                return '#808080';
            }
            
            // Helper: Format value for display
            function formatSampleValue(sample) {
                let originalValue = '';
                if (sample.format === 'hex') {
                    originalValue = sample.value;
                } else if (sample.format === 'lab') {
                    originalValue = `Lab(${sample.value[0].toFixed(2)}, ${sample.value[1].toFixed(2)}, ${sample.value[2].toFixed(2)})`;
                } else if (sample.format === 'rgb') {
                    originalValue = `RGB(${sample.value.join(', ')})`;
                } else if (sample.format === 'cmyk') {
                    originalValue = `CMYK(${sample.value.map(v => v.toFixed(2)).join(', ')})`;
                } else {
                    originalValue = String(sample.value);
                }
                
                // If we have normalized Lab values (after calculation), show them too
                if (sample.normalizedLab && Array.isArray(sample.normalizedLab)) {
                    const labStr = `Lab(${sample.normalizedLab[0].toFixed(2)}, ${sample.normalizedLab[1].toFixed(2)}, ${sample.normalizedLab[2].toFixed(2)})`;
                    if (sample.format !== 'lab') {
                        return `${originalValue}<br><span style="color: #6b7280; font-size: 12px;">→ ${labStr}</span>`;
                    }
                    return labStr;
                }
                
                return originalValue;
            }
            
            // Render samples list
            function renderConsensusSamples() {
                const container = document.getElementById('cmw-consensus-samples');
                container.innerHTML = '';
                
                consensusSamples.forEach((sample, index) => {
                    const row = document.createElement('div');
                    row.className = 'cmw-sample-row' + (sample.excluded ? ' excluded' : '');
                    row.dataset.sampleId = sample.id;
                    
                    row.innerHTML = `
                        <div class="cmw-sample-swatch" style="background: ${getSamplePreviewHex(sample)}"></div>
                        <div class="cmw-sample-info">
                            <div class="cmw-sample-label">${sample.label || 'Sample ' + (index + 1)}</div>
                            <div class="cmw-sample-values">${formatSampleValue(sample)}</div>
                            ${sample.deltaToConsensus !== undefined ? `<div class="cmw-sample-delta">ΔE2000 to consensus: ${sample.deltaToConsensus.toFixed(2)}</div>` : ''}
                        </div>
                        <button class="cmw-sample-remove" data-sample-id="${sample.id}">×</button>
                    `;
                    
                    container.appendChild(row);
                });
                
                // Update calculate button state
                const calcBtn = document.getElementById('cmw-calculate-consensus-btn');
                calcBtn.disabled = consensusSamples.length < 2;
            }
            
            // Get values from individual input fields based on format
            function getColorValuesFromInputs(format) {
                if (format === 'hex') {
                    let hex = document.getElementById('cmw-sample-hex').value.trim();
                    if (!hex) throw new Error('Please enter a hex color');
                    if (!hex.startsWith('#')) hex = '#' + hex;
                    if (!/^#[0-9A-Fa-f]{6}$/i.test(hex)) {
                        throw new Error('Invalid hex format. Use RRGGBB');
                    }
                    return { format: 'hex', value: hex.toUpperCase() };
                }
                
                if (format === 'lab') {
                    const L = parseFloat(document.getElementById('cmw-sample-lab-l').value);
                    const a = parseFloat(document.getElementById('cmw-sample-lab-a').value);
                    const b = parseFloat(document.getElementById('cmw-sample-lab-b').value);
                    if (isNaN(L) || isNaN(a) || isNaN(b)) {
                        throw new Error('Please fill in all Lab values');
                    }
                    if (L < 0 || L > 100) throw new Error('L* must be between 0 and 100');
                    return { format: 'lab', value: [L, a, b] };
                }
                
                if (format === 'rgb') {
                    const r = parseInt(document.getElementById('cmw-sample-rgb-r').value);
                    const g = parseInt(document.getElementById('cmw-sample-rgb-g').value);
                    const b = parseInt(document.getElementById('cmw-sample-rgb-b').value);
                    if (isNaN(r) || isNaN(g) || isNaN(b)) {
                        throw new Error('Please fill in all RGB values');
                    }
                    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
                        throw new Error('RGB values must be between 0 and 255');
                    }
                    return { format: 'rgb', value: [r, g, b] };
                }
                
                if (format === 'cmyk') {
                    const c = parseFloat(document.getElementById('cmw-sample-cmyk-c').value);
                    const m = parseFloat(document.getElementById('cmw-sample-cmyk-m').value);
                    const y = parseFloat(document.getElementById('cmw-sample-cmyk-y').value);
                    const k = parseFloat(document.getElementById('cmw-sample-cmyk-k').value);
                    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
                        throw new Error('Please fill in all CMYK values');
                    }
                    if (c < 0 || c > 100 || m < 0 || m > 100 || y < 0 || y > 100 || k < 0 || k > 100) {
                        throw new Error('CMYK values must be between 0 and 100');
                    }
                    return { format: 'cmyk', value: [c, m, y, k], profile: 'GRACoL2013.icc' };
                }
                
                throw new Error('Unknown format');
            }
            
            // Clear color input fields based on format
            function clearColorInputs(format) {
                if (format === 'hex') {
                    document.getElementById('cmw-sample-hex').value = '';
                } else if (format === 'lab') {
                    document.getElementById('cmw-sample-lab-l').value = '';
                    document.getElementById('cmw-sample-lab-a').value = '';
                    document.getElementById('cmw-sample-lab-b').value = '';
                } else if (format === 'rgb') {
                    document.getElementById('cmw-sample-rgb-r').value = '';
                    document.getElementById('cmw-sample-rgb-g').value = '';
                    document.getElementById('cmw-sample-rgb-b').value = '';
                } else if (format === 'cmyk') {
                    document.getElementById('cmw-sample-cmyk-c').value = '';
                    document.getElementById('cmw-sample-cmyk-m').value = '';
                    document.getElementById('cmw-sample-cmyk-y').value = '';
                    document.getElementById('cmw-sample-cmyk-k').value = '';
                }
            }
            
            // Add sample
            async function addConsensusSample() {
                const format = document.getElementById('cmw-sample-format').value;
                const labelInput = document.getElementById('cmw-sample-label');
                const statusEl = document.getElementById('cmw-consensus-status');
                
                try {
                    const parsed = getColorValuesFromInputs(format);
                    const sample = {
                        id: ++sampleIdCounter,
                        ...parsed,
                        label: labelInput.value.trim() || null,
                        // Use sRGB.icc for hex/rgb, GRACoL2013.icc for CMYK
                        profile: (format === 'hex' || format === 'rgb') ? 'sRGB.icc' : (format === 'cmyk' ? 'GRACoL2013.icc' : null)
                    };
                    
                    // Pre-compute preview color for CMYK using LittleCMS
                    if (format === 'cmyk') {
                        try {
                            const data = await convertColor({
                                cmyk: sample.value,
                                profile: 'GRACoL2013.icc'
                            });
                            if (data && data.lab) {
                                sample.previewColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                            }
                        } catch (e) {
                            console.error('CMYK preview conversion failed:', e);
                        }
                    }
                    
                    consensusSamples.push(sample);
                    renderConsensusSamples();
                    
                    // Clear inputs
                    clearColorInputs(format);
                    labelInput.value = '';
                    statusEl.className = 'cmw-status';
                    statusEl.textContent = '';
                    
                } catch (e) {
                    statusEl.textContent = e.message;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Remove sample
            function removeSample(sampleId) {
                const index = consensusSamples.findIndex(s => s.id === parseInt(sampleId));
                if (index !== -1) {
                    consensusSamples.splice(index, 1);
                    renderConsensusSamples();
                }
            }
            
            // Clear all samples
            function clearAllSamples() {
                consensusSamples.length = 0;
                sampleIdCounter = 0;
                renderConsensusSamples();
                document.getElementById('cmw-consensus-result').classList.remove('show');
                document.getElementById('cmw-consensus-status').className = 'cmw-status';
            }
            
            // Calculate consensus
            async function calculateConsensus() {
                const statusEl = document.getElementById('cmw-consensus-status');
                const loadingEl = document.getElementById('cmw-consensus-loading');
                const resultEl = document.getElementById('cmw-consensus-result');
                
                if (consensusSamples.length < 2) {
                    statusEl.textContent = 'Need at least 2 color samples';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                loadingEl.style.display = 'flex';
                resultEl.classList.remove('show');
                statusEl.className = 'cmw-status';
                
                try {
                    const apiUrl = getApiBaseUrl();
                    const threshold = parseFloat(document.getElementById('cmw-outlier-threshold').value) || 3.0;
                    
                    // Pre-convert samples to Lab using convertColor() for consistency with Color Search
                    // RGB/Hex uses sRGB.icc, CMYK uses GRACoL2013.icc (or selected profile)
                    const colors = await Promise.all(consensusSamples.map(async (s, i) => {
                        const label = s.label || `Sample ${i + 1}`;
                        
                        if (s.format === 'hex') {
                            // Convert hex to Lab using sRGB.icc (same as Color Search)
                            const cleanHex = s.value.replace('#', '');
                            const r = parseInt(cleanHex.substring(0, 2), 16);
                            const g = parseInt(cleanHex.substring(2, 4), 16);
                            const b = parseInt(cleanHex.substring(4, 6), 16);
                            
                            console.log(`[Consensus] Converting hex ${s.value} -> RGB(${r}, ${g}, ${b})`);
                            
                            try {
                                const data = await convertColor({
                                    rgb: [r, g, b],
                                    profile: 'sRGB.icc'
                                });
                                console.log(`[Consensus] Hex ${s.value} -> Lab(${data.lab[0]}, ${data.lab[1]}, ${data.lab[2]})`);
                                // Send as Lab to ensure consistency
                                return {
                                    format: 'lab',
                                    value: data.lab,
                                    label: label,
                                    profile: null
                                };
                            } catch (err) {
                                console.warn('[Consensus] Failed to convert hex, sending as-is:', err);
                                return {
                                    format: s.format,
                                    value: s.value,
                                    label: label,
                                    profile: 'sRGB.icc'
                                };
                            }
                        } else if (s.format === 'rgb') {
                            // Convert RGB to Lab using sRGB.icc
                            try {
                                const data = await convertColor({
                                    rgb: s.value,
                                    profile: 'sRGB.icc'
                                });
                                return {
                                    format: 'lab',
                                    value: data.lab,
                                    label: label,
                                    profile: null
                                };
                            } catch (err) {
                                console.warn('Failed to convert RGB, sending as-is:', err);
                                return {
                                    format: s.format,
                                    value: s.value,
                                    label: label,
                                    profile: 'sRGB.icc'
                                };
                            }
                        } else if (s.format === 'cmyk') {
                            // Convert CMYK to Lab using GRACoL2013.icc
                            try {
                                const data = await convertColor({
                                    cmyk: s.value,
                                    profile: 'GRACoL2013.icc'
                                });
                                return {
                                    format: 'lab',
                                    value: data.lab,
                                    label: label,
                                    profile: null
                                };
                            } catch (err) {
                                console.warn('Failed to convert CMYK, sending as-is:', err);
                                return {
                                    format: s.format,
                                    value: s.value,
                                    label: label,
                                    profile: 'GRACoL2013.icc'
                                };
                            }
                        } else {
                            // Lab - send as-is
                            return {
                                format: s.format,
                                value: s.value,
                                label: label,
                                profile: null
                            };
                        }
                    }));
                    
                    console.log('[Consensus] Sending colors to API:', JSON.stringify(colors, null, 2));
                    
                    // Log what we're actually sending for each sample
                    colors.forEach((c, i) => {
                        console.log(`[Consensus] Sample ${i + 1}: format=${c.format}, value=${JSON.stringify(c.value)}`);
                        if (c.format === 'lab') {
                            console.log(`[Consensus] Sample ${i + 1} Lab values: L=${c.value[0].toFixed(4)}, a=${c.value[1].toFixed(4)}, b=${c.value[2].toFixed(4)}`);
                        }
                    });
                    
                    // Include rendering intent to match Color Search behavior
                    const currentIntent = document.getElementById('cmw-default-intent').value;
                    const requestBody = {
                        colors: colors,
                        outlier_threshold: threshold,
                        include_pairwise: true,
                        include_hex_preview: true
                    };
                    
                    // Only add rendering intent if it's not "none"
                    if (currentIntent !== 'none') {
                        requestBody.renderingIntent = parseInt(currentIntent);
                    }
                    
                    const response = await fetch(`${apiUrl}/color-consensus`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                    
                    if (!response.ok) {
                        const errData = await response.json().catch(() => ({}));
                        throw new Error(errData.detail || 'API request failed');
                    }
                    
                    const data = await response.json();
                    console.log('Consensus API response:', data);
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Consensus calculation failed');
                    }
                    
                    // Log the consensus result Lab values
                    if (data.consensus && data.consensus.lab) {
                        console.log(`[Consensus] Result Lab: L=${data.consensus.lab[0].toFixed(4)}, a=${data.consensus.lab[1].toFixed(4)}, b=${data.consensus.lab[2].toFixed(4)}`);
                    }
                    
                    // Update sample deltas and excluded status based on actual API response
                    const includedSamples = data.samples?.included || [];
                    const excludedSamples = data.samples?.excluded || [];
                    
                    // Log each sample's Lab values from the API response
                    console.log('[Consensus] Included samples from API:');
                    includedSamples.forEach(s => {
                        if (s.lab) {
                            console.log(`  ${s.label}: Lab(${s.lab[0].toFixed(4)}, ${s.lab[1].toFixed(4)}, ${s.lab[2].toFixed(4)})`);
                        }
                    });
                    console.log('[Consensus] Excluded samples from API:');
                    excludedSamples.forEach(s => {
                        if (s.lab) {
                            console.log(`  ${s.label}: Lab(${s.lab[0].toFixed(4)}, ${s.lab[1].toFixed(4)}, ${s.lab[2].toFixed(4)})`);
                        }
                    });
                    const excludedLabels = new Set(excludedSamples.map(s => s.label || ''));
                    
                    // Create a map of label -> sample data for quick lookup
                    const sampleDataMap = {};
                    includedSamples.forEach(s => { sampleDataMap[s.label] = { ...s, excluded: false }; });
                    excludedSamples.forEach(s => { sampleDataMap[s.label] = { ...s, excluded: true }; });
                    
                    consensusSamples.forEach((sample, i) => {
                        const label = sample.label || `Sample ${i + 1}`;
                        const apiSample = sampleDataMap[label];
                        if (apiSample) {
                            sample.normalizedLab = apiSample.lab;
                            sample.deltaToConsensus = apiSample.deltaE_to_consensus;
                            sample.excluded = apiSample.excluded;
                        }
                    });
                    renderConsensusSamples();
                    
                    // Display results
                    displayConsensusResult(data);
                    
                } catch (e) {
                    console.error('Consensus error:', e);
                    statusEl.textContent = e.message || 'Failed to calculate consensus';
                    statusEl.className = 'cmw-status error show';
                } finally {
                    loadingEl.style.display = 'none';
                }
            }
            
            // Display consensus results
            function displayConsensusResult(data) {
                const resultEl = document.getElementById('cmw-consensus-result');
                
                // Consensus color - from data.consensus.lab (actual API structure)
                const consensus = data.consensus || {};
                const consensusLab = consensus.lab || [50, 0, 0];
                const L = consensusLab[0] ?? 50;
                const a = consensusLab[1] ?? 0;
                const b = consensusLab[2] ?? 0;
                const consensusHex = consensus.hex || '';
                
                // Use LittleCMS hex - show error if not available
                if (!consensusHex) {
                    console.error('LittleCMS API did not return consensus hex');
                    document.getElementById('cmw-consensus-swatch').style.background = '#f0f0f0';
                } else {
                    document.getElementById('cmw-consensus-swatch').style.background = consensusHex;
                }
                document.getElementById('cmw-consensus-lab').textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)})`;
                document.getElementById('cmw-consensus-hex').textContent = consensusHex;
                
                // Stats from actual API response
                const includedCount = data.included_count || 0;
                const excludedCount = data.excluded_count || 0;
                const maxDelta = consensus.max_deltaE || 0;
                
                document.getElementById('cmw-stat-included').textContent = includedCount;
                document.getElementById('cmw-stat-excluded').textContent = excludedCount;
                document.getElementById('cmw-stat-max-delta').textContent = maxDelta.toFixed(2);
                
                // Warning
                const warningEl = document.getElementById('cmw-consensus-warning');
                if (data.warning) {
                    warningEl.textContent = data.warning;
                    warningEl.style.display = 'block';
                } else {
                    warningEl.style.display = 'none';
                }
                
                // Pairwise comparisons - from data.pairwise_comparisons (actual API structure)
                const pairwiseGrid = document.getElementById('cmw-pairwise-grid');
                pairwiseGrid.innerHTML = '';
                
                const pairwiseData = data.pairwise_comparisons || [];
                if (pairwiseData.length > 0) {
                    pairwiseData.forEach(pair => {
                        if (pair) {
                            const item = document.createElement('div');
                            item.className = 'cmw-pairwise-item';
                            // API returns: { sample1, sample2, deltaE2000 }
                            const label1 = pair.sample1 || '?';
                            const label2 = pair.sample2 || '?';
                            const deltaE = pair.deltaE2000 || 0;
                            item.innerHTML = `
                                <span class="cmw-pairwise-pair">${label1} ↔ ${label2}</span>
                                <span class="cmw-pairwise-delta">ΔE ${deltaE.toFixed(2)}</span>
                            `;
                            pairwiseGrid.appendChild(item);
                        }
                    });
                }
                
                resultEl.classList.add('show');
            }
            
            // Event listeners for consensus feature
            document.getElementById('cmw-add-sample-btn').addEventListener('click', addConsensusSample);
            
            // Enter key support for all input fields
            document.getElementById('cmw-sample-hex').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-lab-l').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-lab-a').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-lab-b').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-rgb-r').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-rgb-g').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-rgb-b').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-c').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-m').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-y').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-cmyk-k').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            document.getElementById('cmw-sample-label').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addConsensusSample();
            });
            
            document.getElementById('cmw-consensus-samples').addEventListener('click', (e) => {
                if (e.target.classList.contains('cmw-sample-remove')) {
                    removeSample(e.target.dataset.sampleId);
                }
            });
            
            document.getElementById('cmw-clear-samples-btn').addEventListener('click', clearAllSamples);
            
            document.getElementById('cmw-calculate-consensus-btn').addEventListener('click', calculateConsensus);
            
            document.getElementById('cmw-pairwise-toggle').addEventListener('click', () => {
                const grid = document.getElementById('cmw-pairwise-grid');
                const toggle = document.getElementById('cmw-pairwise-toggle');
                const isShown = grid.classList.toggle('show');
                toggle.classList.toggle('expanded', isShown);
                toggle.querySelector('span:last-child').textContent = isShown ? 'Hide Pairwise Comparisons' : 'Show Pairwise Comparisons';
            });
            
            // Show/hide input groups based on format selection
            document.getElementById('cmw-sample-format').addEventListener('change', (e) => {
                const format = e.target.value;
                // Hide all input groups
                document.getElementById('cmw-sample-hex-inputs').classList.remove('active');
                document.getElementById('cmw-sample-lab-inputs').classList.remove('active');
                document.getElementById('cmw-sample-rgb-inputs').classList.remove('active');
                document.getElementById('cmw-sample-cmyk-inputs').classList.remove('active');
                // Show selected input group
                document.getElementById(`cmw-sample-${format}-inputs`).classList.add('active');
                // Update swatch preview
                updateSamplePreviewSwatch();
            });
            
            // Update the sample preview swatch as user types
            async function updateSamplePreviewSwatch() {
                const format = document.getElementById('cmw-sample-format').value;
                const swatch = document.getElementById('cmw-sample-preview-swatch');
                let hexColor = '#f0f0f0'; // Default gray
                
                try {
                    if (format === 'hex') {
                        const hex = document.getElementById('cmw-sample-hex').value.trim();
                        if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                            hexColor = '#' + hex;
                        }
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById('cmw-sample-lab-l').value);
                        const a = parseFloat(document.getElementById('cmw-sample-lab-a').value);
                        const b = parseFloat(document.getElementById('cmw-sample-lab-b').value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            hexColor = lab2rgb(L, a, b);
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById('cmw-sample-rgb-r').value);
                        const g = parseInt(document.getElementById('cmw-sample-rgb-g').value);
                        const b = parseInt(document.getElementById('cmw-sample-rgb-b').value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            hexColor = `rgb(${r}, ${g}, ${b})`;
                        }
                    } else if (format === 'cmyk') {
                        // Use LittleCMS API for accurate CMYK → Lab → RGB conversion
                        const c = parseFloat(document.getElementById('cmw-sample-cmyk-c').value);
                        const m = parseFloat(document.getElementById('cmw-sample-cmyk-m').value);
                        const y = parseFloat(document.getElementById('cmw-sample-cmyk-y').value);
                        const k = parseFloat(document.getElementById('cmw-sample-cmyk-k').value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            try {
                                // CMYK → Lab via LittleCMS with GRACoL profile
                                const data = await convertColor({
                                    cmyk: [c, m, y, k],
                                    profile: 'GRACoL2013.icc'
                                });
                                if (data && data.lab) {
                                    hexColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                                }
                            } catch (e) {
                                console.error('CMYK preview conversion failed:', e);
                            }
                        }
                    }
                } catch (e) {
                    // Keep default gray on error
                }
                
                swatch.style.background = hexColor;
            }
            
            // Add input event listeners for live swatch preview
            document.getElementById('cmw-sample-hex').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-lab-l').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-lab-a').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-lab-b').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-rgb-r').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-rgb-g').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-rgb-b').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-c').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-m').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-y').addEventListener('input', updateSamplePreviewSwatch);
            document.getElementById('cmw-sample-cmyk-k').addEventListener('input', updateSamplePreviewSwatch);
            
            // Consensus section collapsible toggle
            const consensusToggle = document.getElementById('cmw-consensus-toggle');
            const consensusContent = document.getElementById('cmw-consensus-content');
            
            consensusToggle.addEventListener('click', () => {
                const isCollapsed = consensusToggle.classList.contains('collapsed');
                
                if (isCollapsed) {
                    // Expand
                    consensusToggle.classList.remove('collapsed');
                    consensusContent.classList.remove('collapsed');
                } else {
                    // Collapse
                    consensusToggle.classList.add('collapsed');
                    consensusContent.classList.add('collapsed');
                }
            });

            /* ─────────────────────
               Color Compare Feature
               ───────────────────── */
            
            // Color Compare section collapsible toggle
            const compareToggle = document.getElementById('cmw-compare-toggle');
            const compareContent = document.getElementById('cmw-compare-content');
            
            compareToggle.addEventListener('click', () => {
                const isCollapsed = compareToggle.classList.contains('collapsed');
                
                if (isCollapsed) {
                    compareToggle.classList.remove('collapsed');
                    compareContent.classList.remove('collapsed');
                } else {
                    compareToggle.classList.add('collapsed');
                    compareContent.classList.add('collapsed');
                }
            });
            
            // Store compare colors data
            let compareColor1 = null;
            let compareColor2 = null;
            
            // Get color data from compare inputs and convert using LittleCMS API
            async function getCompareColorData(colorNum) {
                const format = document.getElementById(`cmw-compare-format-${colorNum}`).value;
                
                try {
                    if (format === 'hex') {
                        const input = document.getElementById(`cmw-compare-hex-${colorNum}`).value.trim();
                        // Remove # if present and check if it's a valid 6-digit hex only
                        const cleanHex = input.replace(/^#/, '');
                        if (/^[0-9A-Fa-f]{6}$/.test(cleanHex)) {
                            // Use LittleCMS API to convert hex to Lab
                            const rgb = hex2rgb(cleanHex);
                            const data = await convertColor({
                                rgb: [rgb.r, rgb.g, rgb.b],
                                profile: 'sRGB.icc'
                            });
                            return {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex ? (data.hex.startsWith('#') ? data.hex : '#' + data.hex) : '#' + cleanHex
                            };
                        }
                        return null;
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById(`cmw-compare-lab-l-${colorNum}`).value);
                        const a = parseFloat(document.getElementById(`cmw-compare-lab-a-${colorNum}`).value);
                        const b = parseFloat(document.getElementById(`cmw-compare-lab-b-${colorNum}`).value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            // Use LittleCMS API to convert Lab to hex (Lab → RGB uses sRGB)
                            const data = await convertColor({
                                lab: [L, a, b],
                                profile: 'sRGB.icc'
                            });
                            if (!data.hex) {
                                throw new Error('LittleCMS did not return hex value');
                            }
                            return {
                                lab: { L, a, b },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex
                            };
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById(`cmw-compare-rgb-r-${colorNum}`).value);
                        const g = parseInt(document.getElementById(`cmw-compare-rgb-g-${colorNum}`).value);
                        const b = parseInt(document.getElementById(`cmw-compare-rgb-b-${colorNum}`).value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            // Use LittleCMS API to convert RGB to Lab
                            const data = await convertColor({
                                rgb: [r, g, b],
                                profile: 'sRGB.icc'
                            });
                            if (!data.hex || !data.lab) {
                                throw new Error('LittleCMS did not return required values');
                            }
                            const result = {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex,
                                // Preserve original RGB values so we don't have to convert again
                                rgb_r: r,
                                rgb_g: g,
                                rgb_b: b
                            };
                            console.log('📦 RGB input created color data:', result);
                            return result;
                        }
                    } else if (format === 'cmyk') {
                        const c = parseFloat(document.getElementById(`cmw-compare-cmyk-c-${colorNum}`).value);
                        const m = parseFloat(document.getElementById(`cmw-compare-cmyk-m-${colorNum}`).value);
                        const y = parseFloat(document.getElementById(`cmw-compare-cmyk-y-${colorNum}`).value);
                        const k = parseFloat(document.getElementById(`cmw-compare-cmyk-k-${colorNum}`).value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            // Use LittleCMS API to convert CMYK to Lab
                            const data = await convertColor({
                                cmyk: [c, m, y, k],
                                profile: 'GRACoL2013.icc'
                            });
                            if (!data.hex || !data.lab) {
                                throw new Error('LittleCMS did not return required values');
                            }
                            const result = {
                                lab: { L: data.lab[0], a: data.lab[1], b: data.lab[2] },
                                hex: data.hex.startsWith('#') ? data.hex : '#' + data.hex,
                                // Preserve original CMYK values so we don't have to convert again
                                cmyk_c: c,
                                cmyk_m: m,
                                cmyk_y: y,
                                cmyk_k: k
                            };
                            console.log('📦 CMYK input created color data:', result);
                            return result;
                        }
                    }
                } catch (e) {
                    console.error('Error converting color via API:', e);
                }
                
                return null;
            }
            
            // Update swatch preview for compare color using LittleCMS
            async function updateCompareSwatchPreview(colorNum) {
                const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                
                const colorData = await getCompareColorData(colorNum);
                
                if (colorData) {
                    swatch.style.background = colorData.hex;
                    valuesEl.textContent = `Lab(${colorData.lab.L.toFixed(2)}, ${colorData.lab.a.toFixed(2)}, ${colorData.lab.b.toFixed(2)}) | ${colorData.hex}`;
                    
                    console.log(`💾 Storing compare color ${colorNum}:`, colorData);
                    
                    if (colorNum === 1) {
                        compareColor1 = colorData;
                    } else {
                        compareColor2 = colorData;
                    }
                } else {
                    swatch.style.background = '#f0f0f0';
                    valuesEl.textContent = 'Lab: — | Hex: —';
                    
                    if (colorNum === 1) {
                        compareColor1 = null;
                    } else {
                        compareColor2 = null;
                    }
                }
            }
            
            // Format change handlers
            function setupCompareFormatHandler(colorNum) {
                document.getElementById(`cmw-compare-format-${colorNum}`).addEventListener('change', (e) => {
                    const format = e.target.value;
                    // Hide all input groups
                    document.getElementById(`cmw-compare-hex-inputs-${colorNum}`).classList.remove('active');
                    document.getElementById(`cmw-compare-lab-inputs-${colorNum}`).classList.remove('active');
                    document.getElementById(`cmw-compare-rgb-inputs-${colorNum}`).classList.remove('active');
                    document.getElementById(`cmw-compare-cmyk-inputs-${colorNum}`).classList.remove('active');
                    // Show selected input group
                    document.getElementById(`cmw-compare-${format}-inputs-${colorNum}`).classList.add('active');
                    updateCompareSwatchPreview(colorNum);
                });
            }
            
            setupCompareFormatHandler(1);
            setupCompareFormatHandler(2);
            
            // Input change handlers for live preview
            function setupCompareInputHandlers(colorNum) {
                // Hex/Name input - only update preview for valid 6-digit hex values
                document.getElementById(`cmw-compare-hex-${colorNum}`).addEventListener('input', () => {
                    const input = document.getElementById(`cmw-compare-hex-${colorNum}`).value.trim();
                    const cleanHex = input.replace(/^#/, '');
                    // Only update preview if it's exactly a 6-digit hex value
                    if (/^[0-9A-Fa-f]{6}$/.test(cleanHex)) {
                        updateCompareSwatchPreview(colorNum);
                    }
                });
                
                // Lab inputs
                ['l', 'a', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-lab-${comp}-${colorNum}`).addEventListener('input', () => {
                        updateCompareSwatchPreview(colorNum);
                    });
                });
                
                // RGB inputs
                ['r', 'g', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-rgb-${comp}-${colorNum}`).addEventListener('input', () => {
                        updateCompareSwatchPreview(colorNum);
                    });
                });
                
                // CMYK inputs
                ['c', 'm', 'y', 'k'].forEach(comp => {
                    document.getElementById(`cmw-compare-cmyk-${comp}-${colorNum}`).addEventListener('input', () => {
                        updateCompareSwatchPreview(colorNum);
                    });
                });
            }
            
            setupCompareInputHandlers(1);
            setupCompareInputHandlers(2);
            
            // Color name search functionality for compare (uses the same hex/name input)
            function setupCompareNameSearch(colorNum) {
                const hexInput = document.getElementById(`cmw-compare-hex-${colorNum}`);
                const suggestionsEl = document.getElementById(`cmw-compare-suggestions-${colorNum}`);
                
                let debounceTimer = null;
                
                hexInput.addEventListener('input', () => {
                    clearTimeout(debounceTimer);
                    const query = hexInput.value.trim();
                    
                    // Only treat as hex if it's exactly 6 hex digits (with optional #)
                    // This allows numbers like "185" to trigger color name search (e.g., PANTONE 185)
                    const cleanHex = query.replace(/^#/, '');
                    const isValidHexCode = /^[0-9A-Fa-f]{6}$/.test(cleanHex);
                    
                    // If it's a valid 6-digit hex, update preview and hide suggestions
                    if (isValidHexCode) {
                        suggestionsEl.style.display = 'none';
                        updateCompareSwatchPreview(colorNum);
                        return;
                    }
                    
                    if (query.length < 2) {
                        suggestionsEl.style.display = 'none';
                        return;
                    }
                    
                    debounceTimer = setTimeout(async () => {
                        const results = searchByNameComplete(query);
                        
                        if (results.length === 0) {
                            suggestionsEl.style.display = 'none';
                            return;
                        }
                        
                        // Show up to 8 suggestions
                        const limitedResults = results.slice(0, 8);
                        
                        // Build suggestions with LittleCMS hex conversion
                        const suggestionHtmlPromises = limitedResults.map(async result => {
                            const color = result.color;
                            const libName = color.libraryName || libNames[color.library] || color.library || '';
                            // Shorten "Pantone" to "PMS" in color names for display
                            let displayName = color.name.replace(/^Pantone\s*/i, 'PMS ');
                            // Convert Crayola color names to lowercase
                            if (color.library === 'crayola') {
                                displayName = displayName.toLowerCase();
                            }
                            
                            // Use LittleCMS to convert Lab to hex
                            try {
                                const data = await convertColor({
                                    lab: [color.L, color.a, color.b],
                                    profile: 'sRGB.icc'
                                });
                                const hex = data.hex ? (data.hex.startsWith('#') ? data.hex : '#' + data.hex) : '#888888';
                                return `
                                    <div class="cmw-compare-suggestion-item" 
                                         data-hex="${color.hex || hex.replace('#', '')}" 
                                         data-lab-l="${color.L}" 
                                         data-lab-a="${color.a}" 
                                         data-lab-b="${color.b}" 
                                         data-name="${color.name}" 
                                         data-library="${libName}"
                                         data-rgb-r="${color.rgb_r !== undefined ? color.rgb_r : ''}"
                                         data-rgb-g="${color.rgb_g !== undefined ? color.rgb_g : ''}"
                                         data-rgb-b="${color.rgb_b !== undefined ? color.rgb_b : ''}"
                                         data-cmyk-c="${color.cmyk_c !== undefined ? color.cmyk_c : ''}"
                                         data-cmyk-m="${color.cmyk_m !== undefined ? color.cmyk_m : ''}"
                                         data-cmyk-y="${color.cmyk_y !== undefined ? color.cmyk_y : ''}"
                                         data-cmyk-k="${color.cmyk_k !== undefined ? color.cmyk_k : ''}">
                                        <div class="cmw-compare-suggestion-swatch" style="background: ${hex};"></div>
                                        <div class="cmw-compare-suggestion-info">
                                            <div class="cmw-compare-suggestion-name">${displayName}</div>
                                            <div class="cmw-compare-suggestion-library">${libName}</div>
                                        </div>
                                    </div>
                                `;
                            } catch (err) {
                                console.error('LittleCMS API unavailable for suggestion:', err);
                                return `
                                    <div class="cmw-compare-suggestion-item" 
                                         data-hex="${color.hex ? color.hex.replace('#', '') : '888888'}" 
                                         data-lab-l="${color.L}" 
                                         data-lab-a="${color.a}" 
                                         data-lab-b="${color.b}" 
                                         data-name="${color.name}" 
                                         data-library="${libName}"
                                         data-rgb-r="${color.rgb_r !== undefined ? color.rgb_r : ''}"
                                         data-rgb-g="${color.rgb_g !== undefined ? color.rgb_g : ''}"
                                         data-rgb-b="${color.rgb_b !== undefined ? color.rgb_b : ''}"
                                         data-cmyk-c="${color.cmyk_c !== undefined ? color.cmyk_c : ''}"
                                         data-cmyk-m="${color.cmyk_m !== undefined ? color.cmyk_m : ''}"
                                         data-cmyk-y="${color.cmyk_y !== undefined ? color.cmyk_y : ''}"
                                         data-cmyk-k="${color.cmyk_k !== undefined ? color.cmyk_k : ''}">
                                        <div class="cmw-compare-suggestion-swatch" style="background: #888888;"></div>
                                        <div class="cmw-compare-suggestion-info">
                                            <div class="cmw-compare-suggestion-name">${displayName}</div>
                                            <div class="cmw-compare-suggestion-library">${libName} (API Error)</div>
                                        </div>
                                    </div>
                                `;
                            }
                        });
                        
                        const suggestionHtml = await Promise.all(suggestionHtmlPromises);
                        suggestionsEl.innerHTML = suggestionHtml.join('');
                        
                        suggestionsEl.style.display = 'block';
                    }, 150);
                });
                
                // Handle suggestion click
                suggestionsEl.addEventListener('click', async (e) => {
                    const item = e.target.closest('.cmw-compare-suggestion-item');
                    if (item) {
                        const colorName = item.dataset.name;
                        const libraryName = item.dataset.library || '';
                        // Shorten "Pantone" to "PMS" for display
                        let displayName = colorName.replace(/^Pantone\s*/i, 'PMS ');
                        // Convert Crayola color names to lowercase
                        if (item.dataset.libraryId === 'crayola') {
                            displayName = displayName.toLowerCase();
                        }
                        // Use the known Lab values from the library directly
                        const L = parseFloat(item.dataset.labL);
                        const a = parseFloat(item.dataset.labA);
                        const b = parseFloat(item.dataset.labB);
                        
                        // Also get RGB & CMYK if available from library
                        const rgb_r = item.dataset.rgbR && item.dataset.rgbR !== '' ? parseFloat(item.dataset.rgbR) : undefined;
                        const rgb_g = item.dataset.rgbG && item.dataset.rgbG !== '' ? parseFloat(item.dataset.rgbG) : undefined;
                        const rgb_b = item.dataset.rgbB && item.dataset.rgbB !== '' ? parseFloat(item.dataset.rgbB) : undefined;
                        const cmyk_c = item.dataset.cmykC && item.dataset.cmykC !== '' ? parseFloat(item.dataset.cmykC) : undefined;
                        const cmyk_m = item.dataset.cmykM && item.dataset.cmykM !== '' ? parseFloat(item.dataset.cmykM) : undefined;
                        const cmyk_y = item.dataset.cmykY && item.dataset.cmykY !== '' ? parseFloat(item.dataset.cmykY) : undefined;
                        const cmyk_k = item.dataset.cmykK && item.dataset.cmykK !== '' ? parseFloat(item.dataset.cmykK) : undefined;
                        const libHex = item.dataset.hex || undefined;
                        
                        // Keep the color name in the input (don't convert to hex)
                        hexInput.value = displayName;
                        suggestionsEl.style.display = 'none';
                        
                        // Use LittleCMS to get accurate hex for display only (Lab → RGB uses sRGB)
                        try {
                            const data = await convertColor({
                                lab: [L, a, b],
                                profile: 'sRGB.icc'
                            });
                            if (!data.hex) {
                                throw new Error('LittleCMS did not return hex value');
                            }
                            const hex = data.hex.startsWith('#') ? data.hex : '#' + data.hex;
                            
                            // Store the original library Lab values, name, library, AND RGB/CMYK from library
                            const colorData = { 
                                lab: { L, a, b }, 
                                hex: libHex || hex, 
                                isLibraryColor: true, 
                                name: displayName, 
                                libraryName: libraryName,
                                rgb_r,
                                rgb_g,
                                rgb_b,
                                cmyk_c,
                                cmyk_m,
                                cmyk_y,
                                cmyk_k
                            };
                            const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                            const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                            
                            swatch.style.background = hex;
                            valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | ${hex}`;
                            
                            if (colorNum === 1) {
                                compareColor1 = colorData;
                            } else {
                                compareColor2 = colorData;
                            }
                        } catch (err) {
                            console.error('LittleCMS API unavailable:', err);
                            // Show error state - no fallback
                            const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                            const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                            
                            swatch.style.background = '#f0f0f0';
                            valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | API Error`;
                            
                            // Still store Lab values for Delta E calculation (Lab values are known) + RGB/CMYK from library
                            const colorData = { 
                                lab: { L, a, b }, 
                                hex: libHex || null, 
                                isLibraryColor: true, 
                                name: displayName, 
                                libraryName: libraryName,
                                rgb_r,
                                rgb_g,
                                rgb_b,
                                cmyk_c,
                                cmyk_m,
                                cmyk_y,
                                cmyk_k
                            };
                            if (colorNum === 1) {
                                compareColor1 = colorData;
                            } else {
                                compareColor2 = colorData;
                            }
                        }
                    }
                });
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!hexInput.contains(e.target) && !suggestionsEl.contains(e.target)) {
                        suggestionsEl.style.display = 'none';
                    }
                });
                
                // Handle Enter key to select first suggestion
                hexInput.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        const firstItem = suggestionsEl.querySelector('.cmw-compare-suggestion-item');
                        if (firstItem && suggestionsEl.style.display !== 'none') {
                            const colorName = firstItem.dataset.name;
                            const libraryName = firstItem.dataset.library || '';
                            // Shorten "Pantone" to "PMS" for display
                            let displayName = colorName.replace(/^Pantone\s*/i, 'PMS ');
                            // Convert Crayola color names to lowercase
                            if (firstItem.dataset.libraryId === 'crayola') {
                                displayName = displayName.toLowerCase();
                            }
                            // Use the known Lab values from the library directly
                            const L = parseFloat(firstItem.dataset.labL);
                            const a = parseFloat(firstItem.dataset.labA);
                            const b = parseFloat(firstItem.dataset.labB);
                            
                            // Also get RGB & CMYK if available from library
                            const rgb_r = firstItem.dataset.rgbR && firstItem.dataset.rgbR !== '' ? parseFloat(firstItem.dataset.rgbR) : undefined;
                            const rgb_g = firstItem.dataset.rgbG && firstItem.dataset.rgbG !== '' ? parseFloat(firstItem.dataset.rgbG) : undefined;
                            const rgb_b = firstItem.dataset.rgbB && firstItem.dataset.rgbB !== '' ? parseFloat(firstItem.dataset.rgbB) : undefined;
                            const cmyk_c = firstItem.dataset.cmykC && firstItem.dataset.cmykC !== '' ? parseFloat(firstItem.dataset.cmykC) : undefined;
                            const cmyk_m = firstItem.dataset.cmykM && firstItem.dataset.cmykM !== '' ? parseFloat(firstItem.dataset.cmykM) : undefined;
                            const cmyk_y = firstItem.dataset.cmykY && firstItem.dataset.cmykY !== '' ? parseFloat(firstItem.dataset.cmykY) : undefined;
                            const cmyk_k = firstItem.dataset.cmykK && firstItem.dataset.cmykK !== '' ? parseFloat(firstItem.dataset.cmykK) : undefined;
                            const libHex = firstItem.dataset.hex || undefined;
                            
                            // Keep the color name in the input
                            hexInput.value = displayName;
                            suggestionsEl.style.display = 'none';
                            e.preventDefault();
                            
                            // Use LittleCMS to get accurate hex for display only (Lab → RGB uses sRGB)
                            try {
                                const data = await convertColor({
                                    lab: [L, a, b],
                                    profile: 'sRGB.icc'
                                });
                                if (!data.hex) {
                                    throw new Error('LittleCMS did not return hex value');
                                }
                                const hex = data.hex.startsWith('#') ? data.hex : '#' + data.hex;
                                
                                // Store the original library Lab values, name, library, AND RGB/CMYK from library
                                const colorData = { 
                                    lab: { L, a, b }, 
                                    hex: libHex || hex, 
                                    isLibraryColor: true, 
                                    name: displayName, 
                                    libraryName: libraryName,
                                    rgb_r,
                                    rgb_g,
                                    rgb_b,
                                    cmyk_c,
                                    cmyk_m,
                                    cmyk_y,
                                    cmyk_k
                                };
                                const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                                const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                                
                                swatch.style.background = hex;
                                valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | ${hex}`;
                                
                                if (colorNum === 1) {
                                    compareColor1 = colorData;
                                } else {
                                    compareColor2 = colorData;
                                }
                            } catch (err) {
                                console.error('LittleCMS API unavailable:', err);
                                // Show error state - no fallback
                                const swatch = document.getElementById(`cmw-compare-swatch-${colorNum}`);
                                const valuesEl = document.getElementById(`cmw-compare-values-${colorNum}`);
                                
                                swatch.style.background = '#f0f0f0';
                                valuesEl.textContent = `Lab(${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}) | API Error`;
                                
                                // Still store Lab values for Delta E calculation (Lab values are known) + RGB/CMYK from library
                                const colorData = { 
                                    lab: { L, a, b }, 
                                    hex: libHex || null, 
                                    isLibraryColor: true, 
                                    name: displayName, 
                                    libraryName: libraryName,
                                    rgb_r,
                                    rgb_g,
                                    rgb_b,
                                    cmyk_c,
                                    cmyk_m,
                                    cmyk_y,
                                    cmyk_k
                                };
                                if (colorNum === 1) {
                                    compareColor1 = colorData;
                                } else {
                                    compareColor2 = colorData;
                                }
                            }
                        }
                    } else if (e.key === 'Escape') {
                        suggestionsEl.style.display = 'none';
                    }
                });
            }
            
            setupCompareNameSearch(1);
            setupCompareNameSearch(2);
            
            // Interpret deltaE value
            function interpretDeltaE(deltaE) {
                if (deltaE < 1) return 'Perfect Match';       // < 1
                if (deltaE <= 2) return 'Great Match';        // 1 - 2
                if (deltaE < 4) return 'Acceptable Match';    // 2.1 - 3.9
                if (deltaE <= 5) return 'Noticeable Difference';  // 4 - 5
                if (deltaE <= 10) return 'Clearly Different'; // 5.1 - 10
                return 'Very Different';                      // 10+
            }
            
            // Compare button click handler
            document.getElementById('cmw-compare-btn').addEventListener('click', async () => {
                const resultEl = document.getElementById('cmw-compare-result');
                const statusEl = document.getElementById('cmw-compare-status');
                
                statusEl.textContent = 'Converting colors...';
                statusEl.className = 'cmw-status show';
                
                // Only update colors that aren't already set from library selection
                // Library colors already have accurate Lab values stored
                if (!compareColor1 || !compareColor1.isLibraryColor) {
                    await updateCompareSwatchPreview(1);
                }
                if (!compareColor2 || !compareColor2.isLibraryColor) {
                    await updateCompareSwatchPreview(2);
                }
                
                if (!compareColor1 || !compareColor2) {
                    statusEl.textContent = 'Please enter valid values for both colors';
                    statusEl.className = 'cmw-status error show';
                    resultEl.classList.remove('show');
                    return;
                }
                
                statusEl.className = 'cmw-status';
                
                // Calculate deltaE2000 using the stored Lab values
                // For library colors, these are the original accurate values
                const lab1 = compareColor1.lab;
                const lab2 = compareColor2.lab;
                
                // Debug logging to trace Delta E calculation
                console.log('=== Color Compare Delta E Calculation ===');
                console.log('Color 1:', compareColor1.isLibraryColor ? 'LIBRARY' : 'CONVERTED', 
                    `Lab(${lab1.L}, ${lab1.a}, ${lab1.b})`, 
                    compareColor1.name || compareColor1.hex);
                console.log('Color 2:', compareColor2.isLibraryColor ? 'LIBRARY' : 'CONVERTED', 
                    `Lab(${lab2.L}, ${lab2.a}, ${lab2.b})`, 
                    compareColor2.name || compareColor2.hex);
                
                const deltaE = dE(lab1.L, lab1.a, lab1.b, lab2.L, lab2.a, lab2.b);
                console.log('Delta E 2000:', deltaE);
                
                // Update result display
                const deltaValueEl = document.getElementById('cmw-compare-delta-value');
                deltaValueEl.textContent = deltaE.toFixed(2);
                
                // Apply gradient color based on Delta E value
                // 1-3: green, 3-5: green to yellow to red gradient, 5+: red
                deltaValueEl.classList.remove('good', 'moderate', 'poor');
                let color;
                if (deltaE <= 3) {
                    // Solid green for 0-3
                    color = `hsl(120, 85%, 40%)`;
                } else if (deltaE <= 5) {
                    // Green (120°) to Yellow (60°) to Red (0°) - interpolate hue
                    // At 3: green, at 4: yellow, at 5: red
                    const t = (deltaE - 3) / 2; // 0 at deltaE=3, 0.5 at deltaE=4, 1 at deltaE=5
                    const hue = 120 - (t * 120); // 120 (green) -> 60 (yellow) -> 0 (red)
                    color = `hsl(${hue}, 85%, 45%)`;
                } else {
                    // Red for anything above 5
                    color = `hsl(0, 85%, 45%)`;
                }
                deltaValueEl.style.color = color;
                
                document.getElementById('cmw-compare-delta-interpretation').textContent = interpretDeltaE(deltaE);
                
                // Show result
                resultEl.classList.add('show');
            });
            
            // Clear button
            document.getElementById('cmw-compare-clear-btn').addEventListener('click', () => {
                // Clear inputs
                document.getElementById('cmw-compare-hex-1').value = '';
                document.getElementById('cmw-compare-hex-2').value = '';
                ['l', 'a', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-lab-${comp}-1`).value = '';
                    document.getElementById(`cmw-compare-lab-${comp}-2`).value = '';
                });
                ['r', 'g', 'b'].forEach(comp => {
                    document.getElementById(`cmw-compare-rgb-${comp}-1`).value = '';
                    document.getElementById(`cmw-compare-rgb-${comp}-2`).value = '';
                });
                ['c', 'm', 'y', 'k'].forEach(comp => {
                    document.getElementById(`cmw-compare-cmyk-${comp}-1`).value = '';
                    document.getElementById(`cmw-compare-cmyk-${comp}-2`).value = '';
                });
                
                // Hide suggestions
                document.getElementById('cmw-compare-suggestions-1').style.display = 'none';
                document.getElementById('cmw-compare-suggestions-2').style.display = 'none';
                
                // Reset swatches
                document.getElementById('cmw-compare-swatch-1').style.background = '#f0f0f0';
                document.getElementById('cmw-compare-swatch-2').style.background = '#f0f0f0';
                document.getElementById('cmw-compare-values-1').textContent = 'Lab: — | Hex: —';
                document.getElementById('cmw-compare-values-2').textContent = 'Lab: — | Hex: —';
                
                // Hide result and reset delta value color
                document.getElementById('cmw-compare-result').classList.remove('show');
                document.getElementById('cmw-compare-delta-value').style.color = '';
                document.getElementById('cmw-compare-status').className = 'cmw-status';
                
                // Reset colors
                compareColor1 = null;
                compareColor2 = null;
            });
            

            /* ─────────────────────
               Custom Libraries Feature (Multi-Library)
               ───────────────────── */
            
            // Storage for all custom libraries: { libraryId: { name, colors: [] } }
            const CUSTOM_LIBRARIES_KEY = 'cmw_custom_libraries';
            let customLibraries = {};
            let currentCustomLibraryId = null;
            
            // Generate a unique library ID
            function generateLibraryId(name) {
                return 'custom_' + name.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_' + Date.now();
            }
            
            // Load all custom libraries from localStorage
            function loadCustomLibraries() {
                try {
                    const stored = localStorage.getItem(CUSTOM_LIBRARIES_KEY);
                    if (stored) {
                        customLibraries = JSON.parse(stored);
                    }
                } catch (e) {
                    console.error('Failed to load custom libraries:', e);
                    customLibraries = {};
                }
                updateLibraryToggles();
                updateLibrarySelector();
                syncCustomLibsToSearch();
            }
            
            // Save all custom libraries to localStorage
            function saveCustomLibraries() {
                try {
                    localStorage.setItem(CUSTOM_LIBRARIES_KEY, JSON.stringify(customLibraries));
                    updateLibraryToggles();
                    syncCustomLibsToSearch();
                } catch (e) {
                    console.error('Failed to save custom libraries:', e);
                }
            }
            
            // Sync custom libraries to the libs object for search
            function syncCustomLibsToSearch() {
                // Remove old custom libs from libs object
                Object.keys(libs).forEach(key => {
                    if (key.startsWith('custom_')) {
                        delete libs[key];
                        delete libNames[key];
                    }
                });
                // Add current custom libraries with libraryName set
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    if (lib.colors && lib.colors.length > 0) {
                        // Add libraryName to each color so it shows correctly in results
                        libs[id] = lib.colors.map(color => ({
                            ...color,
                            library: id,
                            libraryName: lib.name // Use the custom library's name
                        }));
                        // Also add to libNames for fallback lookups
                        libNames[id] = lib.name;
                        
                        // Debug: Check if Amazon links are present
                        const colorsWithLinks = lib.colors.filter(c => c.amazon_link || c.amazonLink).length;
                        if (colorsWithLinks > 0) {
                            console.log(`📦 Library "${lib.name}": ${colorsWithLinks}/${lib.colors.length} colors have Amazon links`);
                        }
                    }
                });
            }
            
            // Update the library toggles in the main list (only show libraries with colors)
            function updateLibraryToggles() {
                const container = document.getElementById('cmw-custom-libraries-container');
                if (!container) {
                    console.warn('Custom libraries container not ready yet');
                    return;
                }
                container.innerHTML = '';
                
                let customLibCount = 0;
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    if (lib.colors && lib.colors.length > 0) {
                        const div = document.createElement('div');
                        div.className = 'cmw-toggle-item';
                        div.innerHTML = `
                            <input type="checkbox" id="toggle-${id}" value="${id}" checked>
                            <label for="toggle-${id}">${lib.name} <span class="cmw-library-count" id="count-${id}">(${lib.colors.length})</span></label>
                        `;
                        container.appendChild(div);
                        customLibCount++;
                    }
                });
                console.log(`✔ ${customLibCount} custom libraries added to toggles`);
            }
            
            // Update the library selector dropdown
            function updateLibrarySelector() {
                const select = document.getElementById('cmw-custom-library-select');
                const currentValue = select.value;
                
                select.innerHTML = '<option value="">-- Select or Create --</option>';
                
                console.log('updateLibrarySelector called. libraryManifest:', libraryManifest, 'libs:', Object.keys(libs));
                
                // Add public libraries first (with "public-" prefix to distinguish)
                if (libraryManifest && libraryManifest.length > 0) {
                    const publicGroup = document.createElement('optgroup');
                    publicGroup.label = 'Public Libraries';
                    
                    libraryManifest.forEach(lib => {
                        const option = document.createElement('option');
                        option.value = `public-${lib.id}`;
                        const colorCount = libs[lib.id] ? libs[lib.id].length : 0;
                        option.textContent = `${lib.name} (${colorCount})`;
                        publicGroup.appendChild(option);
                    });
                    
                    select.appendChild(publicGroup);
                }
                
                // Add custom libraries (if any exist)
                if (Object.keys(customLibraries).length > 0) {
                    const customGroup = document.createElement('optgroup');
                    customGroup.label = 'Custom Libraries';
                    
                    Object.entries(customLibraries).forEach(([id, lib]) => {
                        const option = document.createElement('option');
                        option.value = id;
                        option.textContent = `${lib.name} (${lib.colors?.length || 0})`;
                        customGroup.appendChild(option);
                    });
                    
                    select.appendChild(customGroup);
                }
                
                // Restore selection if still valid
                if (currentValue) {
                    if (currentValue.startsWith('public-')) {
                        // Check if public library still exists
                        const publicId = currentValue.substring(7); // Remove "public-" prefix
                        if (libraryManifest.some(lib => lib.id === publicId)) {
                            select.value = currentValue;
                        }
                    } else if (customLibraries[currentValue]) {
                        // Custom library
                        select.value = currentValue;
                    }
                }
            }
            
            // Select a library to edit
            function selectLibrary(libraryId) {
                currentCustomLibraryId = libraryId;
                
                const infoEl = document.getElementById('cmw-current-library-info');
                const formEl = document.getElementById('cmw-custom-add-form');
                const listEl = document.getElementById('cmw-custom-library-list');
                const actionsEl = document.querySelector('.cmw-custom-library-actions');
                
                // Check if it's a public library (starts with "public-")
                const isPublicLibrary = libraryId && libraryId.startsWith('public-');
                
                if (!libraryId) {
                    currentCustomLibraryId = null;
                    infoEl.style.display = 'none';
                    formEl.style.display = 'none';
                    const deleteBtn = document.getElementById('cmw-delete-library-btn');
                    const exportBtn = document.getElementById('cmw-custom-export-btn');
                    const importBtn = document.getElementById('cmw-custom-import-btn');
                    if (deleteBtn) deleteBtn.style.display = 'none';
                    if (exportBtn) exportBtn.style.display = 'none';
                    if (importBtn) importBtn.style.display = 'inline-block'; // Keep import visible - it creates new libraries
                    if (actionsEl) actionsEl.style.display = 'flex'; // Show container for import button
                    listEl.innerHTML = '<div class="cmw-custom-empty">Select or create a library to add colors.</div>';
                    return;
                }
                
                let lib, libName, colorCount;
                
                if (isPublicLibrary) {
                    // Handle public library
                    const publicId = libraryId.substring(7); // Remove "public-" prefix
                    const manifestEntry = libraryManifest.find(l => l.id === publicId);
                    
                    if (!manifestEntry || !libs[publicId]) {
                        currentCustomLibraryId = null;
                        infoEl.style.display = 'none';
                        formEl.style.display = 'none';
                        const deleteBtn = document.getElementById('cmw-delete-library-btn');
                        const exportBtn = document.getElementById('cmw-custom-export-btn');
                        const importBtn = document.getElementById('cmw-custom-import-btn');
                        if (deleteBtn) deleteBtn.style.display = 'none';
                        if (exportBtn) exportBtn.style.display = 'none';
                        if (importBtn) importBtn.style.display = 'inline-block'; // Keep import visible
                        if (actionsEl) actionsEl.style.display = 'flex';
                        listEl.innerHTML = '<div class="cmw-custom-empty">Library not found.</div>';
                        return;
                    }
                    
                    libName = manifestEntry.name;
                    colorCount = libs[publicId].length;
                    
                    // Show library info (read-only for public libraries)
                    document.getElementById('cmw-current-library-name').textContent = libName + ' (Read-Only)';
                    document.getElementById('cmw-current-library-count').textContent = `(${colorCount} colors)`;
                    
                    // Hide delete button for public libraries
                    const deleteBtn = document.getElementById('cmw-delete-library-btn');
                    if (deleteBtn) deleteBtn.style.display = 'none';
                    
                    // Show both export and import buttons (import creates new library, not editing current)
                    const exportBtn = document.getElementById('cmw-custom-export-btn');
                    const importBtn = document.getElementById('cmw-custom-import-btn');
                    if (exportBtn) exportBtn.style.display = 'inline-block';
                    if (importBtn) importBtn.style.display = 'inline-block';
                    
                    infoEl.style.display = 'block';
                    formEl.style.display = 'none'; // Hide add form for public libraries
                    if (actionsEl) actionsEl.style.display = 'flex'; // Show actions container for export/import buttons
                } else {
                    // Handle custom library
                    if (!customLibraries[libraryId]) {
                        currentCustomLibraryId = null;
                        infoEl.style.display = 'none';
                        formEl.style.display = 'none';
                        const deleteBtn = document.getElementById('cmw-delete-library-btn');
                        const exportBtn = document.getElementById('cmw-custom-export-btn');
                        const importBtn = document.getElementById('cmw-custom-import-btn');
                        if (deleteBtn) deleteBtn.style.display = 'none';
                        if (exportBtn) exportBtn.style.display = 'none';
                        if (importBtn) importBtn.style.display = 'inline-block'; // Keep import visible
                        if (actionsEl) actionsEl.style.display = 'flex';
                        listEl.innerHTML = '<div class="cmw-custom-empty">Select or create a library to add colors.</div>';
                        return;
                    }
                    
                    lib = customLibraries[libraryId];
                    
                    // Show library info
                    document.getElementById('cmw-current-library-name').textContent = lib.name;
                    document.getElementById('cmw-current-library-count').textContent = `(${lib.colors?.length || 0} colors)`;
                    
                    // Show delete button for custom libraries
                    const deleteBtn = document.getElementById('cmw-delete-library-btn');
                    if (deleteBtn) deleteBtn.style.display = 'inline-block';
                    
                    // Show both export and import buttons for custom libraries
                    const exportBtn = document.getElementById('cmw-custom-export-btn');
                    const importBtn = document.getElementById('cmw-custom-import-btn');
                    if (exportBtn) exportBtn.style.display = 'inline-block';
                    if (importBtn) importBtn.style.display = 'inline-block';
                    
                    infoEl.style.display = 'block';
                    formEl.style.display = 'flex';
                    if (actionsEl) actionsEl.style.display = 'flex'; // Show export/import buttons for custom libraries
                }
                
                // Render colors
                renderCurrentLibraryColors();
            }
            
            // Render colors for the current library
            function renderCurrentLibraryColors() {
                const container = document.getElementById('cmw-custom-library-list');
                
                if (!currentCustomLibraryId) {
                    container.innerHTML = '<div class="cmw-custom-empty">Select or create a library to add colors.</div>';
                    return;
                }
                
                // Check if it's a public library
                const isPublicLibrary = currentCustomLibraryId.startsWith('public-');
                let colors, libraryName;
                
                if (isPublicLibrary) {
                    // Handle public library
                    const publicId = currentCustomLibraryId.substring(7); // Remove "public-" prefix
                    const manifestEntry = libraryManifest.find(l => l.id === publicId);
                    
                    if (!manifestEntry || !libs[publicId]) {
                        container.innerHTML = '<div class="cmw-custom-empty">Library not found.</div>';
                        return;
                    }
                    
                    colors = libs[publicId] || [];
                    libraryName = manifestEntry.name;
                } else {
                    // Handle custom library
                    if (!customLibraries[currentCustomLibraryId]) {
                        container.innerHTML = '<div class="cmw-custom-empty">Select or create a library to add colors.</div>';
                        return;
                    }
                    
                    colors = customLibraries[currentCustomLibraryId].colors || [];
                    libraryName = customLibraries[currentCustomLibraryId].name;
                }
                
                if (colors.length === 0) {
                    container.innerHTML = '<div class="cmw-custom-empty">No colors in this library yet.</div>';
                    return;
                }
                
                container.innerHTML = colors.map((color, index) => {
                    const hasAmazonLink = color.amazon_link || color.amazonLink;
                    const amazonIndicator = hasAmazonLink ? ' <img src="https://www.amazon.com/favicon.ico" style="width: 16px; height: 16px; vertical-align: middle; margin-left: 4px;" title="Available on Amazon">' : '';
                    
                    // Only show remove button for custom libraries
                    const removeButton = isPublicLibrary ? '' : `<button class="cmw-custom-color-remove" data-index="${index}" title="Remove color" onclick="event.stopPropagation()">×</button>`;
                    
                    return `
                        <div class="cmw-custom-color-item" data-index="${index}" style="cursor: pointer;" title="${hasAmazonLink ? 'Click for details and purchase link' : 'Click for details'}">
                            <div class="cmw-custom-color-swatch" style="background: ${lab2rgb(color.L, color.a, color.b)}"></div>
                            <div class="cmw-custom-color-info">
                                <div class="cmw-custom-color-name">${color.name}${amazonIndicator}</div>
                                <div class="cmw-custom-color-values">Lab(${color.L.toFixed(2)}, ${color.a.toFixed(2)}, ${color.b.toFixed(2)})</div>
                            </div>
                            ${removeButton}
                        </div>
                    `;
                }).join('');
                
                // Add click handlers to show unified modal with all metadata
                container.querySelectorAll('.cmw-custom-color-item').forEach((item, index) => {
                    item.addEventListener('click', (e) => {
                        // Don't open modal if clicking the remove button
                        if (e.target.classList.contains('cmw-custom-color-remove')) return;
                        
                        const color = colors[index];
                        
                        // Get the actual displayed color from the swatch
                        const swatchElement = item.querySelector('.cmw-custom-color-swatch');
                        const displayColor = swatchElement ? window.getComputedStyle(swatchElement).backgroundColor : null;
                        
                        // Use the unified showColorModal function with all metadata (including RGB & CMYK)
                        showColorModal({
                            name: color.name,
                            library: color.library,
                            L: color.L,
                            a: color.a,
                            b: color.b,
                            libraryName: libraryName,
                            amazon_link: color.amazon_link || color.amazonLink,
                            manufacturer_link: color.manufacturer_link || color.manufacturerLink,
                            hex: color.hex,
                            originalHex: color.hex,
                            manufacturer: color.manufacturer,
                            filament_type: color.filament_type,
                            rgb_r: color.rgb_r,
                            rgb_g: color.rgb_g,
                            rgb_b: color.rgb_b,
                            cmyk_c: color.cmyk_c,
                            cmyk_m: color.cmyk_m,
                            cmyk_y: color.cmyk_y,
                            cmyk_k: color.cmyk_k,
                            spectral: color.spectral || null,
                            displayColor
                        });
                    });
                });
                
                // Update count display
                document.getElementById('cmw-current-library-count').textContent = `(${colors.length} colors)`;
            }
            
            // Create a new library
            function createNewLibrary() {
                const nameInput = document.getElementById('cmw-new-library-name');
                const statusEl = document.getElementById('cmw-custom-status');
                const name = nameInput.value.trim();
                
                if (!name) {
                    statusEl.textContent = 'Please enter a library name';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                // Check for duplicate names
                const exists = Object.values(customLibraries).some(lib => 
                    lib.name.toLowerCase() === name.toLowerCase()
                );
                
                if (exists) {
                    statusEl.textContent = 'A library with this name already exists';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                const id = generateLibraryId(name);
                customLibraries[id] = { name, colors: [] };
                saveCustomLibraries();
                updateLibrarySelector();
                
                // Update unified Color Libraries selector
                if (typeof populateLibrariesSelector === 'function') {
                    populateLibrariesSelector();
                }
                
                // Select the new library
                document.getElementById('cmw-custom-library-select').value = id;
                selectLibrary(id);
                
                nameInput.value = '';
                statusEl.textContent = `Created library "${name}"`;
                statusEl.className = 'cmw-status success show';
                setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
            }
            
            // Delete the current library
            function deleteCurrentLibrary() {
                if (!currentCustomLibraryId) return;
                
                const lib = customLibraries[currentCustomLibraryId];
                if (!confirm(`Delete library "${lib.name}" and all its colors?`)) return;
                
                delete customLibraries[currentCustomLibraryId];
                saveCustomLibraries();
                updateLibrarySelector();
                
                // Update unified Color Libraries selector
                if (typeof populateLibrariesSelector === 'function') {
                    populateLibrariesSelector();
                }
                
                document.getElementById('cmw-custom-library-select').value = '';
                selectLibrary(null);
                
                const statusEl = document.getElementById('cmw-custom-status');
                statusEl.textContent = `Deleted library "${lib.name}"`;
                statusEl.className = 'cmw-status success show';
                setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
            }
            
            // Get custom color values from inputs (uses LittleCMS API for conversions)
            async function getCustomColorValues() {
                const format = document.getElementById('cmw-custom-format').value;
                const name = document.getElementById('cmw-custom-color-name').value.trim();
                
                if (!name) {
                    throw new Error('Please enter a color name');
                }
                
                let L, a, b;
                
                if (format === 'hex') {
                    let hex = document.getElementById('cmw-custom-hex').value.trim();
                    if (!hex) throw new Error('Please enter a hex color');
                    if (!hex.startsWith('#')) hex = '#' + hex;
                    if (!/^#[0-9A-Fa-f]{6}$/i.test(hex)) {
                        throw new Error('Invalid hex format. Use RRGGBB');
                    }
                    const rgb = hex2rgb(hex);
                    // Use LittleCMS API for hex → Lab conversion
                    const data = await convertColor({
                        rgb: [rgb.r, rgb.g, rgb.b],
                        profile: 'sRGB.icc'
                    });
                    L = data.lab[0]; a = data.lab[1]; b = data.lab[2];
                } else if (format === 'lab') {
                    L = parseFloat(document.getElementById('cmw-custom-lab-l').value);
                    a = parseFloat(document.getElementById('cmw-custom-lab-a').value);
                    b = parseFloat(document.getElementById('cmw-custom-lab-b').value);
                    if (isNaN(L) || isNaN(a) || isNaN(b)) {
                        throw new Error('Please fill in all Lab values');
                    }
                    if (L < 0 || L > 100) throw new Error('L* must be between 0 and 100');
                } else if (format === 'rgb') {
                    const r = parseInt(document.getElementById('cmw-custom-rgb-r').value);
                    const g = parseInt(document.getElementById('cmw-custom-rgb-g').value);
                    const bVal = parseInt(document.getElementById('cmw-custom-rgb-b').value);
                    if (isNaN(r) || isNaN(g) || isNaN(bVal)) {
                        throw new Error('Please fill in all RGB values');
                    }
                    if (r < 0 || r > 255 || g < 0 || g > 255 || bVal < 0 || bVal > 255) {
                        throw new Error('RGB values must be between 0 and 255');
                    }
                    // Use LittleCMS API for RGB → Lab conversion
                    const data = await convertColor({
                        rgb: [r, g, bVal],
                        profile: 'sRGB.icc'
                    });
                    L = data.lab[0]; a = data.lab[1]; b = data.lab[2];
                } else if (format === 'cmyk') {
                    const c = parseFloat(document.getElementById('cmw-custom-cmyk-c').value);
                    const m = parseFloat(document.getElementById('cmw-custom-cmyk-m').value);
                    const y = parseFloat(document.getElementById('cmw-custom-cmyk-y').value);
                    const k = parseFloat(document.getElementById('cmw-custom-cmyk-k').value);
                    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
                        throw new Error('Please fill in all CMYK values');
                    }
                    // Use LittleCMS API for CMYK → Lab conversion
                    const data = await convertColor({
                        cmyk: [c, m, y, k],
                        profile: 'GRACoL2013.icc'
                    });
                    L = data.lab[0]; a = data.lab[1]; b = data.lab[2];
                }
                
                return { name, L, a, b };
            }
            
            // Clear custom color inputs
            function clearCustomInputs() {
                document.getElementById('cmw-custom-color-name').value = '';
                document.getElementById('cmw-custom-hex').value = '';
                document.getElementById('cmw-custom-lab-l').value = '';
                document.getElementById('cmw-custom-lab-a').value = '';
                document.getElementById('cmw-custom-lab-b').value = '';
                document.getElementById('cmw-custom-rgb-r').value = '';
                document.getElementById('cmw-custom-rgb-g').value = '';
                document.getElementById('cmw-custom-rgb-b').value = '';
                document.getElementById('cmw-custom-cmyk-c').value = '';
                document.getElementById('cmw-custom-cmyk-m').value = '';
                document.getElementById('cmw-custom-cmyk-y').value = '';
                document.getElementById('cmw-custom-cmyk-k').value = '';
            }
            
            // Add a color to the current library
            async function addCustomColor() {
                const statusEl = document.getElementById('cmw-custom-status');
                
                if (!currentCustomLibraryId) {
                    statusEl.textContent = 'Please select or create a library first';
                    statusEl.className = 'cmw-status error show';
                    return;
                }
                
                try {
                    statusEl.textContent = 'Converting color...';
                    statusEl.className = 'cmw-status show';
                    
                    const color = await getCustomColorValues();
                    customLibraries[currentCustomLibraryId].colors.push(color);
                    saveCustomLibraries();
                    renderCurrentLibraryColors();
                    updateLibrarySelector();
                    
                    // Update unified Color Libraries selector
                    if (typeof populateLibrariesSelector === 'function') {
                        populateLibrariesSelector();
                    }
                    
                    clearCustomInputs();
                    
                    statusEl.textContent = `Added "${color.name}" to ${customLibraries[currentCustomLibraryId].name}`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
                } catch (e) {
                    statusEl.textContent = e.message;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Remove a color from the current library
            function removeCustomColor(index) {
                if (!currentCustomLibraryId) return;
                customLibraries[currentCustomLibraryId].colors.splice(index, 1);
                saveCustomLibraries();
                renderCurrentLibraryColors();
                updateLibrarySelector();
            }
            
            // Export current library as JSON
            function exportCurrentLibrary() {
                if (!currentCustomLibraryId) {
                    alert('Please select a library to export');
                    return;
                }
                
                // Check if it's a public library
                const isPublicLibrary = currentCustomLibraryId.startsWith('public-');
                let lib;
                
                if (isPublicLibrary) {
                    // Handle public library export
                    const publicId = currentCustomLibraryId.substring(7); // Remove "public-" prefix
                    const manifestEntry = libraryManifest.find(l => l.id === publicId);
                    
                    if (!manifestEntry || !libs[publicId] || libs[publicId].length === 0) {
                        alert('Library has no colors to export');
                        return;
                    }
                    
                    // Create a library object for export
                    lib = {
                        name: manifestEntry.name,
                        colors: libs[publicId]
                    };
                } else {
                    // Handle custom library export
                    lib = customLibraries[currentCustomLibraryId];
                    if (!lib || !lib.colors || lib.colors.length === 0) {
                        alert('Library has no colors to export');
                        return;
                    }
                }
                
                // Show export format modal
                showExportFormatModal(lib);
            }
            
            function showExportFormatModal(library) {
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                `;
                
                // Create modal
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: white;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 400px;
                    width: 90%;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                `;
                
                modal.innerHTML = `
                    <h3 style="margin: 0 0 20px 0; color: #0065a3; font-size: 1.4rem;">Export "${library.name}"</h3>
                    <p style="color: #666; margin-bottom: 24px; font-size: 0.95rem;">Select export format:</p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button class="export-format-btn" data-format="json" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            cursor: pointer;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                        ">
                            <span style="font-weight: 600; color: #0065a3;">JSON</span>
                            <span style="color: #888; font-size: 0.85rem;">- Universal format, easy to edit</span>
                        </button>
                        
                        <button class="export-format-btn" data-format="csv" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            cursor: pointer;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                        ">
                            <span style="font-weight: 600; color: #0065a3;">CSV</span>
                            <span style="color: #888; font-size: 0.85rem;">- Excel compatible spreadsheet</span>
                        </button>
                        
                        <div class="export-format-btn-container" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                        ">
                            <div style="font-weight: 600; color: #0065a3; margin-bottom: 8px;">ASE - Adobe Swatch Exchange</div>
                            <div style="color: #666; font-size: 0.9rem; margin-bottom: 8px;">Photoshop/Illustrator/InDesign</div>
                            
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee;">
                                <div style="font-weight: 600; color: #333; margin-bottom: 8px; font-size: 0.9rem;">Color Mode:</div>
                                
                                <label style="display: flex; align-items: start; gap: 8px; margin-bottom: 8px; cursor: pointer; padding: 8px; border-radius: 4px; background: #f8f9fa;">
                                    <input type="radio" name="ase-color-mode" value="rgb" checked style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: #0065a3; font-size: 0.9rem;">RGB (Recommended)</div>
                                        <div style="color: #666; font-size: 0.8rem;">Best for general use, web, digital • No gamut issues</div>
                                    </div>
                                </label>
                                
                                <label style="display: flex; align-items: start; gap: 8px; cursor: pointer; padding: 8px; border-radius: 4px;">
                                    <input type="radio" name="ase-color-mode" value="cmyk" style="margin-top: 2px;">
                                    <div>
                                        <div style="font-weight: 600; color: #333; font-size: 0.9rem;">CMYK (Print)</div>
                                        <div style="color: #666; font-size: 0.8rem;">GRACoL profile • Professional print workflows</div>
                                    </div>
                                </label>
                                
                                <button class="export-ase-btn" data-format="ase" style="
                                    margin-top: 12px;
                                    width: 100%;
                                    padding: 10px 16px;
                                    border: none;
                                    border-radius: 6px;
                                    background: linear-gradient(135deg, #0065a3 0%, #004d7a 100%);
                                    color: white;
                                    cursor: pointer;
                                    font-size: 0.95rem;
                                    font-weight: 600;
                                    transition: all 0.2s;
                                ">Export ASE</button>
                            </div>
                        </div>
                        
                        <button class="export-format-btn" data-format="cxf" style="
                            padding: 14px 20px;
                            border: 2px solid #ddd;
                            border-radius: 8px;
                            background: white;
                            cursor: pointer;
                            font-size: 1rem;
                            transition: all 0.2s;
                            text-align: left;
                            display: flex;
                            align-items: center;
                            gap: 12px;
                        ">
                            <span style="font-weight: 600; color: #0065a3;">CXF</span>
                            <span style="color: #888; font-size: 0.85rem;">- Color Exchange Format (X-Rite standard)</span>
                        </button>
                    </div>
                    
                    <button id="export-cancel-btn" style="
                        margin-top: 20px;
                        width: 100%;
                        padding: 12px;
                        border: 2px solid #ddd;
                        border-radius: 8px;
                        background: white;
                        cursor: pointer;
                        font-size: 1rem;
                        color: #666;
                    ">Cancel</button>
                `;
                
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                // Add hover effects to containers and buttons
                const formatContainers = modal.querySelectorAll('.export-format-btn-container');
                formatContainers.forEach(container => {
                    container.addEventListener('mouseenter', () => {
                        container.style.borderColor = '#0065a3';
                        container.style.background = '#f0f8ff';
                    });
                    container.addEventListener('mouseleave', () => {
                        container.style.borderColor = '#ddd';
                        container.style.background = 'white';
                    });
                    
                    // Add hover effect to radio button labels
                    const labels = container.querySelectorAll('label');
                    labels.forEach(label => {
                        label.addEventListener('mouseenter', () => {
                            label.style.background = '#e8f4f8';
                        });
                        label.addEventListener('mouseleave', () => {
                            const radio = label.querySelector('input[type="radio"]');
                            if (!radio.checked) {
                                label.style.background = radio.value === 'rgb' ? '#f8f9fa' : 'transparent';
                            }
                        });
                    });
                });
                
                // Add click handlers to standard format buttons (JSON, CSV, CXF)
                const formatButtons = modal.querySelectorAll('.export-format-btn');
                formatButtons.forEach(btn => {
                    btn.addEventListener('mouseenter', () => {
                        btn.style.borderColor = '#0065a3';
                        btn.style.background = '#f0f8ff';
                    });
                    btn.addEventListener('mouseleave', () => {
                        btn.style.borderColor = '#ddd';
                        btn.style.background = 'white';
                    });
                    
                    btn.addEventListener('click', async () => {
                        const format = btn.dataset.format;
                        document.body.removeChild(overlay);
                        await exportLibraryInFormat(library, format, null);
                    });
                });
                
                // Handle ASE export button separately
                const aseBtn = modal.querySelector('.export-ase-btn');
                if (aseBtn) {
                    aseBtn.addEventListener('mouseenter', () => {
                        aseBtn.style.background = 'linear-gradient(135deg, #0077c2 0%, #005a8a 100%)';
                        aseBtn.style.transform = 'translateY(-2px)';
                        aseBtn.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                    });
                    aseBtn.addEventListener('mouseleave', () => {
                        aseBtn.style.background = 'linear-gradient(135deg, #0065a3 0%, #004d7a 100%)';
                        aseBtn.style.transform = 'translateY(0)';
                        aseBtn.style.boxShadow = 'none';
                    });
                    
                    aseBtn.addEventListener('click', async () => {
                        const selectedMode = modal.querySelector('input[name="ase-color-mode"]:checked');
                        const colorMode = selectedMode ? selectedMode.value : 'rgb';  // Default to RGB
                        console.log('ASE Export clicked - Color Mode:', colorMode);
                        
                        document.body.removeChild(overlay);
                        await exportLibraryInFormat(library, 'ase', colorMode);
                    });
                }
                
                // Cancel button
                modal.querySelector('#export-cancel-btn').addEventListener('click', () => {
                    document.body.removeChild(overlay);
                });
                
                // Click outside to close
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        document.body.removeChild(overlay);
                    }
                });
            }
            
            async function exportLibraryInFormat(library, format, colorMode = null) {
                console.log('exportLibraryInFormat called:', { format, colorMode, library: library.name });
                const sanitizedName = library.name.replace(/[^a-z0-9]/gi, '_');
                
                try {
                    switch (format) {
                        case 'json':
                            await exportAsJSON(library, sanitizedName);
                            break;
                        case 'csv':
                            exportAsCSV(library, sanitizedName);
                            break;
                        case 'ase':
                            console.log('Calling exportAsASE with colorMode:', colorMode || 'rgb');
                            await exportAsASE(library, sanitizedName, colorMode || 'rgb');
                            break;
                        case 'cxf':
                            await exportAsCXF(library, sanitizedName);
                            break;
                    }
                } catch (error) {
                    console.error('Export error:', error);
                    alert(`Failed to export: ${error.message}`);
                }
            }
            
            async function exportAsJSON(library, filename) {
                console.log('Exporting library as JSON:', library.name, 'Colors:', library.colors.length);
                
                // Show progress message
                const statusEl = document.getElementById('cmw-custom-status');
                if (statusEl) {
                    statusEl.textContent = `Exporting ${library.colors.length} colors...`;
                    statusEl.className = 'cmw-status show';
                }
                
                const apiUrl = getApiBaseUrl();
                const exportData = [];
                
                try {
                    // Process colors and generate hex values via LittleCMS API if needed
                    for (let i = 0; i < library.colors.length; i++) {
                        const color = library.colors[i];
                        
                        // Update progress every 50 colors
                        if (statusEl && i % 50 === 0) {
                            statusEl.textContent = `Processing ${i + 1}/${library.colors.length}...`;
                        }
                        
                        const exportColor = {
                            name: color.name || 'Unnamed',
                            L: color.L,
                            a: color.a,
                            b: color.b,
                            hex: color.hex || color.Hex || null
                        };
                        
                        // If hex doesn't exist, generate it via LittleCMS API (proper sRGB.icc conversion)
                        if (!exportColor.hex) {
                            try {
                                const response = await fetch(`${apiUrl}/convert`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        lab: [color.L, color.a, color.b],
                                        profile: 'sRGB.icc',
                                        renderingIntent: 1  // Relative colorimetric
                                    })
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    if (data.hex) {
                                        exportColor.hex = '#' + data.hex.toUpperCase();
                                    }
                                    // Add RGB from LittleCMS
                                    if (data.rgb && Array.isArray(data.rgb)) {
                                        exportColor.rgb_r = Math.round(data.rgb[0]);
                                        exportColor.rgb_g = Math.round(data.rgb[1]);
                                        exportColor.rgb_b = Math.round(data.rgb[2]);
                                    }
                                }
                            } catch (e) {
                                console.error(`LittleCMS conversion failed for ${color.name}:`, e);
                                // Skip this color if conversion fails
                                continue;
                            }
                        } else {
                            // Hex exists, include RGB if available
                            if (color.rgb_r !== undefined) exportColor.rgb_r = color.rgb_r;
                            if (color.rgb_g !== undefined) exportColor.rgb_g = color.rgb_g;
                            if (color.rgb_b !== undefined) exportColor.rgb_b = color.rgb_b;
                        }
                        
                        // Add optional metadata fields
                        if (color.amazon_link || color.amazonLink) exportColor.amazon_link = color.amazon_link || color.amazonLink;
                        if (color.manufacturer_link || color.manufacturerLink) exportColor.manufacturer_link = color.manufacturer_link || color.manufacturerLink;
                        if (color.manufacturer) exportColor.manufacturer = color.manufacturer;
                        if (color.filament_type) exportColor.filament_type = color.filament_type;
                        
                        exportData.push(exportColor);
                    }
                
                console.log('Export complete, creating JSON file with', exportData.length, 'colors');
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                downloadBlob(blob, `${filename}_colors.json`);
                
                // Show success message
                if (statusEl) {
                    statusEl.textContent = `Exported ${exportData.length} colors successfully!`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => {
                        statusEl.className = 'cmw-status';
                    }, 3000);
                }
                
                } catch (error) {
                    console.error('Export failed:', error);
                    if (statusEl) {
                        statusEl.textContent = `Export failed: ${error.message}`;
                        statusEl.className = 'cmw-status error show';
                    }
                }
            }
            
            function exportAsCSV(library, filename) {
                // Create CSV header (use L*, a*, b* to match import expectations)
                let csv = 'Name,L*,a*,b*,Hex,Notes\n';
                
                // Add each color
                library.colors.forEach(color => {
                    const name = `"${(color.name || '').replace(/"/g, '""')}"`;
                    // Handle both data formats: {L, a, b} and {lab: [L, a, b]}
                    const L = (color.L !== undefined ? color.L : color.lab[0]).toFixed(2);
                    const a = (color.a !== undefined ? color.a : color.lab[1]).toFixed(2);
                    const b = (color.b !== undefined ? color.b : color.lab[2]).toFixed(2);
                    
                    // Use hex from library if available, otherwise use client-side conversion
                    // (Client-side conversion is not accurate - library should have hex values!)
                    let hex;
                    if (color.hex) {
                        hex = color.hex.startsWith('#') ? color.hex : '#' + color.hex;
                    } else {
                        console.warn(`⚠️ No hex value for ${color.name} - using client-side conversion (not accurate!)`);
                        hex = lab2hex(parseFloat(L), parseFloat(a), parseFloat(b));
                    }
                    const notes = `"${(color.notes || '').replace(/"/g, '""')}"`;
                    
                    csv += `${name},${L},${a},${b},${hex},${notes}\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                downloadBlob(blob, `${filename}_colors.csv`);
            }
            
            async function exportAsASE(library, filename, colorMode) {
                // Send to backend for ASE generation
                // Prepare colors based on mode: send what we have, API will convert if needed
                const aseColors = library.colors.map(c => {
                    const color = {
                        name: c.name,
                        L: c.L,
                        a: c.a,
                        b: c.b
                    };
                    
                    // Include RGB if available (for RGB mode)
                    if (c.rgb_r !== undefined && c.rgb_g !== undefined && c.rgb_b !== undefined) {
                        color.rgb_r = c.rgb_r;
                        color.rgb_g = c.rgb_g;
                        color.rgb_b = c.rgb_b;
                    }
                    
                    // Include CMYK if available (for CMYK mode)
                    if (c.cmyk_c !== undefined && c.cmyk_m !== undefined && c.cmyk_y !== undefined && c.cmyk_k !== undefined) {
                        color.cmyk_c = c.cmyk_c;
                        color.cmyk_m = c.cmyk_m;
                        color.cmyk_y = c.cmyk_y;
                        color.cmyk_k = c.cmyk_k;
                    }
                    
                    return color;
                });
                
                const apiUrl = getApiBaseUrl();
                const response = await fetch(`${apiUrl}/export-ase`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        library_name: library.name,
                        colors: aseColors,
                        color_mode: colorMode  // Default: 'lab' (device-independent)
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`ASE export failed: ${errorText}`);
                }
                
                // Check for gamut warnings
                const warningCount = response.headers.get('X-Gamut-Warnings');
                const warningDetails = response.headers.get('X-Warning-Details');
                
                if (warningCount && parseInt(warningCount) > 0) {
                    const modeLabel = colorMode === 'rgb' ? 'sRGB' : 'CMYK/GRACoL';
                    let message = `⚠️ Gamut Warning: ${warningCount} color(s) are out of ${modeLabel} gamut and were clipped.\n\n`;
                    
                    if (warningDetails) {
                        message += `Examples:\n${warningDetails.replace(/; /g, '\n')}`;
                    }
                    
                    message += `\n\nThe colors were exported, but some may not match exactly due to gamut limitations.`;
                    alert(message);
                }
                
                const blob = await response.blob();
                const modeLabel = colorMode.toUpperCase();
                downloadBlob(blob, `${filename}_${modeLabel}_colors.ase`);
            }
            
            async function exportAsCXF(library, filename) {
                // Send to backend for CXF generation
                // CXF only needs name and Lab values - strip extra fields
                const cxfColors = library.colors.map(c => ({
                    name: c.name,
                    L: c.L,
                    a: c.a,
                    b: c.b
                }));
                
                const apiUrl = getApiBaseUrl();
                const response = await fetch(`${apiUrl}/export-cxf`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        library_name: library.name,
                        colors: cxfColors
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`CXF export failed: ${errorText}`);
                }
                
                const blob = await response.blob();
                downloadBlob(blob, `${filename}_colors.cxf`);
            }
            
            function downloadBlob(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            // Import library from JSON
            function importLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const imported = JSON.parse(e.target.result);
                        
                        let libraryName, colors;
                        
                        // Support both formats: { libraryName, colors } or just array of colors
                        if (imported.libraryName && Array.isArray(imported.colors)) {
                            libraryName = imported.libraryName;
                            colors = imported.colors;
                        } else if (Array.isArray(imported)) {
                            // Prompt for library name
                            libraryName = prompt('Enter a name for the imported library:', 'Imported Library');
                            if (!libraryName) return;
                            colors = imported;
                        } else {
                            throw new Error('Invalid format');
                        }
                        
                        // Auto-detect nested format and flatten it
                        if (colors.length > 0 && colors[0]) {
                            const first = colors[0];
                            console.log('📋 Import: First color structure:', first);
                            
                            const hasNestedStructure = (
                                (first.rgb && typeof first.rgb === 'object' && 'r' in first.rgb) ||
                                (first.lab && typeof first.lab === 'object' && 'l' in first.lab) ||
                                (first.cmyk && typeof first.cmyk === 'object' && 'c' in first.cmyk)
                            );
                            
                            if (hasNestedStructure) {
                                console.log('✓ Auto-detected nested format in imported file');
                                colors = parseNestedFormat(colors, libraryName);
                                console.log('📋 After parsing, first color:', colors[0]);
                            }
                        }
                        
                        // Validate colors and preserve all metadata (amazon_link, manufacturer_link, cmyk, etc.)
                        console.log(`📋 Validating ${colors.length} colors...`);
                        const validColors = [];
                        const invalidColors = [];
                        
                        for (let i = 0; i < colors.length; i++) {
                            const c = colors[i];
                            if (!c) {
                                invalidColors.push({ index: i, reason: 'null/undefined' });
                                continue;
                            }
                            if (typeof c.name !== 'string') {
                                invalidColors.push({ index: i, reason: 'missing/invalid name', color: c });
                                continue;
                            }
                            if (typeof c.L !== 'number') {
                                invalidColors.push({ index: i, reason: `missing/invalid L (type: ${typeof c.L})`, color: c });
                                continue;
                            }
                            if (typeof c.a !== 'number') {
                                invalidColors.push({ index: i, reason: `missing/invalid a (type: ${typeof c.a})`, color: c });
                                continue;
                            }
                            if (typeof c.b !== 'number') {
                                invalidColors.push({ index: i, reason: `missing/invalid b (type: ${typeof c.b})`, color: c });
                                continue;
                            }
                            
                            // Valid color - preserve all fields
                            validColors.push({
                                ...c, // Preserve all fields from original color object
                                name: c.name,
                                L: c.L,
                                a: c.a,
                                b: c.b
                            });
                        }
                        
                        if (invalidColors.length > 0) {
                            console.warn(`⚠ ${invalidColors.length} colors failed validation:`, invalidColors.slice(0, 3));
                        }
                        
                        if (validColors.length === 0) {
                            throw new Error(`No valid colors found in file. ${invalidColors.length} colors failed validation.`);
                        }
                        
                        console.log(`✓ ${validColors.length} valid colors ready for import`);
                        
                        // Create new library
                        const id = generateLibraryId(libraryName);
                        customLibraries[id] = { name: libraryName, colors: validColors };
                        saveCustomLibraries();
                        updateLibrarySelector();
                        
                        // Select the new library
                        document.getElementById('cmw-custom-library-select').value = id;
                        selectLibrary(id);
                        
                        statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors`;
                        statusEl.className = 'cmw-status success show';
                        setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
                    } catch (e) {
                        statusEl.textContent = `Import failed: ${e.message}`;
                        statusEl.className = 'cmw-status error show';
                    }
                };
                
                reader.readAsText(file);
            }
            
            // Import library from CXF (Color Exchange Format) file
            async function importCxfLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing CXF file...';
                statusEl.className = 'cmw-status show';
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch(`${API_URL}/import-cxf`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'CXF import failed');
                    }
                    
                    const data = await response.json();
                    
                    if (!data.colors || data.colors.length === 0) {
                        throw new Error('No colors found in CXF file');
                    }
                    
                    // Prompt for library name
                    let libraryName = data.file_info?.description || file.name.replace('.cxf', '');
                    libraryName = prompt('Enter a name for the imported library:', libraryName);
                    if (!libraryName) {
                        statusEl.className = 'cmw-status';
                        return;
                    }
                    
                    // Validate and format colors
                    const validColors = data.colors.filter(c => 
                        c && typeof c.name === 'string' && 
                        typeof c.L === 'number' && 
                        typeof c.a === 'number' && 
                        typeof c.b === 'number'
                    ).map(c => ({
                        name: c.name,
                        L: c.L,
                        a: c.a,
                        b: c.b,
                        // Include any additional data from CXF
                        ...(c.rgb && { rgb: c.rgb }),
                        ...(c.cmyk && { cmyk: c.cmyk }),
                        source: 'cxf'
                    }));
                    
                    if (validColors.length === 0) {
                        throw new Error('No valid Lab colors found in CXF file');
                    }
                    
                    // Create new library
                    const id = generateLibraryId(libraryName);
                    customLibraries[id] = { 
                        name: libraryName, 
                        colors: validColors,
                        source: 'cxf',
                        importedFrom: file.name,
                        importedAt: new Date().toISOString()
                    };
                    saveCustomLibraries();
                    updateLibrarySelector();
                    
                    // Select the new library
                    document.getElementById('cmw-custom-library-select').value = id;
                    selectLibrary(id);
                    
                    statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors from CXF`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                    
                } catch (e) {
                    console.error('CXF import error:', e);
                    statusEl.textContent = `CXF import failed: ${e.message}`;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Import library from ASE (Adobe Swatch Exchange) file
            async function importAseLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing ASE file...';
                statusEl.className = 'cmw-status show';
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch(`${API_URL}/import-ase`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'ASE import failed');
                    }
                    
                    const data = await response.json();
                    
                    if (!data.colors || data.colors.length === 0) {
                        throw new Error('No colors found in ASE file');
                    }
                    
                    // Prompt for library name
                    let libraryName = file.name.replace('.ase', '');
                    libraryName = prompt('Enter a name for the imported library:', libraryName);
                    if (!libraryName) {
                        statusEl.className = 'cmw-status';
                        return;
                    }
                    
                    // Validate and format colors
                    const validColors = data.colors.filter(c => 
                        c && typeof c.name === 'string' && 
                        typeof c.L === 'number' && 
                        typeof c.a === 'number' && 
                        typeof c.b === 'number'
                    ).map(c => ({
                        name: c.name,
                        L: c.L,
                        a: c.a,
                        b: c.b,
                        source: 'ase'
                    }));
                    
                    if (validColors.length === 0) {
                        throw new Error('No valid Lab colors found in ASE file');
                    }
                    
                    // Create new library
                    const id = generateLibraryId(libraryName);
                    customLibraries[id] = { 
                        name: libraryName, 
                        colors: validColors,
                        source: 'ase',
                        importedFrom: file.name,
                        importedAt: new Date().toISOString()
                    };
                    saveCustomLibraries();
                    updateLibrarySelector();
                    
                    // Select the new library
                    document.getElementById('cmw-custom-library-select').value = id;
                    selectLibrary(id);
                    
                    statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors from ASE`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                    
                } catch (e) {
                    console.error('ASE import error:', e);
                    statusEl.textContent = `ASE import failed: ${e.message}`;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // Import library from FilamentColors JSON format
            async function importFilamentColorsLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing Filament Colors...';
                statusEl.className = 'cmw-status show';
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch(`${API_URL}/import-filament-colors`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Filament colors import failed');
                    }
                    
                    const data = await response.json();
                    
                    if (!data.colors || data.colors.length === 0) {
                        throw new Error('No colors found in file');
                    }
                    
                    // Prompt for library name
                    let libraryName = data.source || file.name.replace('.json', '');
                    libraryName = prompt('Enter a name for the imported library:', libraryName);
                    if (!libraryName) {
                        statusEl.className = 'cmw-status';
                        return;
                    }
                    
                    // Format colors (they already have L, a, b from backend)
                    const validColors = data.colors.map(c => ({
                        name: c.name,
                        L: c.L,
                        a: c.a,
                        b: c.b,
                        manufacturer: c.manufacturer,
                        filament_type: c.filament_type,
                        hex: c.hex,
                        amazon_link: c.amazon_link,
                        manufacturer_link: c.manufacturer_link,
                        source: 'filament'
                    }));
                    
                    // Create new library
                    const id = generateLibraryId(libraryName);
                    customLibraries[id] = { 
                        name: libraryName, 
                        colors: validColors,
                        source: 'filament',
                        importedFrom: file.name,
                        importedAt: new Date().toISOString(),
                        stats: data.stats
                    };
                    saveCustomLibraries();
                    updateLibrarySelector();
                    
                    // Select the new library
                    document.getElementById('cmw-custom-library-select').value = id;
                    selectLibrary(id);
                    
                    let statsMsg = '';
                    if (data.stats) {
                        statsMsg = ` (${data.stats.converted_from_rgb} converted from RGB)`;
                    }
                    
                    statusEl.textContent = `Imported "${libraryName}" with ${validColors.length} colors${statsMsg}`;
                    statusEl.className = 'cmw-status success show';
                    setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                    
                } catch (e) {
                    console.error('Filament colors import error:', e);
                    statusEl.textContent = `Import failed: ${e.message}`;
                    statusEl.className = 'cmw-status error show';
                }
            }
            
            // CSV Import function
            async function importCsvLibrary(file) {
                const statusEl = document.getElementById('cmw-custom-status');
                const API_URL = document.getElementById('cmw-api-url').value;
                
                statusEl.textContent = 'Importing CSV file...';
                statusEl.className = 'cmw-status show';
                
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        const csvText = e.target.result;
                        const lines = csvText.split(/\r?\n/).filter(line => line.trim());
                        
                        if (lines.length < 2) {
                            throw new Error('CSV file must have a header row and at least one data row');
                        }
                        
                        // Parse header to find column indices
                        const header = lines[0].toLowerCase().split(',').map(h => h.trim().replace(/"/g, ''));
                        
                        // DEBUG: Show what we're looking at
                        console.log('CSV Header:', header);
                        
                        // Find column indices (flexible naming)
                        const findCol = (...names) => {
                            for (const name of names) {
                                const idx = header.findIndex(h => h.includes(name));
                                if (idx !== -1) return idx;
                            }
                            return -1;
                        };
                        
                        const nameCol = findCol('name', 'color', 'swatch');
                        
                        // Lab column detection - be VERY specific to avoid confusion with RGB 'b'
                        const lCol = (() => {
                            // Look for L* or L column (but not 'blue' or 'lightness')
                            const idx = header.findIndex(h => {
                                if (h.includes('blue') || h.includes('lightness')) return false;
                                return h === 'l' || h === 'l*' || h.includes('l*') || h.includes('l ') || h.includes(' l');
                            });
                            return idx;
                        })();
                        
                        const aCol = (() => {
                            // Look for a* or a column (but not 'alpha')
                            const idx = header.findIndex(h => {
                                if (h.includes('alpha')) return false;
                                return h === 'a' || h === 'a*' || h.includes('a*') || h.includes('a ') || h.includes(' a');
                            });
                            return idx;
                        })();
                        
                        const bCol = (() => {
                            // Look for b* column ONLY (not 'b' alone, which could be blue or RGB b)
                            const idx = header.findIndex(h => {
                                if (h.includes('blue')) return false;
                                return h === 'b' || h === 'b*' || h.includes('b*') || h.includes('b ') || h.includes(' b');
                            });
                            return idx;
                        })();
                        
                        const hexCol = findCol('hex', '#');
                        const rCol = findCol('r', 'red');
                        const gCol = findCol('g', 'green');
                        const blueCol = findCol('blue'); // Only look for 'blue', not 'b'
                        
                        // DEBUG: Show column detection
                        console.log('Column detection:', {
                            nameCol, lCol, aCol, bCol, hexCol, rCol, gCol, blueCol
                        });
                        
                        // Determine which format we have
                        const hasLab = lCol !== -1 && aCol !== -1 && bCol !== -1;
                        const hasHex = hexCol !== -1;
                        const hasRgb = rCol !== -1 && gCol !== -1 && blueCol !== -1 && !hasLab; // Only use RGB if no Lab
                        
                        console.log('Format detection:', { hasLab, hasHex, hasRgb });
                        console.log('IMPORTANT: hasLab =', hasLab, '- Will use Lab columns:', hasLab ? 'YES (ignoring Hex)' : 'NO');
                        
                        if (!hasLab && !hasHex && !hasRgb) {
                            throw new Error('CSV must have Lab (L*, a*, b*), Hex, or RGB columns');
                        }
                        
                        if (nameCol === -1) {
                            throw new Error('CSV must have a Name/Color column');
                        }
                        
                        const colors = [];
                        const parseValue = (val) => {
                            if (!val) return null;
                            val = val.trim().replace(/"/g, '');
                            const num = parseFloat(val);
                            return isNaN(num) ? null : num;
                        };
                        
                        // Process data rows
                        for (let i = 1; i < lines.length; i++) {
                            // Handle CSV with quoted values containing commas
                            const row = [];
                            let current = '';
                            let inQuotes = false;
                            for (const char of lines[i]) {
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    row.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            row.push(current.trim());
                            
                            const name = row[nameCol]?.replace(/"/g, '').trim();
                            if (!name) continue;
                            
                            let L, a, b;
                            
                            // HARD RULE: If Lab columns exist, NEVER use Hex conversion
                            if (hasLab) {
                                // Direct Lab values - use these first!
                                L = parseValue(row[lCol]);
                                a = parseValue(row[aCol]);
                                b = parseValue(row[bCol]);
                                console.log(`Row ${i}: ${name} -> L=${L}, a=${a}, b=${b} (from Lab columns - Hex IGNORED)`);
                                
                                // Skip to validation - DO NOT try Hex conversion
                            } 
                            // Only use Hex conversion if NO Lab columns were found
                            else if (!hasLab && hasHex) {
                                // Convert Hex to Lab using API
                                let hex = row[hexCol]?.replace(/"/g, '').trim();
                                if (!hex) continue;
                                if (!hex.startsWith('#')) hex = '#' + hex;
                                
                                try {
                                    const result = await convertColor({ hex, profile: 'sRGB.icc' });
                                    if (result && result.lab) {
                                        L = result.lab.L;
                                        a = result.lab.a;
                                        b = result.lab.b;
                                    }
                                } catch (err) {
                                    console.warn(`Failed to convert hex ${hex} for ${name}:`, err);
                                    continue;
                                }
                            } 
                            // Only use RGB if we have neither Lab nor Hex
                            else if (hasRgb && !hasLab && !hasHex) {
                                // Convert RGB to Lab using API
                                const r = parseValue(row[rCol]);
                                const g = parseValue(row[gCol]);
                                const blue = parseValue(row[blueCol]);
                                
                                if (r === null || g === null || blue === null) continue;
                                
                                try {
                                    const result = await convertColor({ rgb: [r, g, blue], profile: 'sRGB.icc' });
                                    if (result && result.lab) {
                                        L = result.lab.L;
                                        a = result.lab.a;
                                        b = result.lab.b;
                                    }
                                } catch (err) {
                                    console.warn(`Failed to convert RGB for ${name}:`, err);
                                    continue;
                                }
                            }
                            
                            if (L !== null && a !== null && b !== null) {
                                colors.push({ name, L, a, b, source: 'csv' });
                            }
                        }
                        
                        if (colors.length === 0) {
                            console.error('No colors extracted from CSV. Processed', lines.length - 1, 'data rows');
                            throw new Error('No valid colors found in CSV file. Check console for details.');
                        }
                        
                        console.log('Successfully extracted', colors.length, 'colors from CSV');
                        
                        // Prompt for library name
                        let libraryName = file.name.replace(/\.csv$/i, '');
                        libraryName = prompt('Enter a name for the imported library:', libraryName);
                        if (!libraryName) {
                            statusEl.className = 'cmw-status';
                            return;
                        }
                        
                        // Create new library
                        const id = generateLibraryId(libraryName);
                        customLibraries[id] = { 
                            name: libraryName, 
                            colors: colors,
                            source: 'csv',
                            importedFrom: file.name,
                            importedAt: new Date().toISOString()
                        };
                        saveCustomLibraries();
                        updateLibrarySelector();
                        
                        // Select the new library
                        document.getElementById('cmw-custom-library-select').value = id;
                        selectLibrary(id);
                        
                        statusEl.textContent = `Imported "${libraryName}" with ${colors.length} colors from CSV`;
                        statusEl.className = 'cmw-status success show';
                        setTimeout(() => { statusEl.className = 'cmw-status'; }, 4000);
                        
                    } catch (e) {
                        console.error('CSV import error:', e);
                        statusEl.textContent = `CSV import failed: ${e.message}`;
                        statusEl.className = 'cmw-status error show';
                    }
                };
                
                reader.onerror = () => {
                    statusEl.textContent = 'Failed to read CSV file';
                    statusEl.className = 'cmw-status error show';
                };
                
                reader.readAsText(file);
            }
            
            // Custom library toggle
            const customLibraryToggle = document.getElementById('cmw-custom-library-toggle');
            const customLibraryContent = document.getElementById('cmw-custom-library-content');
            
            customLibraryToggle.addEventListener('click', () => {
                const isCollapsed = customLibraryToggle.classList.contains('collapsed');
                
                if (isCollapsed) {
                    customLibraryToggle.classList.remove('collapsed');
                    customLibraryContent.classList.remove('collapsed');
                } else {
                    customLibraryToggle.classList.add('collapsed');
                    customLibraryContent.classList.add('collapsed');
                }
            });
            
            // Library selector
            document.getElementById('cmw-custom-library-select').addEventListener('change', (e) => {
                selectLibrary(e.target.value);
            });
            
            // Create library button
            document.getElementById('cmw-create-library-btn').addEventListener('click', createNewLibrary);
            document.getElementById('cmw-new-library-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') createNewLibrary();
            });
            
            // Delete library button
            document.getElementById('cmw-delete-library-btn').addEventListener('click', deleteCurrentLibrary);
            
            // Custom library format selector
            document.getElementById('cmw-custom-format').addEventListener('change', (e) => {
                const format = e.target.value;
                document.getElementById('cmw-custom-hex-inputs').classList.remove('active');
                document.getElementById('cmw-custom-lab-inputs').classList.remove('active');
                document.getElementById('cmw-custom-rgb-inputs').classList.remove('active');
                document.getElementById('cmw-custom-cmyk-inputs').classList.remove('active');
                document.getElementById(`cmw-custom-${format}-inputs`).classList.add('active');
                // Update swatch preview
                updateCustomPreviewSwatch();
            });
            
            // Update the custom library preview swatch as user types
            async function updateCustomPreviewSwatch() {
                const format = document.getElementById('cmw-custom-format').value;
                const swatch = document.getElementById('cmw-custom-preview-swatch');
                let hexColor = '#f0f0f0'; // Default gray
                
                try {
                    if (format === 'hex') {
                        const hex = document.getElementById('cmw-custom-hex').value.trim();
                        if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                            hexColor = '#' + hex;
                        }
                    } else if (format === 'lab') {
                        const L = parseFloat(document.getElementById('cmw-custom-lab-l').value);
                        const a = parseFloat(document.getElementById('cmw-custom-lab-a').value);
                        const b = parseFloat(document.getElementById('cmw-custom-lab-b').value);
                        if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                            hexColor = lab2rgb(L, a, b);
                        }
                    } else if (format === 'rgb') {
                        const r = parseInt(document.getElementById('cmw-custom-rgb-r').value);
                        const g = parseInt(document.getElementById('cmw-custom-rgb-g').value);
                        const b = parseInt(document.getElementById('cmw-custom-rgb-b').value);
                        if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                            hexColor = `rgb(${r}, ${g}, ${b})`;
                        }
                    } else if (format === 'cmyk') {
                        // Use LittleCMS API for accurate CMYK → Lab → RGB conversion
                        const c = parseFloat(document.getElementById('cmw-custom-cmyk-c').value);
                        const m = parseFloat(document.getElementById('cmw-custom-cmyk-m').value);
                        const y = parseFloat(document.getElementById('cmw-custom-cmyk-y').value);
                        const k = parseFloat(document.getElementById('cmw-custom-cmyk-k').value);
                        if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                            try {
                                // CMYK → Lab via LittleCMS with GRACoL profile
                                const data = await convertColor({
                                    cmyk: [c, m, y, k],
                                    profile: 'GRACoL2013.icc'
                                });
                                if (data && data.lab) {
                                    hexColor = lab2rgb(data.lab[0], data.lab[1], data.lab[2]);
                                }
                            } catch (e) {
                                console.error('CMYK preview conversion failed:', e);
                            }
                        }
                    }
                } catch (e) {
                    // Keep default gray on error
                }
                
                swatch.style.background = hexColor;
            }
            
            // Add input event listeners for live custom swatch preview
            document.getElementById('cmw-custom-hex').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-lab-l').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-lab-a').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-lab-b').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-rgb-r').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-rgb-g').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-rgb-b').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-c').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-m').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-y').addEventListener('input', updateCustomPreviewSwatch);
            document.getElementById('cmw-custom-cmyk-k').addEventListener('input', updateCustomPreviewSwatch);
            
            // Add color button
            document.getElementById('cmw-custom-add-btn').addEventListener('click', addCustomColor);
            
            // Export/Import buttons
            document.getElementById('cmw-custom-export-btn').addEventListener('click', exportCurrentLibrary);
            document.getElementById('cmw-custom-import-btn').addEventListener('click', () => {
                document.getElementById('cmw-custom-import-file').click();
            });
            document.getElementById('cmw-custom-import-file').addEventListener('change', async (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const ext = file.name.split('.').pop().toLowerCase();
                    
                    if (ext === 'json') {
                        // Check if it's a filament colors JSON
                        const reader = new FileReader();
                        reader.onload = async (e) => {
                            try {
                                const jsonContent = JSON.parse(e.target.result);
                                // Detect filament colors format
                                if (jsonContent.metadata && jsonContent.swatches && Array.isArray(jsonContent.swatches)) {
                                    // It's a filament colors JSON - use API import
                                    await importFilamentColorsLibrary(file);
                                } else {
                                    // Regular JSON import
                                    importLibrary(file);
                                }
                            } catch (err) {
                                console.error('Error detecting JSON format:', err);
                                importLibrary(file); // Fallback to regular import
                            }
                        };
                        reader.readAsText(file);
                    } else if (ext === 'cxf') {
                        importCxfLibrary(file);
                    } else if (ext === 'csv') {
                        importCsvLibrary(file);
                    } else if (ext === 'ase') {
                        importAseLibrary(file);
                    } else {
                        const statusEl = document.getElementById('cmw-custom-status');
                        statusEl.textContent = 'Unsupported file format. Use JSON, CXF, CSV, or ASE.';
                        statusEl.className = 'cmw-status error show';
                        setTimeout(() => { statusEl.className = 'cmw-status'; }, 3000);
                    }
                    e.target.value = '';
                }
            });
            
            // Remove color button delegation
            document.getElementById('cmw-custom-library-list').addEventListener('click', (e) => {
                if (e.target.classList.contains('cmw-custom-color-remove')) {
                    removeCustomColor(parseInt(e.target.dataset.index));
                }
            });
            
            // Enter key support
            document.getElementById('cmw-custom-color-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCustomColor();
            });
            document.getElementById('cmw-custom-hex').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addCustomColor();
            });

            /* ─────────────────────
               Color Info Modal
               ───────────────────── */
            
            const colorModal = {
                overlay: document.getElementById('cmw-color-modal-overlay'),
                swatch: document.getElementById('cmw-color-modal-swatch'),
                name: document.getElementById('cmw-color-modal-name'),
                lab: document.getElementById('cmw-modal-lab'),
                hex: document.getElementById('cmw-modal-hex'),
                rgb: document.getElementById('cmw-modal-rgb'),
                cmyk: document.getElementById('cmw-modal-cmyk'),
                closeBtn: document.getElementById('cmw-color-modal-close'),
                purchaseLinks: document.getElementById('cmw-modal-purchase-links'),
                amazonLink: document.getElementById('cmw-modal-amazon-link'),
                manufacturerLink: document.getElementById('cmw-modal-manufacturer-link'),
                currentColor: null,
                currentSpectralData: null
            };
            
            // Modal Tab Switching
            function initModalTabs() {
                const tabs = document.querySelectorAll('.cmw-modal-tab');
                console.log('🔧 Initializing modal tabs, found:', tabs.length);
                
                tabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.getAttribute('data-tab');
                        console.log('🔄 Tab clicked:', tabName);
                        
                        // Update active tab
                        document.querySelectorAll('.cmw-modal-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        
                        // Update active content
                        document.querySelectorAll('.cmw-modal-tab-content').forEach(content => {
                            content.classList.remove('active');
                        });
                        document.getElementById(`cmw-tab-${tabName}`).classList.add('active');
                        
                        // If switching to spectral tab and we have data, render the graph
                        if (tabName === 'spectral') {
                            console.log('📊 Spectral tab selected');
                            if (colorModal.currentSpectralData) {
                                console.log('✅ Spectral data available, rendering graph...');
                                renderSpectralGraph(colorModal.currentSpectralData);
                            } else {
                                console.warn('⚠️ No spectral data stored in colorModal.currentSpectralData');
                            }
                        }
                    });
                });
            }
            
            // Initialize tabs
            initModalTabs();
            
            // Render Spectral Reflectance Graph using Plotly
            function renderSpectralGraph(spectralData) {
                console.log('📊 renderSpectralGraph called with:', spectralData);
                
                if (!spectralData || !spectralData.wavelengths || !spectralData.reflectance) {
                    console.warn('⚠️ Invalid spectral data:', spectralData);
                    return;
                }
                
                // Check if Plotly is available
                if (typeof Plotly === 'undefined') {
                    console.error('❌ Plotly is not loaded!');
                    document.getElementById('cmw-spectral-graph').innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444;">Error: Plotly library not loaded. Please refresh the page.</div>';
                    return;
                }
                
                console.log('✅ Plotly available, rendering graph...');
                
                const graphDiv = document.getElementById('cmw-spectral-graph');
                if (!graphDiv) {
                    console.error('❌ Graph container not found!');
                    return;
                }
                
                console.log('✅ Graph container found:', graphDiv);
                
                try {
                    const trace = {
                        x: spectralData.wavelengths,
                        y: spectralData.reflectance,
                        type: 'scatter',
                        mode: 'lines+markers',
                        line: {
                            color: '#0065a3',
                            width: 3
                        },
                        marker: {
                            size: 6,
                            color: '#0065a3'
                        },
                        fill: 'tozeroy',
                        fillcolor: 'rgba(0, 101, 163, 0.1)',
                        name: 'Reflectance'
                    };
                    
                    const layout = {
                        title: {
                            text: 'Spectral Reflectance Curve',
                            font: { size: 16, family: 'Inter, sans-serif' }
                        },
                        xaxis: {
                            title: 'Wavelength (nm)',
                            gridcolor: '#e2e8f0',
                            range: [380, 720]
                        },
                        yaxis: {
                            title: 'Reflectance',
                            gridcolor: '#e2e8f0',
                            range: [0, 1],
                            tickformat: '.0%'
                        },
                        margin: { l: 60, r: 40, t: 60, b: 60 },
                        plot_bgcolor: '#ffffff',
                        paper_bgcolor: '#ffffff',
                        hovermode: 'closest'
                    };
                    
                    const config = {
                        responsive: true,
                        displayModeBar: true,
                        modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d'],
                        displaylogo: false
                    };
                    
                    console.log('🎨 Plotting graph with Plotly.newPlot...');
                    Plotly.newPlot('cmw-spectral-graph', [trace], layout, config);
                    console.log('✅ Graph rendered successfully!');
                    
                } catch (error) {
                    console.error('❌ Error rendering graph:', error);
                    graphDiv.innerHTML = '<div style="padding: 40px; text-align: center; color: #ef4444;">Error rendering graph: ' + error.message + '</div>';
                }
            }
            
            // Debug: Verify modal elements exist
            console.log('Color modal initialized:', {
                overlay: !!colorModal.overlay,
                swatch: !!colorModal.swatch,
                name: !!colorModal.name,
                lab: !!colorModal.lab,
                hex: !!colorModal.hex,
                rgb: !!colorModal.rgb,
                cmyk: !!colorModal.cmyk,
                closeBtn: !!colorModal.closeBtn
            });
            
            // Color History Navigation System
            let colorHistory = [];
            let currentHistoryIndex = -1;
            let originalColor = null; // The first color clicked
            
            const historyHomeBtn = document.getElementById('cmw-modal-history-home');
            const historyPrevBtn = document.getElementById('cmw-modal-history-prev');
            const historyNextBtn = document.getElementById('cmw-modal-history-next');
            
            // Update history navigation button states
            function updateHistoryNavigation() {
                if (colorHistory.length <= 1) {
                    // No history yet - hide all buttons
                    if (historyHomeBtn) historyHomeBtn.style.display = 'none';
                    if (historyPrevBtn) historyPrevBtn.style.display = 'none';
                    if (historyNextBtn) historyNextBtn.style.display = 'none';
                    return;
                }
                
                // Show home button always (after first click)
                if (historyHomeBtn) historyHomeBtn.style.display = 'inline-block';
                
                // Show prev/next based on position in history
                if (historyPrevBtn) {
                    historyPrevBtn.style.display = currentHistoryIndex > 0 ? 'inline-block' : 'none';
                    historyPrevBtn.disabled = currentHistoryIndex <= 0;
                }
                
                if (historyNextBtn) {
                    historyNextBtn.style.display = currentHistoryIndex < colorHistory.length - 1 ? 'inline-block' : 'none';
                    historyNextBtn.disabled = currentHistoryIndex >= colorHistory.length - 1;
                }
            }
            
            // Navigate to a specific color in history
            function navigateToHistoryIndex(index, skipHistory = true) {
                if (index < 0 || index >= colorHistory.length) return;
                
                currentHistoryIndex = index;
                const colorData = colorHistory[index];
                
                // Call showColorModal with skipHistory flag to avoid adding to history again
                showColorModal(colorData, skipHistory);
            }
            
            // History button event listeners
            if (historyHomeBtn) {
                historyHomeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (originalColor) {
                        navigateToHistoryIndex(0, true);
                    }
                });
                
                historyHomeBtn.addEventListener('mouseover', () => {
                    historyHomeBtn.style.background = '#f0f9ff';
                });
                historyHomeBtn.addEventListener('mouseout', () => {
                    historyHomeBtn.style.background = 'none';
                });
            }
            
            if (historyPrevBtn) {
                historyPrevBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentHistoryIndex > 0) {
                        navigateToHistoryIndex(currentHistoryIndex - 1, true);
                    }
                });
                
                historyPrevBtn.addEventListener('mouseover', () => {
                    if (!historyPrevBtn.disabled) historyPrevBtn.style.background = '#f0f9ff';
                });
                historyPrevBtn.addEventListener('mouseout', () => {
                    historyPrevBtn.style.background = 'none';
                });
            }
            
            if (historyNextBtn) {
                historyNextBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (currentHistoryIndex < colorHistory.length - 1) {
                        navigateToHistoryIndex(currentHistoryIndex + 1, true);
                    }
                });
                
                historyNextBtn.addEventListener('mouseover', () => {
                    if (!historyNextBtn.disabled) historyNextBtn.style.background = '#f0f9ff';
                });
                historyNextBtn.addEventListener('mouseout', () => {
                    historyNextBtn.style.background = 'none';
                });
            }
            
            /**
             * 🎨 UNIFIED COLOR MODAL SYSTEM
             * 
             * VISUAL CONSISTENCY RULE:
             * - Popup swatch = clicked swatch color (passed as displayColor)
             * 
             * DATA PRIORITY:
             * 1. USE LIBRARY VALUES (if available) - NO conversion needed
             *    - RGB values from library → display as-is
             *    - Hex values from library → display as-is  
             *    - CMYK values from library → display as-is
             * 
             * 2. FALLBACK TO API (if values missing) - Accurate CAT16 conversion
             *    - LittleCMS API with CAT16 chromatic adaptation
             *    - CIE Lab D50 → sRGB (sRGB.icc profile)
             *    - CIE Lab D50 → CMYK (GRACoL2013.icc profile)
             * 
             * All libraries MUST have Lab values. RGB/CMYK/Hex are optional.
             */
            async function showColorModal(colorData, skipHistory = false) {
                console.log('showColorModal called with:', colorData);
                const { name, L, a, b, originalHex, libraryName, amazon_link, manufacturer_link, cmyk_c, cmyk_m, cmyk_y, cmyk_k, rgb_r, rgb_g, rgb_b, hex, displayColor, spectral, lab_calculated } = colorData;
                
                // Store the full color data for menu actions
                colorModal.currentColorData = colorData;
                
                // Handle color history tracking
                if (!skipHistory) {
                    // If this is the first color clicked (history is empty), set it as the original
                    if (colorHistory.length === 0) {
                        originalColor = colorData;
                        colorHistory = [colorData];
                        currentHistoryIndex = 0;
                    } else {
                        // If we're in the middle of history and click a new color, truncate future history
                        if (currentHistoryIndex < colorHistory.length - 1) {
                            colorHistory = colorHistory.slice(0, currentHistoryIndex + 1);
                        }
                        
                        // Add new color to history
                        colorHistory.push(colorData);
                        currentHistoryIndex = colorHistory.length - 1;
                    }
                    
                    // Update navigation buttons
                    updateHistoryNavigation();
                } else {
                    // Just update navigation without changing history
                    updateHistoryNavigation();
                }
                
                // Format the display name based on library
                let displayName = '';
                let hasLibraryName = false;
                
                if (libraryName && name) {
                    hasLibraryName = true;
                    // Check if this is a Pantone/PMS color
                    if (libraryName === 'PMS' || libraryName.toLowerCase() === 'pantone') {
                        // For Pantone, format as "Pantone # C" (extract just the number/code part)
                        const pmsMatch = name.match(/^(?:PMS|Pantone)\s*(.+)$/i);
                        if (pmsMatch) {
                            displayName = `Pantone ${pmsMatch[1]}`;
                        } else {
                            displayName = `Pantone ${name}`;
                        }
                    } else {
                        // For other libraries, prepend library name
                        let colorName = name;
                        // Convert Crayola color names to lowercase
                        if (colorData.library === 'crayola' || libraryName.toLowerCase().includes('crayola')) {
                            colorName = colorName.toLowerCase();
                        }
                        displayName = `${libraryName} ${colorName}`;
                    }
                }
                
                // Store Lab values for adding to library
                colorModal.currentLabValues = { L, a, b };
                
                // Check what data we already have from the library
                const hasRGB = (typeof rgb_r === 'number' && typeof rgb_g === 'number' && typeof rgb_b === 'number');
                // Check if hex exists AND is not the placeholder gray value (#808080 or 808080)
                const hexUpper = hex ? hex.toUpperCase().replace('#', '') : '';
                const hasHex = (hex && typeof hex === 'string' && hexUpper !== '808080');
                const hasCMYK = (typeof cmyk_c === 'number' && typeof cmyk_m === 'number' && 
                                 typeof cmyk_y === 'number' && typeof cmyk_k === 'number');
                
                console.log('🎨 Modal Data Check:', {
                    name: displayName,
                    hasRGB,
                    hasHex,
                    hasCMYK,
                    hexValue: hex,
                    isPlaceholder: hexUpper === '808080',
                    needsAPI: !hasRGB || !hasHex || !hasCMYK
                });
                
                // Initialize values
                let hexValue = '#000000';
                let rgbValues = { r: 0, g: 0, b: 0 };
                let cmykValues = { c: 0, m: 0, y: 0, k: 100 };
                
                // USE KNOWN DATA FIRST - NO CONVERSION NEEDED!
                if (hasRGB) {
                    rgbValues = {
                        r: Math.round(rgb_r),
                        g: Math.round(rgb_g),
                        b: Math.round(rgb_b)
                    };
                    console.log('✓ Using RGB from library (no conversion):', rgbValues);
                }
                
                if (hasHex) {
                    hexValue = hex.toUpperCase();
                    if (!hexValue.startsWith('#')) hexValue = '#' + hexValue;
                    console.log('✓ Using Hex from library (no conversion):', hexValue);
                } else if (hex && hexUpper === '808080') {
                    console.log('⚠️ Hex is placeholder gray (#808080) - will convert from Lab');
                }
                
                if (hasCMYK) {
                    cmykValues = { c: cmyk_c, m: cmyk_m, y: cmyk_y, k: cmyk_k };
                    console.log('✓ Using CMYK from library (no conversion):', cmykValues);
                }
                
                // Only fetch from API if we're missing data
                const needsRGB = !hasRGB;
                const needsHex = !hasHex;
                const needsCMYK = !hasCMYK;
                
                if (needsRGB || needsHex || needsCMYK) {
                    console.log('⚙️ Fetching missing data from LittleCMS API...', {
                        needsRGB,
                        needsHex,
                        needsCMYK
                    });
                    
                    try {
                        const apiUrl = getApiBaseUrl();
                        const currentIntent = document.getElementById('cmw-default-intent')?.value || '1';
                        const renderingIntent = currentIntent !== 'none' ? parseInt(currentIntent) : 1;
                        
                        // Only make API calls for what we need
                        const apiCalls = [];
                        
                        if (needsRGB || needsHex) {
                            apiCalls.push(
                                fetch(`${apiUrl}/convert`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        lab: [L, a, b],
                                        profile: 'sRGB.icc',
                                        renderingIntent: renderingIntent
                                    })
                                })
                            );
                        } else {
                            apiCalls.push(null);
                        }
                        
                        if (needsCMYK) {
                            apiCalls.push(
                                fetch(`${apiUrl}/convert`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        lab: [L, a, b],
                                        profile: 'GRACoL2013.icc',
                                        renderingIntent: renderingIntent
                                    })
                                })
                            );
                        } else {
                            apiCalls.push(null);
                        }
                        
                        const [srgbResponse, cmykResponse] = await Promise.all(apiCalls);
                        
                        // Process sRGB API response if we made the call
                        if (srgbResponse && srgbResponse.ok) {
                            const srgbData = await srgbResponse.json();
                            console.log('📥 LittleCMS sRGB API response:', srgbData);
                            
                            if (needsRGB && srgbData.rgb && Array.isArray(srgbData.rgb)) {
                                rgbValues = {
                                    r: Math.round(srgbData.rgb[0]),
                                    g: Math.round(srgbData.rgb[1]),
                                    b: Math.round(srgbData.rgb[2])
                                };
                                console.log('✓ RGB from LittleCMS API:', rgbValues);
                            } else if (needsRGB) {
                                console.error('❌ API returned but no RGB data:', srgbData);
                            }
                            
                            if (needsHex && srgbData.hex) {
                                hexValue = srgbData.hex.toUpperCase();
                                if (!hexValue.startsWith('#')) hexValue = '#' + hexValue;
                                console.log('✓ Hex from LittleCMS API:', hexValue);
                            } else if (needsHex) {
                                console.error('❌ API returned but no hex data:', srgbData);
                            }
                        } else if (srgbResponse) {
                            console.error('❌ LittleCMS sRGB API failed:', srgbResponse.status, srgbResponse.statusText);
                        }
                        
                        // Build hex from API-provided RGB if needed (just encoding, not conversion)
                        if (needsHex && hexValue === '#000000' && rgbValues.r !== 0 && rgbValues.g !== 0 && rgbValues.b !== 0) {
                            hexValue = `#${rgbValues.r.toString(16).padStart(2, '0')}${rgbValues.g.toString(16).padStart(2, '0')}${rgbValues.b.toString(16).padStart(2, '0')}`.toUpperCase();
                            console.log('✓ Built Hex from API RGB (encoding only):', hexValue);
                        }
                        
                        // Log error if API failed to provide data
                        if (needsHex && hexValue === '#000000') {
                            console.error('❌ LittleCMS API failed to provide hex value');
                        }
                        if (needsRGB && rgbValues.r === 0 && rgbValues.g === 0 && rgbValues.b === 0) {
                            console.error('❌ LittleCMS API failed to provide RGB values');
                        }
                        
                        // Process CMYK API response if we made the call
                        if (needsCMYK && cmykResponse && cmykResponse.ok) {
                            const cmykData = await cmykResponse.json();
                            console.log('📥 LittleCMS CMYK API response:', cmykData);
                            
                            if (cmykData.gamut && cmykData.gamut.cmykEquivalent && Array.isArray(cmykData.gamut.cmykEquivalent)) {
                                const cmyk = cmykData.gamut.cmykEquivalent;
                                cmykValues = {
                                    c: parseFloat(cmyk[0].toFixed(1)),
                                    m: parseFloat(cmyk[1].toFixed(1)),
                                    y: parseFloat(cmyk[2].toFixed(1)),
                                    k: parseFloat(cmyk[3].toFixed(1))
                                };
                                console.log('✓ CMYK from LittleCMS API:', cmykValues);
                            } else if (cmykData.cmyk && Array.isArray(cmykData.cmyk)) {
                                cmykValues = {
                                    c: parseFloat(cmykData.cmyk[0].toFixed(1)),
                                    m: parseFloat(cmykData.cmyk[1].toFixed(1)),
                                    y: parseFloat(cmykData.cmyk[2].toFixed(1)),
                                    k: parseFloat(cmykData.cmyk[3].toFixed(1))
                                };
                                console.log('✓ CMYK from LittleCMS API (direct):', cmykValues);
                            } else if (needsCMYK) {
                                console.error('❌ API returned but no CMYK data:', cmykData);
                            }
                        } else if (needsCMYK && cmykResponse) {
                            console.error('❌ LittleCMS CMYK API failed:', cmykResponse.status, cmykResponse.statusText);
                        }
                    } catch (error) {
                        console.error('❌ LittleCMS API conversion failed:', error);
                        console.error('API call details:', {
                            apiUrl: getApiBaseUrl(),
                            lab: [L, a, b],
                            needsRGB,
                            needsHex,
                            needsCMYK
                        });
                        // Library data will be used if available, otherwise display will show error
                    }
                } else {
                    console.log('✅ All data from library - no API calls needed!');
                }
                
                // 🎯 VISUAL CONSISTENCY: Popup swatch = clicked swatch color
                // Use displayColor if provided (actual displayed color), otherwise build from data
                let swatchColor;
                if (displayColor) {
                    swatchColor = displayColor;
                    console.log('✓ Using clicked swatch color directly:', swatchColor);
                } else {
                    // Build from hex data
                    let displayHex = originalHex ? originalHex.toUpperCase() : hexValue;
                    if (!displayHex.startsWith('#')) {
                        displayHex = '#' + displayHex;
                    }
                    
                    // Validate hex - if invalid, the API conversion failed
                    if (!displayHex || displayHex === '#' || displayHex.length < 7) {
                        console.error('❌ Invalid hex value - LittleCMS API conversion failed!', {
                            displayHex,
                            hexValue,
                            originalHex,
                            lab: [L, a, b]
                        });
                        // Show a visible error swatch so user knows API failed
                        displayHex = '#FF0000'; // Red = API error
                    }
                    swatchColor = displayHex;
                }
                
                // Store all color values (for text display and copying)
                colorModal.currentColor = {
                    lab: `${L.toFixed(2)}, ${a.toFixed(2)}, ${b.toFixed(2)}`,
                    hex: hexValue.toUpperCase().startsWith('#') ? hexValue.toUpperCase() : '#' + hexValue.toUpperCase(),
                    rgb: `${rgbValues.r}, ${rgbValues.g}, ${rgbValues.b}`,
                    cmyk: `${cmykValues.c}, ${cmykValues.m}, ${cmykValues.y}, ${cmykValues.k}`
                };
                
                // NOW show the modal with all data ready - no flicker
                console.log('Setting modal swatch color to:', swatchColor);
                colorModal.swatch.style.background = swatchColor;
                
                // Only show name if it's from a library
                if (hasLibraryName && displayName) {
                    colorModal.name.textContent = displayName;
                    colorModal.name.style.display = 'block';
                } else {
                    colorModal.name.textContent = '';
                    colorModal.name.style.display = 'none';
                }
                
                // Update button colors based on background brightness
                const menuBtn = document.getElementById('cmw-color-modal-menu');
                const closeBtn = document.getElementById('cmw-color-modal-close');
                
                // Use Lab L value to determine icon color and outline
                // L >= 55: Light background - dark icons with NO outline
                // L < 55: Dark background - white icons with black outline
                
                if (L >= 55) {
                    // Light background: dark icons, no outline
                    menuBtn.style.color = '#374151';
                    menuBtn.style.textShadow = 'none';
                    closeBtn.style.color = '#374151';
                    closeBtn.style.textShadow = 'none';
                } else {
                    // Dark background: white icons with black outline
                    menuBtn.style.color = '#ffffff';
                    menuBtn.style.textShadow = '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000';
                    closeBtn.style.color = '#ffffff';
                    closeBtn.style.textShadow = '-1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000';
                }
                
                // Lab is "measured" if from library AND not calculated from spectral
                // Lab is "calculated" if derived from spectral data OR converted from user input
                const labIsMeasured = !!libraryName && !lab_calculated;
                console.log('🔍 Lab display check:', { 
                    libraryName, 
                    lab_calculated,
                    labIsMeasured 
                });
                if (labIsMeasured) {
                    console.log('📝 Lab measured (device M1 from X-Rite) → BOLD');
                    colorModal.lab.innerHTML = `<span style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-weight: 600; color: #020202;">${colorModal.currentColor.lab}</span>`;
                } else {
                    console.log('✨ Lab calculated (from spectral or user input) → MONOSPACE');
                    colorModal.lab.innerHTML = `<span style="font-family: 'SF Mono', 'Consolas', monospace; font-weight: 400; color: #1f2937;">${colorModal.currentColor.lab}</span>`;
                }
                
                // Make converted values distinguishable so users know they were calculated
                console.log('🎯 Styling check:', { needsHex, needsRGB, needsCMYK });
                
                if (needsHex) {
                    console.log('✨ Hex converted (lighter gray, monospace)');
                    colorModal.hex.innerHTML = `<span style="font-family: 'SF Mono', 'Consolas', monospace; font-weight: 400; color: #1f2937;">${colorModal.currentColor.hex}</span>`;
                } else {
                    console.log('📝 Hex known (darker, sans-serif)');
                    colorModal.hex.innerHTML = `<span style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-weight: 425; color: #020202;">${colorModal.currentColor.hex}</span>`;
                }
                
                if (needsRGB) {
                    console.log('✨ RGB converted (lighter gray, monospace)');
                    colorModal.rgb.innerHTML = `<span style="font-family: 'SF Mono', 'Consolas', monospace; font-weight: 400; color: #1f2937;">${colorModal.currentColor.rgb}</span>`;
                } else {
                    console.log('📝 RGB known (darker, sans-serif)');
                    colorModal.rgb.innerHTML = `<span style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-weight: 425; color: #020202;">${colorModal.currentColor.rgb}</span>`;
                }
                
                if (needsCMYK) {
                    console.log('✨ CMYK converted (lighter gray, monospace)');
                    colorModal.cmyk.innerHTML = `<span style="font-family: 'SF Mono', 'Consolas', monospace; font-weight: 400; color: #1f2937;">${colorModal.currentColor.cmyk}</span>`;
                } else {
                    console.log('📝 CMYK known (darker, sans-serif)');
                    colorModal.cmyk.innerHTML = `<span style="font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; font-weight: 425; color: #020202;">${colorModal.currentColor.cmyk}</span>`;
                }
                
                // Handle purchase links
                if (amazon_link || manufacturer_link) {
                    colorModal.purchaseLinks.style.display = 'flex';
                    
                    if (amazon_link) {
                        colorModal.amazonLink.href = amazon_link;
                        colorModal.amazonLink.style.display = 'inline-block';
                    } else {
                        colorModal.amazonLink.style.display = 'none';
                    }
                    
                    if (manufacturer_link) {
                        colorModal.manufacturerLink.href = manufacturer_link;
                        colorModal.manufacturerLink.style.display = 'inline-block';
                    } else {
                        colorModal.manufacturerLink.style.display = 'none';
                    }
                } else {
                    colorModal.purchaseLinks.style.display = 'none';
                }
                
                // Handle Spectral Data Display
                const modalTabs = document.getElementById('cmw-modal-tabs');
                const spectralTab = document.getElementById('cmw-tab-spectral');
                const valuesTab = document.getElementById('cmw-tab-values');
                
                console.log('🔍 Checking for spectral data:', { 
                    hasSpectral: !!spectral,
                    hasWavelengths: spectral?.wavelengths,
                    hasReflectance: spectral?.reflectance,
                    spectralObject: spectral
                });
                
                if (spectral && spectral.wavelengths && spectral.reflectance) {
                    console.log('🌈 Spectral data detected! Showing tabs...', spectral);
                    
                    // Store spectral data for tab switching
                    colorModal.currentSpectralData = spectral;
                    
                    // Show tabs
                    if (modalTabs) {
                        modalTabs.style.display = 'flex';
                        console.log('✅ Tabs displayed');
                    } else {
                        console.error('❌ modalTabs element not found!');
                    }
                    
                    // Reset to values tab (first tab active)
                    document.querySelectorAll('.cmw-modal-tab').forEach(t => t.classList.remove('active'));
                    const valuesTabBtn = document.querySelector('.cmw-modal-tab[data-tab="values"]');
                    if (valuesTabBtn) {
                        valuesTabBtn.classList.add('active');
                    }
                    
                    if (valuesTab) valuesTab.classList.add('active');
                    if (spectralTab) spectralTab.classList.remove('active');
                    
                    // Update spectral info
                    const rangeText = `${spectral.start || spectral.wavelengths[0]}nm - ${spectral.end || spectral.wavelengths[spectral.wavelengths.length - 1]}nm`;
                    const pointsText = `${spectral.data_points || spectral.wavelengths.length}`;
                    const rangeEl = document.getElementById('cmw-spectral-range');
                    const pointsEl = document.getElementById('cmw-spectral-points');
                    if (rangeEl) rangeEl.textContent = rangeText;
                    if (pointsEl) pointsEl.textContent = pointsText;
                    
                    console.log('✅ Spectral info updated:', { rangeText, pointsText });
                    
                } else {
                    console.log('ℹ️ No spectral data available for this color');
                    colorModal.currentSpectralData = null;
                    if (modalTabs) modalTabs.style.display = 'none';
                    if (valuesTab) valuesTab.classList.add('active');
                    if (spectralTab) spectralTab.classList.remove('active');
                }
                
                // Show closest library colors if user preference is enabled
                await displayClosestLibraryColors(L, a, b);
                
                colorModal.overlay.classList.add('show');
                document.body.style.overflow = 'hidden';
            }
            
            // Display closest library colors based on user preferences
            async function displayClosestLibraryColors(L, a, b) {
                try {
                    const closestSection = document.getElementById('cmw-modal-closest-colors');
                    const closestGrid = document.getElementById('cmw-modal-closest-colors-grid');
                    
                    // Check if elements exist
                    if (!closestSection || !closestGrid) {
                        console.warn('Closest colors elements not found');
                        return;
                    }
                    
                    // Check if user has enabled this feature
                    if (!userPreferences.showClosestLibraries || userPreferences.selectedLibraries.length === 0) {
                        closestSection.style.display = 'none';
                        return;
                    }
                    
                    // Check if libraries are loaded
                    if (typeof libs === 'undefined' || typeof libNames === 'undefined') {
                        console.warn('Libraries not loaded yet');
                        closestSection.style.display = 'none';
                        return;
                    }
                    
                    console.log('Finding closest colors in selected libraries:', userPreferences.selectedLibraries);
                    
                    // Check if required functions exist
                    if (typeof dE !== 'function' || typeof lab2rgb !== 'function') {
                        console.warn('Required color functions not available');
                        closestSection.style.display = 'none';
                        return;
                    }
                    
                    // Find the closest color from EACH selected library
                    const closestPerLibrary = [];
                    
                    userPreferences.selectedLibraries.forEach(libId => {
                        if (libs[libId] && libs[libId].length > 0) {
                            // Calculate Delta E for all colors in this library
                            const colorsWithDistance = libs[libId].map(color => ({
                                ...color,
                                libraryId: libId,
                                libraryName: libNames[libId] || libId,
                                deltaE: dE(L, a, b, color.L, color.a, color.b)
                            }));
                            
                            // Sort by deltaE
                            colorsWithDistance.sort((a, b) => a.deltaE - b.deltaE);
                            
                            // Find the first non-self match (deltaE >= 0.01)
                            // This ensures we never show a color as its own closest match
                            const closestNonSelf = colorsWithDistance.find(color => color.deltaE >= 0.01);
                            
                            if (closestNonSelf) {
                                closestPerLibrary.push(closestNonSelf);
                                if (colorsWithDistance[0].deltaE < 0.01) {
                                    console.log(`🚫 Modal: Excluded self-match in ${libNames[libId]}: ${colorsWithDistance[0].name} (ΔE=${colorsWithDistance[0].deltaE.toFixed(4)})`);
                                    console.log(`✓ Modal: Showing next closest: ${closestNonSelf.name} (ΔE=${closestNonSelf.deltaE.toFixed(4)})`);
                                }
                            } else {
                                // If only self-match exists, still push it (edge case for single-color libraries)
                                closestPerLibrary.push(colorsWithDistance[0]);
                            }
                        }
                    });
                    
                    if (closestPerLibrary.length === 0) {
                        closestSection.style.display = 'none';
                        return;
                    }
                    
                    // Determine grid columns based on number of libraries
                    // 1 lib = 1 column, 2 libs = 2 columns, 3 libs = 3 columns, 4+ libs = 4 columns
                    const numLibs = closestPerLibrary.length;
                    let gridColumns;
                    if (numLibs === 1) gridColumns = 1;
                    else if (numLibs === 2) gridColumns = 2;
                    else if (numLibs === 3) gridColumns = 3;
                    else gridColumns = 4; // 4 or more
                    
                    // Use minmax to ensure equal column widths
                    closestGrid.style.gridTemplateColumns = `repeat(${gridColumns}, minmax(0, 1fr))`;
                    
                    // Adjust gap based on number of columns
                    const gap = gridColumns >= 4 ? '8px' : '10px';
                    closestGrid.style.gap = gap;
                    
                    // Clear and populate grid
                    closestGrid.innerHTML = '';
                    
                    closestPerLibrary.forEach(color => {
                        const tile = document.createElement('div');
                        
                        // Adjust size based on grid columns
                        let tileHeight = '90px';
                        let fontSize = '12px';
                        let libFontSize = '11px';
                        let deltaFontSize = '10px';
                        let padding = '12px 8px';
                        
                        if (gridColumns === 1) {
                            tileHeight = '120px';
                            fontSize = '16px';
                            libFontSize = '14px';
                            deltaFontSize = '12px';
                            padding = '16px 12px';
                        } else if (gridColumns === 2) {
                            tileHeight = '110px';
                            fontSize = '14px';
                            libFontSize = '12px';
                            deltaFontSize = '11px';
                            padding = '14px 10px';
                        } else if (gridColumns === 3) {
                            tileHeight = '100px';
                            fontSize = '13px';
                            libFontSize = '11px';
                            deltaFontSize = '10px';
                            padding = '12px 8px';
                        }
                        
                        tile.style.cssText = `
                            background: ${lab2rgb(color.L, color.a, color.b)};
                            border: 2px solid #e2e8f0;
                            border-radius: 8px;
                            padding: ${padding};
                            cursor: pointer;
                            transition: all 0.2s ease;
                            display: flex;
                            flex-direction: column;
                            justify-content: center;
                            align-items: stretch;
                            height: ${tileHeight};
                            width: 100%;
                            box-sizing: border-box;
                            overflow: hidden;
                        `;
                        
                        const textColor = color.L > 60 ? '#1f2937' : '#ffffff';
                        const textShadow = color.L > 60 ? '0 1px 1px rgba(255,255,255,0.8)' : '0 1px 2px rgba(0,0,0,0.5)';
                        
                        // Adjust name truncation based on available space
                        let maxNameLength = 20;
                        if (gridColumns === 1) maxNameLength = 50;
                        else if (gridColumns === 2) maxNameLength = 30;
                        else if (gridColumns === 3) maxNameLength = 25;
                        
                        let colorNameForDisplay = color.name;
                        // Convert Crayola color names to lowercase
                        if (color.library === 'crayola') {
                            colorNameForDisplay = colorNameForDisplay.toLowerCase();
                        }
                        
                        const displayName = colorNameForDisplay.length > maxNameLength 
                            ? colorNameForDisplay.substring(0, maxNameLength - 2) + '...' 
                            : colorNameForDisplay;
                        
                        tile.innerHTML = `
                            <div style="color: ${textColor}; font-size: ${fontSize}; font-weight: 600; text-align: center; text-shadow: ${textShadow}; line-height: 1.3; margin-bottom: 4px; word-wrap: break-word; overflow-wrap: break-word;">
                                ${displayName}
                            </div>
                            <div style="color: ${textColor}; font-size: ${libFontSize}; text-align: center; text-shadow: ${textShadow}; opacity: 0.9; margin-bottom: 3px; font-weight: 500; word-wrap: break-word; overflow-wrap: break-word; word-break: break-all; line-height: 1.2;">
                                ${color.libraryName}
                            </div>
                            <div style="color: ${textColor}; font-size: ${deltaFontSize}; text-align: center; text-shadow: ${textShadow}; opacity: 0.8; font-weight: 600; letter-spacing: 0.3px;">
                                ΔE ${color.deltaE.toFixed(1)}
                            </div>
                        `;
                    
                        tile.addEventListener('mouseover', () => {
                            tile.style.transform = 'translateY(-3px) scale(1.02)';
                            tile.style.boxShadow = '0 6px 16px rgba(0,0,0,0.25)';
                            tile.style.borderColor = '#0065a3';
                            tile.style.zIndex = '10';
                        });
                        
                        tile.addEventListener('mouseout', () => {
                            tile.style.transform = '';
                            tile.style.boxShadow = '';
                            tile.style.borderColor = '#e2e8f0';
                            tile.style.zIndex = '';
                        });
                    
                    tile.addEventListener('click', () => {
                        const displayColor = window.getComputedStyle(tile).backgroundColor;
                        showColorModal({
                            name: color.name,
                            libraryName: color.libraryName,
                            L: color.L,
                            a: color.a,
                            b: color.b,
                            lab_calculated: color.lab_calculated,
                            spectral: color.spectral,
                            displayColor
                        });
                    });
                    
                    closestGrid.appendChild(tile);
                });
                
                closestSection.style.display = 'block';
                } catch (error) {
                    console.error('Error displaying closest library colors:', error);
                    // Hide section if there's an error
                    const closestSection = document.getElementById('cmw-modal-closest-colors');
                    if (closestSection) closestSection.style.display = 'none';
                }
            }
            
            // Hide the color modal
            function hideColorModal() {
                colorModal.overlay.classList.remove('show');
                document.body.style.overflow = '';
                // Also hide the menu dropdown
                hideMenuDropdown();
                
                // Reset color history when modal is closed
                colorHistory = [];
                currentHistoryIndex = -1;
                originalColor = null;
                updateHistoryNavigation();
            }
            
            // Hide menu dropdown
            function hideMenuDropdown() {
                const menuDropdown = document.getElementById('cmw-color-modal-dropdown');
                if (menuDropdown) menuDropdown.style.display = 'none';
            }
            
            // Show prompt to add color to library
            function showAddToLibraryPrompt() {
                if (!colorModal.currentLabValues || !colorModal.currentColor) {
                    alert('No color data available');
                    return;
                }
                
                // Prompt for color name
                const colorName = prompt('Enter a name for this color:', colorModal.currentColor.hex);
                if (!colorName) return; // User cancelled
                
                // Check if we have any libraries
                if (Object.keys(customLibraries).length === 0) {
                    // No libraries - prompt to create one
                    const libraryName = prompt('No libraries found. Enter a name for a new library:');
                    if (!libraryName) return;
                    
                    // Create the library
                    const id = generateLibraryId(libraryName);
                    customLibraries[id] = { name: libraryName, colors: [] };
                    
                    // Add color to the new library
                    const { L, a, b } = colorModal.currentLabValues;
                    customLibraries[id].colors.push({
                        name: colorName,
                        L: L,
                        a: a,
                        b: b
                    });
                    
                    saveCustomLibraries();
                    updateLibrarySelector();
                    
                    // Update unified Color Libraries selector
                    if (typeof populateLibrariesSelector === 'function') {
                        populateLibrariesSelector();
                    }
                    
                    alert(`Color "${colorName}" added to new library "${libraryName}"`);
                    return;
                }
                
                // Show library selection
                let libraryOptions = '';
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    libraryOptions += `${id}: ${lib.name} (${lib.colors?.length || 0} colors)\n`;
                });
                
                const libraryChoice = prompt(
                    `Select library by entering its ID:\n\n${libraryOptions}\nOr type "new" to create a new library:`
                );
                
                if (!libraryChoice) return; // User cancelled
                
                let targetLibraryId;
                
                if (libraryChoice.toLowerCase() === 'new') {
                    // Create new library
                    const newLibraryName = prompt('Enter a name for the new library:');
                    if (!newLibraryName) return;
                    
                    targetLibraryId = generateLibraryId(newLibraryName);
                    customLibraries[targetLibraryId] = { name: newLibraryName, colors: [] };
                } else if (customLibraries[libraryChoice]) {
                    targetLibraryId = libraryChoice;
                } else {
                    alert('Invalid library ID');
                    return;
                }
                
                // Add color to library
                const { L, a, b } = colorModal.currentLabValues;
                customLibraries[targetLibraryId].colors.push({
                    name: colorName,
                    L: L,
                    a: a,
                    b: b
                });
                
                saveCustomLibraries();
                updateLibrarySelector();
                
                // Update unified Color Libraries selector
                if (typeof populateLibrariesSelector === 'function') {
                    populateLibrariesSelector();
                }
                
                // If this library is currently selected, refresh it
                if (currentCustomLibraryId === targetLibraryId) {
                    renderCurrentLibraryColors();
                }
                
                alert(`Color "${colorName}" added to ${customLibraries[targetLibraryId].name}`);
            }
            
            // Copy value to clipboard
            function copyColorValue(type) {
                if (!colorModal.currentColor) return;
                
                let textToCopy = colorModal.currentColor[type];
                if (type === 'lab') textToCopy = `Lab(${textToCopy})`;
                if (type === 'rgb') textToCopy = `RGB(${textToCopy})`;
                if (type === 'cmyk') textToCopy = `CMYK(${textToCopy})`;
                
                navigator.clipboard.writeText(textToCopy).then(() => {
                    // Visual feedback
                    const row = document.querySelector(`.cmw-color-value-row[data-type="${type}"]`);
                    row.classList.add('cmw-color-copied');
                    setTimeout(() => row.classList.remove('cmw-color-copied'), 500);
                });
            }
            
            // Event listeners for modal
            colorModal.closeBtn.addEventListener('click', hideColorModal);
            colorModal.overlay.addEventListener('click', (e) => {
                if (e.target === colorModal.overlay) hideColorModal();
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && colorModal.overlay.classList.contains('show')) {
                    hideColorModal();
                }
            });
            
            // Menu button toggle
            const menuBtn = document.getElementById('cmw-color-modal-menu');
            const menuDropdown = document.getElementById('cmw-color-modal-dropdown');
            
            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                menuDropdown.style.display = menuDropdown.style.display === 'none' ? 'block' : 'none';
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', (e) => {
                if (!menuBtn.contains(e.target) && !menuDropdown.contains(e.target)) {
                    menuDropdown.style.display = 'none';
                }
            });
            
            // Handle menu item clicks
            menuDropdown.addEventListener('click', (e) => {
                const menuItem = e.target.closest('.cmw-modal-menu-item');
                if (!menuItem) return;
                
                const action = menuItem.dataset.action;
                menuDropdown.style.display = 'none';
                
                if (action === 'preferences') {
                    hideColorModal();
                    openPreferencesModal();
                } else if (action === 'add-to-library') {
                    // Show prompt to add color to library
                    hideMenuDropdown();
                    showAddToLibraryPrompt();
                } else if (action === 'add-to-search') {
                    // Use this color in search - populate the input field with color name or hex
                    if (colorModal.currentColorData && colorModal.currentColor) {
                        const nameInput = document.getElementById('cmw-name-input');
                        const preview = document.getElementById('cmw-color-preview');
                        const searchTypeSelect = document.getElementById('cmw-search-type-select');
                        const data = colorModal.currentColorData;
                        
                        // Switch to name/hex search mode (manually to preserve data)
                        searchTypeSelect.value = 'name';
                        
                        // Show/hide input sections
                        document.getElementById('cmw-name-inputs').classList.add('active');
                        document.getElementById('cmw-lab-inputs').classList.remove('active');
                        document.getElementById('cmw-cmyk-inputs').classList.remove('active');
                        document.getElementById('cmw-rgb-inputs').classList.remove('active');
                        
                        // Hide profile selector
                        document.getElementById('cmw-profile-selector').style.display = 'none';
                        
                        // Populate search with color name (if from library) or hex value
                        if (data.libraryName && data.name) {
                            // Use the library color name
                            nameInput.value = data.name;
                        } else {
                            // Use hex value
                            nameInput.value = colorModal.currentColor.hex;
                        }
                        
                        // Trigger input event so the app recognizes the text change
                        nameInput.dispatchEvent(new Event('input', { bubbles: true }));
                        nameInput.dispatchEvent(new Event('change', { bubbles: true }));
                        
                        // Update preview with color data
                        const color = lab2rgb(data.L, data.a, data.b);
                        preview.style.backgroundColor = color;
                        preview.style.borderColor = '#e2e8f0';
                        preview.classList.add('valid', 'selected');
                        
                        // Store data in preview for search
                        preview.dataset.selectedL = data.L;
                        preview.dataset.selectedA = data.a;
                        preview.dataset.selectedB = data.b;
                        preview.dataset.selectedColor = color;
                        preview.dataset.selectedName = data.name || '';
                        preview.dataset.selectedLibrary = data.libraryName || '';
                        preview.dataset.amazonLink = data.amazon_link || '';
                        preview.dataset.manufacturerLink = data.manufacturer_link || '';
                        preview.dataset.hex = data.hex || colorModal.currentColor.hex;
                        preview.dataset.rgbR = data.rgb_r || '';
                        preview.dataset.rgbG = data.rgb_g || '';
                        preview.dataset.rgbB = data.rgb_b || '';
                        preview.dataset.cmykC = data.cmyk_c || '';
                        preview.dataset.cmykM = data.cmyk_m || '';
                        preview.dataset.cmykY = data.cmyk_y || '';
                        preview.dataset.cmykK = data.cmyk_k || '';
                        
                        // Close modal
                        hideColorModal();
                        
                        // Trigger search
                        performUnifiedSearch();
                    }
                } else if (action === 'copy-all') {
                    // Copy all color values
                    if (colorModal.currentColor) {
                        const allValues = `Lab: ${colorModal.currentColor.lab}\nHex: ${colorModal.currentColor.hex}\nRGB: ${colorModal.currentColor.rgb}\nCMYK: ${colorModal.currentColor.cmyk}`;
                        navigator.clipboard.writeText(allValues).then(() => {
                            // Visual feedback
                            menuItem.textContent = '✓ Copied!';
                            setTimeout(() => {
                                menuItem.textContent = '📋 Copy All Values';
                            }, 1000);
                        });
                    }
                }
            });
            
            // Copy on click
            document.querySelectorAll('.cmw-color-value-row').forEach(row => {
                row.addEventListener('click', () => {
                    copyColorValue(row.dataset.type);
                });
            });
            
            // Modal Add to Library functionality (legacy - now handled by hamburger menu)
            const modalAddToggle = document.getElementById('cmw-modal-add-toggle');
            const modalAddContent = document.getElementById('cmw-modal-add-content');
            const modalLibrarySelect = document.getElementById('cmw-modal-library-select');
            const modalNewLibBtn = document.getElementById('cmw-modal-new-lib-btn');
            const modalNewLibRow = document.getElementById('cmw-modal-new-lib-row');
            const modalNewLibName = document.getElementById('cmw-modal-new-lib-name');
            const modalCreateLibBtn = document.getElementById('cmw-modal-create-lib-btn');
            const modalColorName = document.getElementById('cmw-modal-color-name');
            const modalAddBtn = document.getElementById('cmw-modal-add-btn');
            const modalAddStatus = document.getElementById('cmw-modal-add-status');
            
            // Toggle add to library section
            if (modalAddToggle) {
            modalAddToggle.addEventListener('click', () => {
                const isHidden = modalAddContent.style.display === 'none';
                modalAddContent.style.display = isHidden ? 'flex' : 'none';
                modalAddToggle.querySelector('span').textContent = isHidden ? '− Add to Library' : '+ Add to Library';
                
                if (isHidden) {
                    // Populate library dropdown
                    updateModalLibraryDropdown();
                    // Pre-fill color name from modal title
                    const currentName = colorModal.name.textContent;
                    if (currentName && currentName !== 'Color' && currentName !== 'Current Color' && currentName !== 'Selected Color') {
                        modalColorName.value = currentName;
                    }
                }
            });
            }
            
            // Update library dropdown in modal
            function updateModalLibraryDropdown() {
                if (!modalLibrarySelect) return;
                modalLibrarySelect.innerHTML = '<option value="">-- Select Library --</option>';
                
                Object.entries(customLibraries).forEach(([id, lib]) => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = `${lib.name} (${lib.colors?.length || 0})`;
                    modalLibrarySelect.appendChild(option);
                });
                
                // If there are no libraries, show the new library row
                if (Object.keys(customLibraries).length === 0 && modalNewLibRow && modalNewLibBtn) {
                    modalNewLibRow.style.display = 'flex';
                    modalNewLibBtn.style.display = 'none';
                }
            }
            
            // Toggle new library input
            if (modalNewLibBtn) {
            modalNewLibBtn.addEventListener('click', () => {
                const isHidden = modalNewLibRow.style.display === 'none';
                modalNewLibRow.style.display = isHidden ? 'flex' : 'none';
                if (isHidden) {
                    modalNewLibName.focus();
                }
            });
            }
            
            // Create new library from modal
            if (modalCreateLibBtn) {
            modalCreateLibBtn.addEventListener('click', () => {
                const name = modalNewLibName.value.trim();
                if (!name) {
                    showModalStatus('Please enter a library name', 'error');
                    return;
                }
                
                // Check for duplicate names
                const exists = Object.values(customLibraries).some(lib => 
                    lib.name.toLowerCase() === name.toLowerCase()
                );
                
                if (exists) {
                    showModalStatus('Library name already exists', 'error');
                    return;
                }
                
                // Create the library
                const id = generateLibraryId(name);
                customLibraries[id] = { name, colors: [] };
                saveCustomLibraries();
                
                // Update dropdowns
                updateModalLibraryDropdown();
                updateLibrarySelector();
                
                // Select the new library
                modalLibrarySelect.value = id;
                modalNewLibRow.style.display = 'none';
                modalNewLibName.value = '';
                modalNewLibBtn.style.display = 'block';
                
                showModalStatus(`Created "${name}"`, 'success');
            });
            }
            
            // Enter key for new library name
            if (modalNewLibName) {
            modalNewLibName.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    modalCreateLibBtn.click();
                }
            });
            }
            
            // Add color to library from modal
            if (modalAddBtn) {
            modalAddBtn.addEventListener('click', () => {
                const libraryId = modalLibrarySelect.value;
                if (!libraryId) {
                    showModalStatus('Please select a library', 'error');
                    return;
                }
                
                if (!colorModal.currentLabValues) {
                    showModalStatus('No color data available', 'error');
                    return;
                }
                
                const { L, a, b } = colorModal.currentLabValues;
                let colorName = modalColorName.value.trim();
                
                // Generate a default name if none provided
                if (!colorName) {
                    colorName = colorModal.currentColor.hex || `Color ${Date.now()}`;
                }
                
                // Add to library
                customLibraries[libraryId].colors.push({
                    name: colorName,
                    L: L,
                    a: a,
                    b: b
                });
                
                saveCustomLibraries();
                updateLibrarySelector();
                
                // If this library is currently selected in the main UI, refresh it
                if (currentCustomLibraryId === libraryId) {
                    renderCurrentLibraryColors();
                }
                
                const libName = customLibraries[libraryId].name;
                showModalStatus(`Added "${colorName}" to ${libName}`, 'success');
                
                // Clear the color name input for next add
                modalColorName.value = '';
            });
            }
            
            // Show status message in modal
            function showModalStatus(message, type) {
                if (!modalAddStatus) return;
                modalAddStatus.textContent = message;
                modalAddStatus.className = `cmw-modal-add-status ${type}`;
                setTimeout(() => {
                    modalAddStatus.className = 'cmw-modal-add-status';
                }, 3000);
            }
            
            // Delegate click events for all swatches (results table, custom library, etc.)
            document.addEventListener('click', (e) => {
                console.log('Click detected:', e.target);
                
                // Check for main color search preview swatch
                const mainPreview = e.target.closest('#cmw-color-preview');
                if (mainPreview) {
                    console.log('Main preview clicked');
                    // Get Lab values from the preview's dataset or current color data
                    const L = parseFloat(mainPreview.dataset.selectedL);
                    const a = parseFloat(mainPreview.dataset.selectedA);
                    const b = parseFloat(mainPreview.dataset.selectedB);
                    const name = mainPreview.dataset.selectedName || 'Selected Color';
                    const libraryName = mainPreview.dataset.selectedLibrary || '';
                    
                    if (!isNaN(L) && !isNaN(a) && !isNaN(b)) {
                        // Library color selected - pass all metadata including purchase links, RGB & CMYK
                        const rgb_r = mainPreview.dataset.rgbR && mainPreview.dataset.rgbR !== '' ? parseFloat(mainPreview.dataset.rgbR) : undefined;
                        const rgb_g = mainPreview.dataset.rgbG && mainPreview.dataset.rgbG !== '' ? parseFloat(mainPreview.dataset.rgbG) : undefined;
                        const rgb_b = mainPreview.dataset.rgbB && mainPreview.dataset.rgbB !== '' ? parseFloat(mainPreview.dataset.rgbB) : undefined;
                        const cmyk_c = mainPreview.dataset.cmykC && mainPreview.dataset.cmykC !== '' ? parseFloat(mainPreview.dataset.cmykC) : undefined;
                        const cmyk_m = mainPreview.dataset.cmykM && mainPreview.dataset.cmykM !== '' ? parseFloat(mainPreview.dataset.cmykM) : undefined;
                        const cmyk_y = mainPreview.dataset.cmykY && mainPreview.dataset.cmykY !== '' ? parseFloat(mainPreview.dataset.cmykY) : undefined;
                        const cmyk_k = mainPreview.dataset.cmykK && mainPreview.dataset.cmykK !== '' ? parseFloat(mainPreview.dataset.cmykK) : undefined;
                        
                        // Get the actual displayed color from the swatch
                        const displayColor = window.getComputedStyle(mainPreview).backgroundColor;
                        
                        showColorModal({ 
                            name, 
                            libraryName, 
                            L, 
                            a, 
                            b,
                            amazon_link: mainPreview.dataset.amazonLink,
                            manufacturer_link: mainPreview.dataset.manufacturerLink,
                            hex: mainPreview.dataset.hex || undefined,
                            rgb_r,
                            rgb_g,
                            rgb_b,
                            cmyk_c,
                            cmyk_m,
                            cmyk_y,
                            cmyk_k,
                            displayColor
                        });
                    } else if (currentColorData && currentColorData.L !== undefined) {
                        // User entered a value (hex, Lab, RGB, CMYK)
                        // Only pass originalHex if user typed a hex directly
                        const originalHexInput = mainPreview.dataset.originalHexInput;
                        
                        // Get the actual displayed color from the swatch
                        const displayColor = window.getComputedStyle(mainPreview).backgroundColor;
                        
                        showColorModal({
                            name: 'Current Color',
                            L: currentColorData.L,
                            a: currentColorData.a,
                            b: currentColorData.b,
                            originalHex: originalHexInput || null, // Only set if user typed hex
                            displayColor
                        });
                    }
                    return;
                }
                
                // Check for compare swatches
                const compareSwatch = e.target.closest('#cmw-compare-swatch-1, #cmw-compare-swatch-2');
                if (compareSwatch) {
                    const colorNum = compareSwatch.id === 'cmw-compare-swatch-1' ? 1 : 2;
                    const compareColor = colorNum === 1 ? compareColor1 : compareColor2;
                    
                    console.log(`🔍 Compare Color ${colorNum} clicked:`, compareColor);
                    
                    if (compareColor && compareColor.lab) {
                        // Get the actual displayed color from the clicked swatch
                        const displayColor = window.getComputedStyle(compareSwatch).backgroundColor;
                        
                        const modalData = {
                            name: compareColor.name || `Color ${colorNum}`,
                            libraryName: compareColor.libraryName || '',
                            L: compareColor.lab.L,
                            a: compareColor.lab.a,
                            b: compareColor.lab.b,
                            hex: compareColor.hex,
                            originalHex: compareColor.hex,
                            // Pass RGB if user entered RGB values
                            rgb_r: compareColor.rgb_r,
                            rgb_g: compareColor.rgb_g,
                            rgb_b: compareColor.rgb_b,
                            // Pass CMYK if user entered CMYK values
                            cmyk_c: compareColor.cmyk_c,
                            cmyk_m: compareColor.cmyk_m,
                            cmyk_y: compareColor.cmyk_y,
                            cmyk_k: compareColor.cmyk_k,
                            displayColor
                        };
                        console.log('📤 Passing to modal:', modalData);
                        showColorModal(modalData);
                    }
                    return;
                }
                
                // Check for result table rows - read data from row dataset (including RGB & CMYK)
                const tableRow = e.target.closest('#cmw-out tbody tr');
                console.log('Table row check:', tableRow, tableRow?.dataset);
                if (tableRow && tableRow.dataset.colorL) {
                    console.log('Opening modal for table row:', tableRow.dataset.colorName);
                    
                    // Parse RGB if present (convert empty strings to undefined)
                    const rgb_r = tableRow.dataset.rgbR && tableRow.dataset.rgbR !== '' ? parseFloat(tableRow.dataset.rgbR) : undefined;
                    const rgb_g = tableRow.dataset.rgbG && tableRow.dataset.rgbG !== '' ? parseFloat(tableRow.dataset.rgbG) : undefined;
                    const rgb_b = tableRow.dataset.rgbB && tableRow.dataset.rgbB !== '' ? parseFloat(tableRow.dataset.rgbB) : undefined;
                    
                    // Parse CMYK if present (convert empty strings to undefined)
                    const cmyk_c = tableRow.dataset.cmykC && tableRow.dataset.cmykC !== '' ? parseFloat(tableRow.dataset.cmykC) : undefined;
                    const cmyk_m = tableRow.dataset.cmykM && tableRow.dataset.cmykM !== '' ? parseFloat(tableRow.dataset.cmykM) : undefined;
                    const cmyk_y = tableRow.dataset.cmykY && tableRow.dataset.cmykY !== '' ? parseFloat(tableRow.dataset.cmykY) : undefined;
                    const cmyk_k = tableRow.dataset.cmykK && tableRow.dataset.cmykK !== '' ? parseFloat(tableRow.dataset.cmykK) : undefined;
                    
                    // Get the actual displayed color from the swatch in the table row
                    const swatchElement = tableRow.querySelector('.cmw-swatch');
                    const displayColor = swatchElement ? window.getComputedStyle(swatchElement).backgroundColor : null;
                    
                    // Try to get spectral data from libs object if available
                    let spectral = null;
                    if (tableRow.dataset.hasSpectral === 'true' && tableRow.dataset.library) {
                        const libId = tableRow.dataset.library;
                        const colorName = tableRow.dataset.colorName;
                        if (libs[libId]) {
                            const fullColor = libs[libId].find(c => c.name === colorName);
                            if (fullColor && fullColor.spectral) {
                                spectral = fullColor.spectral;
                            }
                        }
                    }
                    
                    showColorModal({
                        name: tableRow.dataset.colorName,
                        library: tableRow.dataset.library,
                        L: parseFloat(tableRow.dataset.colorL),
                        a: parseFloat(tableRow.dataset.colorA),
                        b: parseFloat(tableRow.dataset.colorB),
                        libraryName: tableRow.dataset.libraryName,
                        amazon_link: tableRow.dataset.amazonLink,
                        manufacturer_link: tableRow.dataset.manufacturerLink,
                        hex: tableRow.dataset.hex || undefined,
                        originalHex: tableRow.dataset.hex,
                        manufacturer: tableRow.dataset.manufacturer,
                        lab_calculated: tableRow.dataset.labCalculated === 'true',
                        filament_type: tableRow.dataset.filamentType,
                        rgb_r,
                        rgb_g,
                        rgb_b,
                        cmyk_c,
                        cmyk_m,
                        cmyk_y,
                        cmyk_k,
                        displayColor,
                        spectral
                    });
                    return;
                }
                
                // Check for consensus swatch
                const consensusSwatch = e.target.closest('#cmw-consensus-swatch');
                if (consensusSwatch) {
                    const labText = document.getElementById('cmw-consensus-lab').textContent;
                    const labMatch = labText.match(/Lab\(([\d.-]+)\s*,\s*([\d.-]+)\s*,\s*([\d.-]+)\)/);
                    if (labMatch) {
                        // Get the actual displayed color from the swatch
                        const displayColor = window.getComputedStyle(consensusSwatch).backgroundColor;
                        
                        showColorModal({
                            name: 'Consensus Color',
                            L: parseFloat(labMatch[1]),
                            a: parseFloat(labMatch[2]),
                            b: parseFloat(labMatch[3]),
                            displayColor
                        });
                    }
                    return;
                }
                
                // Check for intent swatches
                const intentSwatch = e.target.closest('.cmw-intent-swatch');
                if (intentSwatch) {
                    const card = intentSwatch.closest('.cmw-intent-card');
                    if (card) {
                        const labEl = card.querySelector('.cmw-intent-lab');
                        const nameEl = card.querySelector('.cmw-intent-name');
                        // Get the LittleCMS hex stored when the swatch was displayed
                        const lcmsHex = intentSwatch.dataset.lcmsHex || null;
                        if (labEl && nameEl) {
                            const labText = labEl.textContent;
                            const labMatch = labText.match(/Lab\(([\d.-]+)\s*,\s*([\d.-]+)\s*,\s*([\d.-]+)\)/);
                            if (labMatch) {
                                // Get the actual displayed color from the swatch
                                const displayColor = window.getComputedStyle(intentSwatch).backgroundColor;
                                
                                showColorModal({
                                    name: nameEl.textContent,
                                    L: parseFloat(labMatch[1]),
                                    a: parseFloat(labMatch[2]),
                                    b: parseFloat(labMatch[3]),
                                    originalHex: lcmsHex, // Use stored LittleCMS hex for consistency
                                    displayColor
                                });
                            }
                        }
                    }
                    return;
                }
                
                // Check for harmony swatches
                const harmonySwatch = e.target.closest('.cmw-harmony-swatch');
                if (harmonySwatch) {
                    const labL = parseFloat(harmonySwatch.dataset.labL);
                    const labA = parseFloat(harmonySwatch.dataset.labA);
                    const labB = parseFloat(harmonySwatch.dataset.labB);
                    const colorName = harmonySwatch.dataset.colorName || 'Harmony Color';
                    const libraryName = harmonySwatch.dataset.libraryName || '';
                    // Use the LittleCMS hex value stored when the harmony was displayed
                    const lcmsHex = harmonySwatch.dataset.lcmsHex || null;
                    
                    if (!isNaN(labL) && !isNaN(labA) && !isNaN(labB)) {
                        // Get the actual displayed color from the swatch
                        const displayColor = window.getComputedStyle(harmonySwatch).backgroundColor;
                        
                        showColorModal({
                            name: colorName,
                            libraryName: libraryName,
                            L: labL,
                            a: labA,
                            b: labB,
                            originalHex: lcmsHex, // Pass the LittleCMS hex to ensure consistency
                            amazon_link: harmonySwatch.dataset.amazonLink || null,
                            manufacturer_link: harmonySwatch.dataset.manufacturerLink || null,
                            displayColor
                        });
                    }
                    return;
                }
                
                // Check for sample preview swatch (the input preview)
                const samplePreviewSwatch = e.target.closest('#cmw-sample-preview-swatch');
                if (samplePreviewSwatch) {
                    const format = document.getElementById('cmw-sample-format').value;
                    
                    // Use async IIFE to allow await for LittleCMS API calls
                    (async () => {
                        let L, a, b;
                        let originalHex = null;
                        
                        try {
                            if (format === 'hex') {
                                const hex = document.getElementById('cmw-sample-hex').value.trim();
                                if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                                    originalHex = '#' + hex.toUpperCase();
                                    const rgb = hex2rgb(hex);
                                    if (rgb) {
                                        // Use LittleCMS API for hex → Lab conversion
                                        const data = await convertColor({
                                            rgb: [rgb.r, rgb.g, rgb.b],
                                            profile: 'sRGB.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    }
                                }
                            } else if (format === 'lab') {
                                L = parseFloat(document.getElementById('cmw-sample-lab-l').value);
                                a = parseFloat(document.getElementById('cmw-sample-lab-a').value);
                                b = parseFloat(document.getElementById('cmw-sample-lab-b').value);
                            } else if (format === 'rgb') {
                                const r = parseInt(document.getElementById('cmw-sample-rgb-r').value);
                                const g = parseInt(document.getElementById('cmw-sample-rgb-g').value);
                                const bVal = parseInt(document.getElementById('cmw-sample-rgb-b').value);
                                if (!isNaN(r) && !isNaN(g) && !isNaN(bVal)) {
                                    // Use LittleCMS API for RGB → Lab conversion
                                    const data = await convertColor({
                                        rgb: [r, g, bVal],
                                        profile: 'sRGB.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            } else if (format === 'cmyk') {
                                const c = parseFloat(document.getElementById('cmw-sample-cmyk-c').value);
                                const m = parseFloat(document.getElementById('cmw-sample-cmyk-m').value);
                                const y = parseFloat(document.getElementById('cmw-sample-cmyk-y').value);
                                const k = parseFloat(document.getElementById('cmw-sample-cmyk-k').value);
                                if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                                    // Use LittleCMS API for CMYK → Lab conversion
                                    const data = await convertColor({
                                        cmyk: [c, m, y, k],
                                        profile: 'GRACoL2013.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            }
                            
                            if (L !== undefined && !isNaN(L)) {
                                const label = document.getElementById('cmw-sample-label').value.trim();
                                showColorModal({
                                    name: label || 'Preview Color',
                                    L: L,
                                    a: a,
                                    b: b,
                                    originalHex: originalHex
                                });
                            }
                        } catch (err) {
                            console.error('Failed to convert preview color for modal:', err);
                        }
                    })();
                    return;
                }
                
                // Check for custom library preview swatch
                const customPreviewSwatch = e.target.closest('#cmw-custom-preview-swatch');
                if (customPreviewSwatch) {
                    const format = document.getElementById('cmw-custom-format').value;
                    
                    // Use async IIFE to allow await for LittleCMS API calls
                    (async () => {
                        let L, a, b;
                        let originalHex = null;
                        
                        try {
                            if (format === 'hex') {
                                const hex = document.getElementById('cmw-custom-hex').value.trim();
                                if (/^[0-9A-Fa-f]{6}$/.test(hex)) {
                                    originalHex = '#' + hex.toUpperCase();
                                    const rgb = hex2rgb(hex);
                                    if (rgb) {
                                        // Use LittleCMS API for hex → Lab conversion
                                        const data = await convertColor({
                                            rgb: [rgb.r, rgb.g, rgb.b],
                                            profile: 'sRGB.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    }
                                }
                            } else if (format === 'lab') {
                                L = parseFloat(document.getElementById('cmw-custom-lab-l').value);
                                a = parseFloat(document.getElementById('cmw-custom-lab-a').value);
                                b = parseFloat(document.getElementById('cmw-custom-lab-b').value);
                            } else if (format === 'rgb') {
                                const r = parseInt(document.getElementById('cmw-custom-rgb-r').value);
                                const g = parseInt(document.getElementById('cmw-custom-rgb-g').value);
                                const bVal = parseInt(document.getElementById('cmw-custom-rgb-b').value);
                                if (!isNaN(r) && !isNaN(g) && !isNaN(bVal)) {
                                    // Use LittleCMS API for RGB → Lab conversion
                                    const data = await convertColor({
                                        rgb: [r, g, bVal],
                                        profile: 'sRGB.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            } else if (format === 'cmyk') {
                                const c = parseFloat(document.getElementById('cmw-custom-cmyk-c').value);
                                const m = parseFloat(document.getElementById('cmw-custom-cmyk-m').value);
                                const y = parseFloat(document.getElementById('cmw-custom-cmyk-y').value);
                                const k = parseFloat(document.getElementById('cmw-custom-cmyk-k').value);
                                if (!isNaN(c) && !isNaN(m) && !isNaN(y) && !isNaN(k)) {
                                    // Use LittleCMS API for CMYK → Lab conversion
                                    const data = await convertColor({
                                        cmyk: [c, m, y, k],
                                        profile: 'GRACoL2013.icc'
                                    });
                                    L = data.lab[0];
                                    a = data.lab[1];
                                    b = data.lab[2];
                                }
                            }
                            
                            if (L !== undefined && !isNaN(L)) {
                                const colorName = document.getElementById('cmw-custom-color-name').value.trim();
                                showColorModal({
                                    name: colorName || 'Preview Color',
                                    L: L,
                                    a: a,
                                    b: b,
                                    originalHex: originalHex
                                });
                            }
                        } catch (err) {
                            console.error('Failed to convert custom preview color for modal:', err);
                        }
                    })();
                    return;
                }
                
                // Check for sample swatches in consensus section
                const sampleSwatch = e.target.closest('.cmw-sample-swatch');
                if (sampleSwatch) {
                    const row = sampleSwatch.closest('.cmw-sample-row');
                    if (row) {
                        const sampleId = parseInt(row.dataset.sampleId);
                        const sample = consensusSamples.find(s => s.id === sampleId);
                        const sampleIndex = consensusSamples.findIndex(s => s.id === sampleId);
                        if (sample) {
                            // Use normalizedLab if available (from API after calculation)
                            // This ensures consistency with what's displayed
                            if (sample.normalizedLab && Array.isArray(sample.normalizedLab)) {
                                const originalHex = sample.format === 'hex' ? sample.value : null;
                                showColorModal({
                                    name: sample.label || `Sample ${sampleIndex + 1}`,
                                    L: sample.normalizedLab[0],
                                    a: sample.normalizedLab[1],
                                    b: sample.normalizedLab[2],
                                    originalHex: originalHex
                                });
                                return;
                            }
                            
                            // If no normalizedLab, use LittleCMS API for conversion
                            (async () => {
                                let L, a, b;
                                let originalHex = null;
                                
                                try {
                                    if (sample.format === 'lab') {
                                        // Lab is stored as array [L, a, b]
                                        L = sample.value[0];
                                        a = sample.value[1];
                                        b = sample.value[2];
                                    } else if (sample.format === 'hex') {
                                        // Use LittleCMS API for hex → Lab conversion
                                        originalHex = sample.value;
                                        const rgb = hex2rgb(sample.value);
                                        if (rgb) {
                                            const data = await convertColor({
                                                rgb: [rgb.r, rgb.g, rgb.b],
                                                profile: 'sRGB.icc'
                                            });
                                            L = data.lab[0];
                                            a = data.lab[1];
                                            b = data.lab[2];
                                        }
                                    } else if (sample.format === 'rgb') {
                                        // Use LittleCMS API for RGB → Lab conversion
                                        const data = await convertColor({
                                            rgb: sample.value,
                                            profile: 'sRGB.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    } else if (sample.format === 'cmyk') {
                                        // Use LittleCMS API for CMYK → Lab conversion
                                        const data = await convertColor({
                                            cmyk: sample.value,
                                            profile: 'GRACoL2013.icc'
                                        });
                                        L = data.lab[0];
                                        a = data.lab[1];
                                        b = data.lab[2];
                                    }
                                    
                                    if (L !== undefined) {
                                        showColorModal({
                                            name: sample.label || `Sample ${sampleIndex + 1}`,
                                            L: L,
                                            a: a,
                                            b: b,
                                            originalHex: originalHex
                                        });
                                    }
                                } catch (err) {
                                    console.error('Failed to convert sample color for modal:', err);
                                }
                            })();
                        }
                    }
                    return;
                }
            });
        })();
        
        // Global console function to toggle Color Library section visibility
        window.colorLibrary = function() {
            const section = document.getElementById('cmw-color-library-section');
            if (section) {
                const isHidden = section.style.display === 'none';
                section.style.display = isHidden ? 'block' : 'none';
                console.log(`Color Library section ${isHidden ? 'shown' : 'hidden'}`);
            } else {
                console.error('Color Library section not found');
            }
        };
        
        console.log('💡 Type colorLibrary() in the console to toggle the Color Library section');
    </script>
    
    <!-- X-Rite Live Integration -->
    <script src="xrite_live_integration.js"></script>
</body>
</html>
